/*! For license information please see mindar-image-three.prod.js.LICENSE.txt */
(()=>{var t={485:(t,e,n)=>{"use strict";n.d(e,{Z:()=>o});var r=n(81),i=n.n(r),s=n(645),a=n.n(s)()(i());a.push([t.id,".mindar-ui-overlay{display:flex;align-items:center;justify-content:center;position:absolute;left:0;right:0;top:0;bottom:0;background:rgba(0,0,0,0)}.mindar-ui-overlay.hidden{display:none}.mindar-ui-loading .loader{border:16px solid #222;border-top:16px solid #fff;opacity:.8;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.mindar-ui-compatibility .content{background:#000;color:#fff;opacity:.8;text-align:center;margin:20px;padding:20px;min-height:50vh}@media(min-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:50vh;height:50vh}}@media(max-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:80vw;height:80vw}}.mindar-ui-scanning .scanning .inner{position:relative;width:100%;height:100%;opacity:.8;background:linear-gradient(to right, white 10px, transparent 10px) 0 0,linear-gradient(to right, white 10px, transparent 10px) 0 100%,linear-gradient(to left, white 10px, transparent 10px) 100% 0,linear-gradient(to left, white 10px, transparent 10px) 100% 100%,linear-gradient(to bottom, white 10px, transparent 10px) 0 0,linear-gradient(to bottom, white 10px, transparent 10px) 100% 0,linear-gradient(to top, white 10px, transparent 10px) 0 100%,linear-gradient(to top, white 10px, transparent 10px) 100% 100%;background-repeat:no-repeat;background-size:40px 40px}.mindar-ui-scanning .scanning .inner .scanline{position:absolute;width:100%;height:10px;background:#fff;animation:move 2s linear infinite}@keyframes move{0%,100%{top:0%}50%{top:calc(100% - 10px)}}",""]);const o=a},645:t=>{"use strict";t.exports=function(t){var e=[];return e.toString=function(){return this.map((function(e){var n="",r=void 0!==e[5];return e[4]&&(n+="@supports (".concat(e[4],") {")),e[2]&&(n+="@media ".concat(e[2]," {")),r&&(n+="@layer".concat(e[5].length>0?" ".concat(e[5]):""," {")),n+=t(e),r&&(n+="}"),e[2]&&(n+="}"),e[4]&&(n+="}"),n})).join("")},e.i=function(t,n,r,i,s){"string"==typeof t&&(t=[[null,t,void 0]]);var a={};if(r)for(var o=0;o<this.length;o++){var l=this[o][0];null!=l&&(a[l]=!0)}for(var u=0;u<t.length;u++){var c=[].concat(t[u]);r&&a[c[0]]||(void 0!==s&&(void 0===c[5]||(c[1]="@layer".concat(c[5].length>0?" ".concat(c[5]):""," {").concat(c[1],"}")),c[5]=s),n&&(c[2]?(c[1]="@media ".concat(c[2]," {").concat(c[1],"}"),c[2]=n):c[2]=n),i&&(c[4]?(c[1]="@supports (".concat(c[4],") {").concat(c[1],"}"),c[4]=i):c[4]="".concat(i)),e.push(c))}},e}},81:t=>{"use strict";t.exports=function(t){return t[1]}},720:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var i={},s={};function a(t,e){var n,r,a;return e?(a=0<=(t>>>=0)&&t<256)&&(r=s[t])?r:(n=l(t,(0|t)<0?-1:0,!0),a&&(s[t]=n),n):(a=-128<=(t|=0)&&t<128)&&(r=i[t])?r:(n=l(t,t<0?-1:0,!1),a&&(i[t]=n),n)}function o(t,e){if(isNaN(t))return e?x:g;if(e){if(t<0)return x;if(t>=p)return S}else{if(t<=-f)return _;if(t+1>=f)return w}return t<0?o(-t,e).neg():l(t%d|0,t/d|0,e)}function l(t,e,r){return new n(t,e,r)}n.fromInt=a,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return g;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(t.substring(1),e,n).neg();for(var i=o(u(n,8)),s=g,a=0;a<t.length;a+=8){var l=Math.min(8,t.length-a),h=parseInt(t.substring(a,a+l),n);if(l<8){var d=o(u(n,l));s=s.mul(d).add(o(h))}else s=(s=s.mul(i)).add(o(h))}return s.unsigned=e,s}function h(t,e){return"number"==typeof t?o(t,e):"string"==typeof t?c(t,e):l(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=a(1<<24),g=a(0);n.ZERO=g;var x=a(0,!0);n.UZERO=x;var y=a(1);n.ONE=y;var v=a(1,!0);n.UONE=v;var b=a(-1);n.NEG_ONE=b;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var S=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=S;var _=l(0,-2147483648,!1);n.MIN_VALUE=_;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(_)){var e=o(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var i=o(u(t,6),this.unsigned),s=this,a="";;){var l=s.div(i),c=(s.sub(l.mul(i)).toInt()>>>0).toString(t);if((s=l).isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(_)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1==(1&this.low)},I.isEven=function(){return 0==(1&this.low)},I.equals=function(t){return r(t)||(t=h(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},I.eq=I.equals,I.notEquals=function(t){return!this.eq(t)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(t){return this.comp(t)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(t){return this.comp(t)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(t){return this.comp(t)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(t){return this.comp(t)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(t){if(r(t)||(t=h(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(_)?_:this.not().add(y)},I.neg=I.negate,I.add=function(t){r(t)||(t=h(t));var e=this.high>>>16,n=65535&this.high,i=this.low>>>16,s=65535&this.low,a=t.high>>>16,o=65535&t.high,u=t.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=s+(65535&t.low))>>>16,d+=(p+=i+u)>>>16,c+=(d+=n+o)>>>16,c+=e+a,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(t){return r(t)||(t=h(t)),this.add(t.neg())},I.sub=I.subtract,I.multiply=function(t){if(this.isZero())return g;if(r(t)||(t=h(t)),e)return l(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return g;if(this.eq(_))return t.isOdd()?_:g;if(t.eq(_))return this.isOdd()?_:g;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(m)&&t.lt(m))return o(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,i=65535&this.high,s=this.low>>>16,a=65535&this.low,u=t.high>>>16,c=65535&t.high,d=t.low>>>16,p=65535&t.low,f=0,x=0,y=0,v=0;return y+=(v+=a*p)>>>16,x+=(y+=s*p)>>>16,y&=65535,x+=(y+=a*d)>>>16,f+=(x+=i*p)>>>16,x&=65535,f+=(x+=s*d)>>>16,x&=65535,f+=(x+=a*c)>>>16,f+=n*p+i*d+s*c+a*u,l((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(x&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(t){if(r(t)||(t=h(t)),t.isZero())throw Error("division by zero");var n,i,s;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?l((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?x:g;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return x;if(t.gt(this.shru(1)))return v;s=x}else{if(this.eq(_))return t.eq(y)||t.eq(b)?_:t.eq(_)?y:(n=this.shr(1).div(t).shl(1)).eq(g)?t.isNegative()?y:b:(i=this.sub(t.mul(n)),s=n.add(i.div(t)));if(t.eq(_))return this.unsigned?x:g;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=g}for(i=this;i.gte(t);){n=Math.max(1,Math.floor(i.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),c=a<=48?1:u(2,a-48),d=o(n),p=d.mul(t);p.isNegative()||p.gt(i);)p=(d=o(n-=c,this.unsigned)).mul(t);d.isZero()&&(d=y),s=s.add(d),i=i.sub(p)}return s},I.div=I.divide,I.modulo=function(t){return r(t)||(t=h(t)),e?l((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(t){return r(t)||(t=h(t)),l(this.low&t.low,this.high&t.high,this.unsigned)},I.or=function(t){return r(t)||(t=h(t)),l(this.low|t.low,this.high|t.high,this.unsigned)},I.xor=function(t){return r(t)||(t=h(t)),l(this.low^t.low,this.high^t.high,this.unsigned)},I.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):l(0,this.low<<t-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):l(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?l(this.low>>>t|e<<32-t,e>>>t,this.unsigned):l(32===t?e:e>>>t-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},I.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},377:(t,e,n)=>{var r=n(832),i=n(652),s=n(801),a=n(30),o=n(618),l=n(49),u=n(971);u.alea=r,u.xor128=i,u.xorwow=s,u.xorshift7=a,u.xor4096=o,u.tychei=l,t.exports=u},832:function(t,e,n){var r;!function(t,i,s){function a(t){var e,n=this,r=(e=4022871197,function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new a(t),r=e&&e.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,i))||(i.exports=r):this.alea=l}(0,t=n.nmd(t),n.amdD)},49:function(t,e,n){var r;!function(t,i,s){function a(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,i=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^i,e.a=i-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new a(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,i))||(i.exports=r):this.tychei=l}(0,t=n.nmd(t),n.amdD)},652:function(t,e,n){var r;!function(t,i,s){function a(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new a(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,i))||(i.exports=r):this.xor128=l}(0,t=n.nmd(t),n.amdD)},618:function(t,e,n){var r;!function(t,i,s){function a(t){var e=this;e.next=function(){var t,n,r=e.w,i=e.X,s=e.i;return e.w=r=r+1640531527|0,n=i[s+34&127],t=i[s=s+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=i[s]=n^t,e.i=s,n+(r^r>>>16)|0},function(t,e){var n,r,i,s,a,o=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),i=0,s=-32;s<l;++s)e&&(r^=e.charCodeAt((s+32)%e.length)),0===s&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(a=a+1640531527|0,i=0==(n=o[127&s]^=r+a)?i+1:0);for(i>=128&&(o[127&(e&&e.length||0)]=-1),i=127,s=512;s>0;--s)r=o[i+34&127],n=o[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[i]=r^n;t.w=a,t.X=o,t.i=i}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&(r.X&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,i))||(i.exports=r):this.xor4096=l}(0,t=n.nmd(t),n.amdD)},30:function(t,e,n){var r;!function(t,i,s){function a(t){var e=this;e.next=function(){var t,n,r=e.x,i=e.i;return t=r[i],n=(t^=t>>>7)^t<<24,n^=(t=r[i+1&7])^t>>>10,n^=(t=r[i+3&7])^t>>>3,n^=(t=r[i+4&7])^t<<7,t=r[i+7&7],n^=(t^=t<<13)^t<<9,r[i]=n,e.i=i+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&(r.x&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,i))||(i.exports=r):this.xorshift7=l}(0,t=n.nmd(t),n.amdD)},801:function(t,e,n){var r;!function(t,i,s){function a(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new a(t),r=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,i))||(i.exports=r):this.xorwow=l}(0,t=n.nmd(t),n.amdD)},971:function(t,e,n){var r;!function(i,s,a){var o,l=256,u=6,c="random",h=a.pow(l,u),d=a.pow(2,52),p=2*d,f=l-1;function m(t,e,n){var r=[],f=v(y((e=1==e?{entropy:!0}:e||{}).entropy?[t,b(s)]:null==t?function(){try{var t;return o&&(t=o.randomBytes)?t=t(l):(t=new Uint8Array(l),(i.crypto||i.msCrypto).getRandomValues(t)),b(t)}catch(t){var e=i.navigator,n=e&&e.plugins;return[+new Date,i,n,i.screen,b(s)]}}():t,3),r),m=new g(r),w=function(){for(var t=m.g(u),e=h,n=0;t<d;)t=(t+n)*l,e*=l,n=m.g(1);for(;t>=p;)t/=2,e/=2,n>>>=1;return(t+n)/e};return w.int32=function(){return 0|m.g(4)},w.quick=function(){return m.g(4)/4294967296},w.double=w,v(b(m.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&x(r,m),t.state=function(){return x(m,{})}),n?(a[c]=t,e):t})(w,f,"global"in e?e.global:this==a,e.state)}function g(t){var e,n=t.length,r=this,i=0,s=r.i=r.j=0,a=r.S=[];for(n||(t=[n++]);i<l;)a[i]=i++;for(i=0;i<l;i++)a[i]=a[s=f&s+t[i%n]+(e=a[i])],a[s]=e;(r.g=function(t){for(var e,n=0,i=r.i,s=r.j,a=r.S;t--;)e=a[i=f&i+1],n=n*l+a[f&(a[i]=a[s=f&s+e])+(a[s]=e)];return r.i=i,r.j=s,n})(l)}function x(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function y(t,e){var n,r=[],i=typeof t;if(e&&"object"==i)for(n in t)try{r.push(y(t[n],e-1))}catch(t){}return r.length?r:"string"==i?t:t+"\0"}function v(t,e){for(var n,r=t+"",i=0;i<r.length;)e[f&i]=f&(n^=19*e[f&i])+r.charCodeAt(i++);return b(e)}function b(t){return String.fromCharCode.apply(0,t)}if(v(a.random(),s),t.exports){t.exports=m;try{o=n(42)}catch(t){}}else void 0===(r=function(){return m}.call(e,n,e,t))||(t.exports=r)}("undefined"!=typeof self?self:this,[],Math)},379:t=>{"use strict";var e=[];function n(t){for(var n=-1,r=0;r<e.length;r++)if(e[r].identifier===t){n=r;break}return n}function r(t,r){for(var s={},a=[],o=0;o<t.length;o++){var l=t[o],u=r.base?l[0]+r.base:l[0],c=s[u]||0,h="".concat(u," ").concat(c);s[u]=c+1;var d=n(h),p={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==d)e[d].references++,e[d].updater(p);else{var f=i(p,r);r.byIndex=o,e.splice(o,0,{identifier:h,updater:f,references:1})}a.push(h)}return a}function i(t,e){var n=e.domAPI(e);return n.update(t),function(e){if(e){if(e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap&&e.supports===t.supports&&e.layer===t.layer)return;n.update(t=e)}else n.remove()}}t.exports=function(t,i){var s=r(t=t||[],i=i||{});return function(t){t=t||[];for(var a=0;a<s.length;a++){var o=n(s[a]);e[o].references--}for(var l=r(t,i),u=0;u<s.length;u++){var c=n(s[u]);0===e[c].references&&(e[c].updater(),e.splice(c,1))}s=l}}},569:t=>{"use strict";var e={};t.exports=function(t,n){var r=function(t){if(void 0===e[t]){var n=document.querySelector(t);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(t){n=null}e[t]=n}return e[t]}(t);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},216:t=>{"use strict";t.exports=function(t){var e=document.createElement("style");return t.setAttributes(e,t.attributes),t.insert(e,t.options),e}},565:(t,e,n)=>{"use strict";t.exports=function(t){var e=n.nc;e&&t.setAttribute("nonce",e)}},795:t=>{"use strict";t.exports=function(t){var e=t.insertStyleElement(t);return{update:function(n){!function(t,e,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var i=void 0!==n.layer;i&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,i&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var s=n.sourceMap;s&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s))))," */")),e.styleTagTransform(r,t,e.options)}(e,t,n)},remove:function(){!function(t){if(null===t.parentNode)return!1;t.parentNode.removeChild(t)}(e)}}}},589:t=>{"use strict";t.exports=function(t,e){if(e.styleSheet)e.styleSheet.cssText=t;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(t))}}},477:t=>{"use strict";t.exports=function(t,e,n,r){var i=self||window;try{try{var s;try{s=new i.Blob([t])}catch(e){(s=new(i.BlobBuilder||i.WebKitBlobBuilder||i.MozBlobBuilder||i.MSBlobBuilder)).append(t),s=s.getBlob()}var a=i.URL||i.webkitURL,o=a.createObjectURL(s),l=new i[e](o,n);return a.revokeObjectURL(o),l}catch(r){return new i[e]("data:application/javascript,".concat(encodeURIComponent(t)),n)}}catch(t){if(!r)throw Error("Inline worker is not supported");return new i[e](r,n)}}},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},e={};function n(r){var i=e[r];if(void 0!==i)return i.exports;var s=e[r]={id:r,loaded:!1,exports:{}};return t[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.nmd=t=>(t.paths=[],t.children||(t.children=[]),t),n.nc=void 0,(()=>{"use strict";var t={};n.r(t),n.d(t,{ACESFilmicToneMapping:()=>st,AddEquation:()=>C,AddOperation:()=>tt,AdditiveAnimationBlendMode:()=>Ne,AdditiveBlending:()=>I,AlphaFormat:()=>Pt,AlwaysDepth:()=>H,AlwaysStencilFunc:()=>an,AmbientLight:()=>Zh,AmbientLightProbe:()=>fd,AnimationClip:()=>wh,AnimationLoader:()=>Ah,AnimationMixer:()=>Gd,AnimationObjectGroup:()=>Ud,AnimationUtils:()=>lh,ArcCurve:()=>Mu,ArrayCamera:()=>il,ArrowHelper:()=>Fp,Audio:()=>Md,AudioAnalyser:()=>Rd,AudioContext:()=>hd,AudioListener:()=>kd,AudioLoader:()=>dd,AxesHelper:()=>$p,BackSide:()=>y,BasicDepthPacking:()=>Pe,BasicShadowMap:()=>p,Bone:()=>Hl,BooleanKeyframeTrack:()=>fh,Box2:()=>np,Box3:()=>dr,Box3Helper:()=>Ap,BoxBufferGeometry:()=>ds,BoxGeometry:()=>ds,BoxHelper:()=>Ep,BufferAttribute:()=>Ci,BufferGeometry:()=>ji,BufferGeometryLoader:()=>id,ByteType:()=>Tt,Cache:()=>_h,Camera:()=>xs,CameraHelper:()=>Mp,CanvasTexture:()=>_u,CapsuleBufferGeometry:()=>qu,CapsuleGeometry:()=>qu,CatmullRomCurve3:()=>Ru,CineonToneMapping:()=>it,CircleBufferGeometry:()=>Xu,CircleGeometry:()=>Xu,ClampToEdgeWrapping:()=>ft,Clock:()=>vd,Color:()=>Xn,ColorKeyframeTrack:()=>mh,ColorManagement:()=>Un,CompressedTexture:()=>Su,CompressedTextureLoader:()=>Nh,ConeBufferGeometry:()=>Yu,ConeGeometry:()=>Yu,CubeCamera:()=>bs,CubeReflectionMapping:()=>lt,CubeRefractionMapping:()=>ut,CubeTexture:()=>ws,CubeTextureLoader:()=>Dh,CubeUVReflectionMapping:()=>dt,CubicBezierCurve:()=>$u,CubicBezierCurve3:()=>Pu,CubicInterpolant:()=>ch,CullFaceBack:()=>c,CullFaceFront:()=>h,CullFaceFrontBack:()=>d,CullFaceNone:()=>u,Curve:()=>Iu,CurvePath:()=>Gu,CustomBlending:()=>T,CustomToneMapping:()=>at,CylinderBufferGeometry:()=>Ku,CylinderGeometry:()=>Ku,Cylindrical:()=>tp,Data3DTexture:()=>sr,DataArrayTexture:()=>rr,DataTexture:()=>jl,DataTexture2DArray:()=>qp,DataTexture3D:()=>Xp,DataTextureLoader:()=>Lh,DataUtils:()=>Bp,DecrementStencilOp:()=>Xe,DecrementWrapStencilOp:()=>Ye,DefaultLoadingManager:()=>kh,DepthFormat:()=>Wt,DepthStencilFormat:()=>Vt,DepthTexture:()=>ll,DirectionalLight:()=>Yh,DirectionalLightHelper:()=>_p,DiscreteInterpolant:()=>dh,DodecahedronBufferGeometry:()=>Ju,DodecahedronGeometry:()=>Ju,DoubleSide:()=>v,DstAlphaFactor:()=>z,DstColorFactor:()=>U,DynamicCopyUsage:()=>fn,DynamicDrawUsage:()=>ln,DynamicReadUsage:()=>hn,EdgesGeometry:()=>rc,EllipseCurve:()=>ku,EqualDepth:()=>X,EqualStencilFunc:()=>tn,EquirectangularReflectionMapping:()=>ct,EquirectangularRefractionMapping:()=>ht,Euler:()=>Yr,EventDispatcher:()=>vn,ExtrudeBufferGeometry:()=>Rc,ExtrudeGeometry:()=>Rc,FileLoader:()=>Eh,FlatShading:()=>b,Float16BufferAttribute:()=>$i,Float32BufferAttribute:()=>Pi,Float64BufferAttribute:()=>Oi,FloatType:()=>Rt,Fog:()=>ml,FogExp2:()=>fl,Font:()=>Gp,FontLoader:()=>Vp,FramebufferTexture:()=>wu,FrontSide:()=>x,Frustum:()=>Es,GLBufferAttribute:()=>Kd,GLSL1:()=>gn,GLSL3:()=>xn,GreaterDepth:()=>Y,GreaterEqualDepth:()=>K,GreaterEqualStencilFunc:()=>sn,GreaterStencilFunc:()=>nn,GridHelper:()=>yp,Group:()=>sl,HalfFloatType:()=>Dt,HemisphereLight:()=>Ph,HemisphereLightHelper:()=>xp,HemisphereLightProbe:()=>pd,IcosahedronBufferGeometry:()=>Lc,IcosahedronGeometry:()=>Lc,ImageBitmapLoader:()=>ud,ImageLoader:()=>Rh,ImageUtils:()=>Yn,ImmediateRenderObject:()=>Hp,IncrementStencilOp:()=>qe,IncrementWrapStencilOp:()=>Ke,InstancedBufferAttribute:()=>Yl,InstancedBufferGeometry:()=>rd,InstancedInterleavedBuffer:()=>Xd,InstancedMesh:()=>eu,Int16BufferAttribute:()=>Ri,Int32BufferAttribute:()=>Li,Int8BufferAttribute:()=>Ei,IntType:()=>At,InterleavedBuffer:()=>xl,InterleavedBufferAttribute:()=>vl,Interpolant:()=>uh,InterpolateDiscrete:()=>Ie,InterpolateLinear:()=>ke,InterpolateSmooth:()=>Me,InvertStencilOp:()=>Ze,KeepStencilOp:()=>He,KeyframeTrack:()=>ph,LOD:()=>Ol,LatheBufferGeometry:()=>ju,LatheGeometry:()=>ju,Layers:()=>Zr,LessDepth:()=>j,LessEqualDepth:()=>q,LessEqualStencilFunc:()=>en,LessStencilFunc:()=>Qe,Light:()=>$h,LightProbe:()=>td,Line:()=>lu,Line3:()=>sp,LineBasicMaterial:()=>nu,LineCurve:()=>Ou,LineCurve3:()=>zu,LineDashedMaterial:()=>eh,LineLoop:()=>du,LineSegments:()=>hu,LinearEncoding:()=>Fe,LinearFilter:()=>wt,LinearInterpolant:()=>hh,LinearMipMapLinearFilter:()=>kt,LinearMipMapNearestFilter:()=>_t,LinearMipmapLinearFilter:()=>It,LinearMipmapNearestFilter:()=>St,LinearSRGBColorSpace:()=>Ve,LinearToneMapping:()=>nt,Loader:()=>Mh,LoaderUtils:()=>nd,LoadingManager:()=>Ih,LoopOnce:()=>we,LoopPingPong:()=>_e,LoopRepeat:()=>Se,LuminanceAlphaFormat:()=>Ut,LuminanceFormat:()=>Bt,MOUSE:()=>o,Material:()=>Ii,MaterialLoader:()=>ed,MathUtils:()=>Nn,Matrix3:()=>Dn,Matrix4:()=>Br,MaxEquation:()=>R,Mesh:()=>cs,MeshBasicMaterial:()=>ki,MeshDepthMaterial:()=>Yo,MeshDistanceMaterial:()=>Zo,MeshLambertMaterial:()=>Qc,MeshMatcapMaterial:()=>th,MeshNormalMaterial:()=>Jc,MeshPhongMaterial:()=>Yc,MeshPhysicalMaterial:()=>Kc,MeshStandardMaterial:()=>Xc,MeshToonMaterial:()=>Zc,MinEquation:()=>N,MirroredRepeatWrapping:()=>mt,MixOperation:()=>Q,MultiplyBlending:()=>M,MultiplyOperation:()=>J,NearestFilter:()=>gt,NearestMipMapLinearFilter:()=>bt,NearestMipMapNearestFilter:()=>yt,NearestMipmapLinearFilter:()=>vt,NearestMipmapNearestFilter:()=>xt,NeverDepth:()=>G,NeverStencilFunc:()=>Je,NoBlending:()=>S,NoColorSpace:()=>Ue,NoToneMapping:()=>et,NormalAnimationBlendMode:()=>Ae,NormalBlending:()=>_,NotEqualDepth:()=>Z,NotEqualStencilFunc:()=>rn,NumberKeyframeTrack:()=>gh,Object3D:()=>hi,ObjectLoader:()=>sd,ObjectSpaceNormalMap:()=>Be,OctahedronBufferGeometry:()=>Fc,OctahedronGeometry:()=>Fc,OneFactor:()=>L,OneMinusDstAlphaFactor:()=>B,OneMinusDstColorFactor:()=>W,OneMinusSrcAlphaFactor:()=>O,OneMinusSrcColorFactor:()=>$,OrthographicCamera:()=>Ws,PCFShadowMap:()=>f,PCFSoftShadowMap:()=>m,PMREMGenerator:()=>Zs,ParametricGeometry:()=>Up,Path:()=>Hu,PerspectiveCamera:()=>ys,Plane:()=>Ms,PlaneBufferGeometry:()=>Rs,PlaneGeometry:()=>Rs,PlaneHelper:()=>Np,PointLight:()=>Xh,PointLightHelper:()=>pp,Points:()=>yu,PointsMaterial:()=>pu,PolarGridHelper:()=>vp,PolyhedronBufferGeometry:()=>Zu,PolyhedronGeometry:()=>Zu,PositionalAudio:()=>Nd,PropertyBinding:()=>Bd,PropertyMixer:()=>Dd,QuadraticBezierCurve:()=>Bu,QuadraticBezierCurve3:()=>Uu,Quaternion:()=>lr,QuaternionKeyframeTrack:()=>yh,QuaternionLinearInterpolant:()=>xh,REVISION:()=>a,RGBADepthPacking:()=>Oe,RGBAFormat:()=>zt,RGBAIntegerFormat:()=>Xt,RGBA_ASTC_10x10_Format:()=>xe,RGBA_ASTC_10x5_Format:()=>fe,RGBA_ASTC_10x6_Format:()=>me,RGBA_ASTC_10x8_Format:()=>ge,RGBA_ASTC_12x10_Format:()=>ye,RGBA_ASTC_12x12_Format:()=>ve,RGBA_ASTC_4x4_Format:()=>ae,RGBA_ASTC_5x4_Format:()=>oe,RGBA_ASTC_5x5_Format:()=>le,RGBA_ASTC_6x5_Format:()=>ue,RGBA_ASTC_6x6_Format:()=>ce,RGBA_ASTC_8x5_Format:()=>he,RGBA_ASTC_8x6_Format:()=>de,RGBA_ASTC_8x8_Format:()=>pe,RGBA_BPTC_Format:()=>be,RGBA_ETC2_EAC_Format:()=>se,RGBA_PVRTC_2BPPV1_Format:()=>ne,RGBA_PVRTC_4BPPV1_Format:()=>ee,RGBA_S3TC_DXT1_Format:()=>Yt,RGBA_S3TC_DXT3_Format:()=>Zt,RGBA_S3TC_DXT5_Format:()=>Jt,RGBFormat:()=>Ot,RGB_ETC1_Format:()=>re,RGB_ETC2_Format:()=>ie,RGB_PVRTC_2BPPV1_Format:()=>te,RGB_PVRTC_4BPPV1_Format:()=>Qt,RGB_S3TC_DXT1_Format:()=>Kt,RGFormat:()=>jt,RGIntegerFormat:()=>qt,RawShaderMaterial:()=>qc,Ray:()=>zr,Raycaster:()=>Yd,RectAreaLight:()=>Jh,RedFormat:()=>Gt,RedIntegerFormat:()=>Ht,ReinhardToneMapping:()=>rt,RepeatWrapping:()=>pt,ReplaceStencilOp:()=>je,ReverseSubtractEquation:()=>A,RingBufferGeometry:()=>$c,RingGeometry:()=>$c,SRGBColorSpace:()=>We,Scene:()=>gl,ShaderChunk:()=>Ds,ShaderLib:()=>Fs,ShaderMaterial:()=>gs,ShadowMaterial:()=>jc,Shape:()=>ic,ShapeBufferGeometry:()=>Pc,ShapeGeometry:()=>Pc,ShapePath:()=>Pp,ShapeUtils:()=>Ec,ShortType:()=>Ct,Skeleton:()=>Kl,SkeletonHelper:()=>hp,SkinnedMesh:()=>Gl,SmoothShading:()=>w,Source:()=>Zn,Sphere:()=>Nr,SphereBufferGeometry:()=>Oc,SphereGeometry:()=>Oc,Spherical:()=>Qd,SphericalHarmonics3:()=>Qh,SplineCurve:()=>Wu,SpotLight:()=>Vh,SpotLightHelper:()=>op,Sprite:()=>Ll,SpriteMaterial:()=>bl,SrcAlphaFactor:()=>P,SrcAlphaSaturateFactor:()=>V,SrcColorFactor:()=>F,StaticCopyUsage:()=>pn,StaticDrawUsage:()=>on,StaticReadUsage:()=>cn,StereoCamera:()=>yd,StreamCopyUsage:()=>mn,StreamDrawUsage:()=>un,StreamReadUsage:()=>dn,StringKeyframeTrack:()=>vh,SubtractEquation:()=>E,SubtractiveBlending:()=>k,TOUCH:()=>l,TangentSpaceNormalMap:()=>ze,TetrahedronBufferGeometry:()=>zc,TetrahedronGeometry:()=>zc,TextGeometry:()=>Wp,Texture:()=>tr,TextureLoader:()=>Fh,TorusBufferGeometry:()=>Bc,TorusGeometry:()=>Bc,TorusKnotBufferGeometry:()=>Uc,TorusKnotGeometry:()=>Uc,Triangle:()=>Si,TriangleFanDrawMode:()=>Le,TriangleStripDrawMode:()=>De,TrianglesDrawMode:()=>Re,TubeBufferGeometry:()=>Wc,TubeGeometry:()=>Wc,UVMapping:()=>ot,Uint16BufferAttribute:()=>Di,Uint32BufferAttribute:()=>Fi,Uint8BufferAttribute:()=>Ai,Uint8ClampedBufferAttribute:()=>Ni,Uniform:()=>Hd,UniformsGroup:()=>qd,UniformsLib:()=>Ls,UniformsUtils:()=>ms,UnsignedByteType:()=>Mt,UnsignedInt248Type:()=>$t,UnsignedIntType:()=>Nt,UnsignedShort4444Type:()=>Lt,UnsignedShort5551Type:()=>Ft,UnsignedShortType:()=>Et,VSMShadowMap:()=>g,Vector2:()=>Rn,Vector3:()=>ur,Vector4:()=>er,VectorKeyframeTrack:()=>bh,VideoTexture:()=>bu,WebGL1Renderer:()=>pl,WebGL3DRenderTarget:()=>ar,WebGLArrayRenderTarget:()=>ir,WebGLCubeRenderTarget:()=>Ss,WebGLMultipleRenderTargets:()=>or,WebGLMultisampleRenderTarget:()=>jp,WebGLRenderTarget:()=>nr,WebGLRenderer:()=>dl,WebGLUtils:()=>rl,WireframeGeometry:()=>Vc,WrapAroundEnding:()=>Ee,ZeroCurvatureEnding:()=>Te,ZeroFactor:()=>D,ZeroSlopeEnding:()=>Ce,ZeroStencilOp:()=>Ge,_SRGBAFormat:()=>yn,sRGBEncoding:()=>$e});var e={};n.r(e),n.d(e,{assertParamsValid:()=>bb,computeFlatOffset:()=>Db,computeOutShape:()=>Sb,getNormalizedAxes:()=>Mb,isSliceContinous:()=>Rb,maskToAxes:()=>wb,parseSliceParams:()=>Lb,sliceInfo:()=>Fb,startForAxis:()=>Ab,startIndicesWithElidedDims:()=>Tb,stopForAxis:()=>Nb,stopIndicesWithElidedDims:()=>Cb,stridesForAxis:()=>Eb,stridesWithElidedDims:()=>_b});var r={};n.r(r),n.d(r,{collectGatherOpShapeInfo:()=>Tk,computeOutShape:()=>Mk,segOpComputeOptimalWindowSize:()=>kk});var i={};n.r(i),n.d(i,{ERF_A1:()=>VI,ERF_A2:()=>GI,ERF_A3:()=>HI,ERF_A4:()=>jI,ERF_A5:()=>qI,ERF_P:()=>WI,PARALLELIZE_THRESHOLD:()=>CI,RowPartitionType:()=>_I,SELU_SCALE:()=>UI,SELU_SCALEALPHA:()=>BI,applyActivation:()=>m_,assertAndGetBroadcastShape:()=>xb,assertAxesAreInnerMostDims:()=>mS,assertParamsConsistent:()=>wI,assignToTypedArray:()=>QI,axesAreInnerMostDims:()=>hS,calculateShapes:()=>zI,checkEinsumDimSizes:()=>lk,checkPadOnDimRoundingMode:()=>fw,combineLocations:()=>dS,combineRaggedTensorToTensorShapes:()=>II,complexWithEvenIndex:()=>YI,complexWithOddIndex:()=>ZI,computeConv2DInfo:()=>iw,computeConv3DInfo:()=>sw,computeDefaultPad:()=>aw,computeDilation2DInfo:()=>ew,computeOptimalWindowSize:()=>EI,computeOutAndReduceShapes:()=>pS,computeOutShape:()=>SI,computePool2DInfo:()=>nw,computePool3DInfo:()=>rw,convertConv2DDataFormat:()=>pw,decodeEinsumEquation:()=>ak,eitherStridesOrDilationsAreOne:()=>dw,expandShapeToKeepDim:()=>fS,exponent:()=>ek,exponents:()=>tk,fromStringArrayToUint8:()=>Ek,fromUint8ToStringArray:()=>Ck,getAxesPermutation:()=>gS,getBroadcastDims:()=>mb,getComplexWithIndex:()=>JI,getEinsumComputePath:()=>uk,getEinsumPermutation:()=>ok,getFusedBiasGradient:()=>f_,getFusedDyActivation:()=>p_,getImageCenter:()=>AI,getInnerMostAxes:()=>yS,getPermuted:()=>RI,getRaggedRank:()=>MI,getReductionAxes:()=>gb,getReshaped:()=>NI,getReshapedPermuted:()=>DI,getRowPartitionTypesHelper:()=>kI,getSliceBeginCoords:()=>LI,getSliceSize:()=>FI,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>pk,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>fk,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>mk,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>yk,getSparseReshapeInputOutputMismatchErrorMessage:()=>bk,getSparseReshapeInputOutputMultipleErrorMessage:()=>vk,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>gk,getSparseReshapeNegativeOutputDimErrorMessage:()=>xk,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Ik,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>wk,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Sk,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>_k,getUndoAxesPermutation:()=>xS,isIdentityPermutation:()=>ck,log:()=>ny,mergeRealAndImagArrays:()=>XI,prepareAndValidate:()=>$I,prepareSplitSize:()=>dk,segment_util:()=>r,shouldFuse:()=>g_,slice_util:()=>e,splitRealAndImagArrays:()=>KI,tupleValuesAreOne:()=>hw,upcastType:()=>tv,validateDefaultValueShape:()=>TI,validateInput:()=>OI,validateUpdateShape:()=>PI,warn:()=>ey});var s={};n.r(s),n.d(s,{addImpl:()=>YL,bincountImpl:()=>WF,bincountReduceImpl:()=>VF,castImpl:()=>HL,ceilImpl:()=>jF,concatImpl:()=>JF,equalImpl:()=>F$,expImpl:()=>j$,expm1Impl:()=>Z$,floorImpl:()=>fP,gatherNdImpl:()=>SP,gatherV2Impl:()=>IP,greaterEqualImpl:()=>EP,greaterImpl:()=>MP,lessEqualImpl:()=>WP,lessImpl:()=>zP,linSpaceImpl:()=>HP,logImpl:()=>qP,maxImpl:()=>lO,maximumImpl:()=>hO,minimumImpl:()=>wO,multiplyImpl:()=>T$,negImpl:()=>NO,notEqualImpl:()=>zO,prodImpl:()=>JO,raggedGatherImpl:()=>ez,raggedTensorToTensorImpl:()=>oz,rangeImpl:()=>uz,rsqrtImpl:()=>wz,scatterImpl:()=>Iz,sigmoidImpl:()=>$L,simpleAbsImpl:()=>sF,sliceImpl:()=>OF,sparseFillEmptyRowsImpl:()=>Gz,sparseReshapeImpl:()=>jz,sparseSegmentReductionImpl:()=>Xz,sqrtImpl:()=>Qz,squaredDifferenceImpl:()=>rB,stridedSliceImpl:()=>lB,stringNGramsImpl:()=>hB,stringSplitImpl:()=>fB,stringToHashBucketFastImpl:()=>gB,subImpl:()=>rP,tileImpl:()=>wB,topKImpl:()=>IB,transposeImpl:()=>dF,uniqueImpl:()=>AB});const a="143",o={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},l={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},u=0,c=1,h=2,d=3,p=0,f=1,m=2,g=3,x=0,y=1,v=2,b=1,w=2,S=0,_=1,I=2,k=3,M=4,T=5,C=100,E=101,A=102,N=103,R=104,D=200,L=201,F=202,$=203,P=204,O=205,z=206,B=207,U=208,W=209,V=210,G=0,H=1,j=2,q=3,X=4,K=5,Y=6,Z=7,J=0,Q=1,tt=2,et=0,nt=1,rt=2,it=3,st=4,at=5,ot=300,lt=301,ut=302,ct=303,ht=304,dt=306,pt=1e3,ft=1001,mt=1002,gt=1003,xt=1004,yt=1004,vt=1005,bt=1005,wt=1006,St=1007,_t=1007,It=1008,kt=1008,Mt=1009,Tt=1010,Ct=1011,Et=1012,At=1013,Nt=1014,Rt=1015,Dt=1016,Lt=1017,Ft=1018,$t=1020,Pt=1021,Ot=1022,zt=1023,Bt=1024,Ut=1025,Wt=1026,Vt=1027,Gt=1028,Ht=1029,jt=1030,qt=1031,Xt=1033,Kt=33776,Yt=33777,Zt=33778,Jt=33779,Qt=35840,te=35841,ee=35842,ne=35843,re=36196,ie=37492,se=37496,ae=37808,oe=37809,le=37810,ue=37811,ce=37812,he=37813,de=37814,pe=37815,fe=37816,me=37817,ge=37818,xe=37819,ye=37820,ve=37821,be=36492,we=2200,Se=2201,_e=2202,Ie=2300,ke=2301,Me=2302,Te=2400,Ce=2401,Ee=2402,Ae=2500,Ne=2501,Re=0,De=1,Le=2,Fe=3e3,$e=3001,Pe=3200,Oe=3201,ze=0,Be=1,Ue="",We="srgb",Ve="srgb-linear",Ge=0,He=7680,je=7681,qe=7682,Xe=7683,Ke=34055,Ye=34056,Ze=5386,Je=512,Qe=513,tn=514,en=515,nn=516,rn=517,sn=518,an=519,on=35044,ln=35048,un=35040,cn=35045,hn=35049,dn=35041,pn=35046,fn=35050,mn=35042,gn="100",xn="300 es",yn=1035;class vn{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,r=n.length;e<r;e++)n[e].call(this,t);t.target=null}}}const bn=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let wn=1234567;const Sn=Math.PI/180,_n=180/Math.PI;function In(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(bn[255&t]+bn[t>>8&255]+bn[t>>16&255]+bn[t>>24&255]+"-"+bn[255&e]+bn[e>>8&255]+"-"+bn[e>>16&15|64]+bn[e>>24&255]+"-"+bn[63&n|128]+bn[n>>8&255]+"-"+bn[n>>16&255]+bn[n>>24&255]+bn[255&r]+bn[r>>8&255]+bn[r>>16&255]+bn[r>>24&255]).toLowerCase()}function kn(t,e,n){return Math.max(e,Math.min(n,t))}function Mn(t,e){return(t%e+e)%e}function Tn(t,e,n){return(1-n)*t+n*e}function Cn(t){return 0==(t&t-1)&&0!==t}function En(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function An(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}var Nn=Object.freeze({__proto__:null,DEG2RAD:Sn,RAD2DEG:_n,generateUUID:In,clamp:kn,euclideanModulo:Mn,mapLinear:function(t,e,n,r,i){return r+(t-e)*(i-r)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:Tn,damp:function(t,e,n,r){return Tn(t,e,1-Math.exp(-n*r))},pingpong:function(t,e=1){return e-Math.abs(Mn(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(wn=t);let e=wn+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*Sn},radToDeg:function(t){return t*_n},isPowerOfTwo:Cn,ceilPowerOfTwo:En,floorPowerOfTwo:An,setQuaternionFromProperEuler:function(t,e,n,r,i){const s=Math.cos,a=Math.sin,o=s(n/2),l=a(n/2),u=s((e+r)/2),c=a((e+r)/2),h=s((e-r)/2),d=a((e-r)/2),p=s((r-e)/2),f=a((r-e)/2);switch(i){case"XYX":t.set(o*c,l*h,l*d,o*u);break;case"YZY":t.set(l*d,o*c,l*h,o*u);break;case"ZXZ":t.set(l*h,l*d,o*c,o*u);break;case"XZX":t.set(o*c,l*f,l*p,o*u);break;case"YXY":t.set(l*p,o*c,l*f,o*u);break;case"ZYZ":t.set(l*f,l*p,o*c,o*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}},normalize:function(t,e){switch(e.constructor){case Float32Array:return t;case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}},denormalize:function(t,e){switch(e.constructor){case Float32Array:return t;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}});class Rn{constructor(t=0,e=0){Rn.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),i=this.x-t.x,s=this.y-t.y;return this.x=i*n-s*r+t.x,this.y=i*r+s*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Dn{constructor(){Dn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(t,e,n,r,i,s,a,o,l){const u=this.elements;return u[0]=t,u[1]=r,u[2]=a,u[3]=e,u[4]=i,u[5]=o,u[6]=n,u[7]=s,u[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,i=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],u=n[4],c=n[7],h=n[2],d=n[5],p=n[8],f=r[0],m=r[3],g=r[6],x=r[1],y=r[4],v=r[7],b=r[2],w=r[5],S=r[8];return i[0]=s*f+a*x+o*b,i[3]=s*m+a*y+o*w,i[6]=s*g+a*v+o*S,i[1]=l*f+u*x+c*b,i[4]=l*m+u*y+c*w,i[7]=l*g+u*v+c*S,i[2]=h*f+d*x+p*b,i[5]=h*m+d*y+p*w,i[8]=h*g+d*v+p*S,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],s=t[4],a=t[5],o=t[6],l=t[7],u=t[8];return e*s*u-e*a*l-n*i*u+n*a*o+r*i*l-r*s*o}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],s=t[4],a=t[5],o=t[6],l=t[7],u=t[8],c=u*s-a*l,h=a*o-u*i,d=l*i-s*o,p=e*c+n*h+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=c*f,t[1]=(r*l-u*n)*f,t[2]=(a*n-r*s)*f,t[3]=h*f,t[4]=(u*e-r*o)*f,t[5]=(r*i-a*e)*f,t[6]=d*f,t[7]=(n*o-l*e)*f,t[8]=(s*e-n*i)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,i,s,a){const o=Math.cos(i),l=Math.sin(i);return this.set(n*o,n*l,-n*(o*s+l*a)+s+t,-r*l,r*o,-r*(-l*s+o*a)+a+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),r=this.elements,i=r[0],s=r[3],a=r[6],o=r[1],l=r[4],u=r[7];return r[0]=e*i+n*o,r[3]=e*s+n*l,r[6]=e*a+n*u,r[1]=-n*i+e*o,r[4]=-n*s+e*l,r[7]=-n*a+e*u,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}function Ln(t){for(let e=t.length-1;e>=0;--e)if(t[e]>65535)return!0;return!1}const Fn={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function $n(t,e){return new Fn[t](e)}function Pn(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function On(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function zn(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}const Bn={[We]:{[Ve]:On},[Ve]:{[We]:zn}},Un={legacyMode:!0,get workingColorSpace(){return Ve},set workingColorSpace(t){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(t,e,n){if(this.legacyMode||e===n||!e||!n)return t;if(Bn[e]&&void 0!==Bn[e][n]){const r=Bn[e][n];return t.r=r(t.r),t.g=r(t.g),t.b=r(t.b),t}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this.workingColorSpace)}},Wn={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Vn={r:0,g:0,b:0},Gn={h:0,s:0,l:0},Hn={h:0,s:0,l:0};function jn(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function qn(t,e){return e.r=t.r,e.g=t.g,e.b=t.b,e}class Xn{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=We){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,Un.toWorkingColorSpace(this,e),this}setRGB(t,e,n,r=Ve){return this.r=t,this.g=e,this.b=n,Un.toWorkingColorSpace(this,r),this}setHSL(t,e,n,r=Ve){if(t=Mn(t,1),e=kn(e,0,1),n=kn(n,0,1),0===e)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,i=2*n-r;this.r=jn(i,r,t+1/3),this.g=jn(i,r,t),this.b=jn(i,r,t-1/3)}return Un.toWorkingColorSpace(this,r),this}setStyle(t,e=We){function n(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const i=r[1],s=r[2];switch(i){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,Un.toWorkingColorSpace(this,e),n(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,Un.toWorkingColorSpace(this,e),n(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){const r=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,s=parseInt(t[3],10)/100;return n(t[4]),this.setHSL(r,i,s,e)}}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=r[1],n=t.length;if(3===n)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,Un.toWorkingColorSpace(this,e),this;if(6===n)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,Un.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e=We){const n=Wn[t.toLowerCase()];return void 0!==n?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=On(t.r),this.g=On(t.g),this.b=On(t.b),this}copyLinearToSRGB(t){return this.r=zn(t.r),this.g=zn(t.g),this.b=zn(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=We){return Un.fromWorkingColorSpace(qn(this,Vn),t),kn(255*Vn.r,0,255)<<16^kn(255*Vn.g,0,255)<<8^kn(255*Vn.b,0,255)<<0}getHexString(t=We){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=Ve){Un.fromWorkingColorSpace(qn(this,Vn),e);const n=Vn.r,r=Vn.g,i=Vn.b,s=Math.max(n,r,i),a=Math.min(n,r,i);let o,l;const u=(a+s)/2;if(a===s)o=0,l=0;else{const t=s-a;switch(l=u<=.5?t/(s+a):t/(2-s-a),s){case n:o=(r-i)/t+(r<i?6:0);break;case r:o=(i-n)/t+2;break;case i:o=(n-r)/t+4}o/=6}return t.h=o,t.s=l,t.l=u,t}getRGB(t,e=Ve){return Un.fromWorkingColorSpace(qn(this,Vn),e),t.r=Vn.r,t.g=Vn.g,t.b=Vn.b,t}getStyle(t=We){return Un.fromWorkingColorSpace(qn(this,Vn),t),t!==We?`color(${t} ${Vn.r} ${Vn.g} ${Vn.b})`:`rgb(${255*Vn.r|0},${255*Vn.g|0},${255*Vn.b|0})`}offsetHSL(t,e,n){return this.getHSL(Gn),Gn.h+=t,Gn.s+=e,Gn.l+=n,this.setHSL(Gn.h,Gn.s,Gn.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Gn),t.getHSL(Hn);const n=Tn(Gn.h,Hn.h,e),r=Tn(Gn.s,Hn.s,e),i=Tn(Gn.l,Hn.l,e);return this.setHSL(n,r,i),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let Kn;Xn.NAMES=Wn;class Yn{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===Kn&&(Kn=Pn("canvas")),Kn.width=t.width,Kn.height=t.height;const n=Kn.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Kn}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=Pn("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const r=n.getImageData(0,0,t.width,t.height),i=r.data;for(let t=0;t<i.length;t++)i[t]=255*On(i[t]/255);return n.putImageData(r,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*On(e[t]/255)):e[t]=On(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}class Zn{constructor(t=null){this.isSource=!0,this.uuid=In(),this.data=t,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const n={uuid:this.uuid,url:""},r=this.data;if(null!==r){let t;if(Array.isArray(r)){t=[];for(let e=0,n=r.length;e<n;e++)r[e].isDataTexture?t.push(Jn(r[e].image)):t.push(Jn(r[e]))}else t=Jn(r);n.url=t}return e||(t.images[this.uuid]=n),n}}function Jn(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?Yn.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Qn=0;class tr extends vn{constructor(t=tr.DEFAULT_IMAGE,e=tr.DEFAULT_MAPPING,n=ft,r=ft,i=wt,s=It,a=zt,o=Mt,l=1,u=Fe){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Qn++}),this.uuid=In(),this.name="",this.source=new Zn(t),this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=r,this.magFilter=i,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new Rn(0,0),this.repeat=new Rn(1,1),this.center=new Rn(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Dn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==ot)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case pt:t.x=t.x-Math.floor(t.x);break;case ft:t.x=t.x<0?0:1;break;case mt:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case pt:t.y=t.y-Math.floor(t.y);break;case ft:t.y=t.y<0?0:1;break;case mt:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}}tr.DEFAULT_IMAGE=null,tr.DEFAULT_MAPPING=ot;class er{constructor(t=0,e=0,n=0,r=1){er.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,i=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r+s[12]*i,this.y=s[1]*e+s[5]*n+s[9]*r+s[13]*i,this.z=s[2]*e+s[6]*n+s[10]*r+s[14]*i,this.w=s[3]*e+s[7]*n+s[11]*r+s[15]*i,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,i;const s=.01,a=.1,o=t.elements,l=o[0],u=o[4],c=o[8],h=o[1],d=o[5],p=o[9],f=o[2],m=o[6],g=o[10];if(Math.abs(u-h)<s&&Math.abs(c-f)<s&&Math.abs(p-m)<s){if(Math.abs(u+h)<a&&Math.abs(c+f)<a&&Math.abs(p+m)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,x=(g+1)/2,y=(u+h)/4,v=(c+f)/4,b=(p+m)/4;return t>o&&t>x?t<s?(n=0,r=.707106781,i=.707106781):(n=Math.sqrt(t),r=y/n,i=v/n):o>x?o<s?(n=.707106781,r=0,i=.707106781):(r=Math.sqrt(o),n=y/r,i=b/r):x<s?(n=.707106781,r=.707106781,i=0):(i=Math.sqrt(x),n=v/i,r=b/i),this.set(n,r,i,e),this}let x=Math.sqrt((m-p)*(m-p)+(c-f)*(c-f)+(h-u)*(h-u));return Math.abs(x)<.001&&(x=1),this.x=(m-p)/x,this.y=(c-f)/x,this.z=(h-u)/x,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class nr extends vn{constructor(t,e,n={}){super(),this.isWebGLRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new er(0,0,t,e),this.scissorTest=!1,this.viewport=new er(0,0,t,e);const r={width:t,height:e,depth:1};this.texture=new tr(r,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:wt,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null,this.samples=void 0!==n.samples?n.samples:0}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Zn(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class rr extends tr{constructor(t=null,e=1,n=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:r},this.magFilter=gt,this.minFilter=gt,this.wrapR=ft,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class ir extends nr{constructor(t,e,n){super(t,e),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new rr(null,t,e,n),this.texture.isRenderTargetTexture=!0}}class sr extends tr{constructor(t=null,e=1,n=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:r},this.magFilter=gt,this.minFilter=gt,this.wrapR=ft,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class ar extends nr{constructor(t,e,n){super(t,e),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new sr(null,t,e,n),this.texture.isRenderTargetTexture=!0}}class or extends nr{constructor(t,e,n,r={}){super(t,e,r),this.isWebGLMultipleRenderTargets=!0;const i=this.texture;this.texture=[];for(let t=0;t<n;t++)this.texture[t]=i.clone(),this.texture[t].isRenderTargetTexture=!0}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let r=0,i=this.texture.length;r<i;r++)this.texture[r].image.width=t,this.texture[r].image.height=e,this.texture[r].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}}class lr{constructor(t=0,e=0,n=0,r=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=r}static slerpFlat(t,e,n,r,i,s,a){let o=n[r+0],l=n[r+1],u=n[r+2],c=n[r+3];const h=i[s+0],d=i[s+1],p=i[s+2],f=i[s+3];if(0===a)return t[e+0]=o,t[e+1]=l,t[e+2]=u,void(t[e+3]=c);if(1===a)return t[e+0]=h,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(c!==f||o!==h||l!==d||u!==p){let t=1-a;const e=o*h+l*d+u*p+c*f,n=e>=0?1:-1,r=1-e*e;if(r>Number.EPSILON){const i=Math.sqrt(r),s=Math.atan2(i,e*n);t=Math.sin(t*s)/i,a=Math.sin(a*s)/i}const i=a*n;if(o=o*t+h*i,l=l*t+d*i,u=u*t+p*i,c=c*t+f*i,t===1-a){const t=1/Math.sqrt(o*o+l*l+u*u+c*c);o*=t,l*=t,u*=t,c*=t}}t[e]=o,t[e+1]=l,t[e+2]=u,t[e+3]=c}static multiplyQuaternionsFlat(t,e,n,r,i,s){const a=n[r],o=n[r+1],l=n[r+2],u=n[r+3],c=i[s],h=i[s+1],d=i[s+2],p=i[s+3];return t[e]=a*p+u*c+o*d-l*h,t[e+1]=o*p+u*h+l*c-a*d,t[e+2]=l*p+u*d+a*h-o*c,t[e+3]=u*p-a*c-o*h-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,i=t._z,s=t._order,a=Math.cos,o=Math.sin,l=a(n/2),u=a(r/2),c=a(i/2),h=o(n/2),d=o(r/2),p=o(i/2);switch(s){case"XYZ":this._x=h*u*c+l*d*p,this._y=l*d*c-h*u*p,this._z=l*u*p+h*d*c,this._w=l*u*c-h*d*p;break;case"YXZ":this._x=h*u*c+l*d*p,this._y=l*d*c-h*u*p,this._z=l*u*p-h*d*c,this._w=l*u*c+h*d*p;break;case"ZXY":this._x=h*u*c-l*d*p,this._y=l*d*c+h*u*p,this._z=l*u*p+h*d*c,this._w=l*u*c-h*d*p;break;case"ZYX":this._x=h*u*c-l*d*p,this._y=l*d*c+h*u*p,this._z=l*u*p-h*d*c,this._w=l*u*c+h*d*p;break;case"YZX":this._x=h*u*c+l*d*p,this._y=l*d*c+h*u*p,this._z=l*u*p-h*d*c,this._w=l*u*c-h*d*p;break;case"XZY":this._x=h*u*c-l*d*p,this._y=l*d*c-h*u*p,this._z=l*u*p+h*d*c,this._w=l*u*c+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],i=e[8],s=e[1],a=e[5],o=e[9],l=e[2],u=e[6],c=e[10],h=n+a+c;if(h>0){const t=.5/Math.sqrt(h+1);this._w=.25/t,this._x=(u-o)*t,this._y=(i-l)*t,this._z=(s-r)*t}else if(n>a&&n>c){const t=2*Math.sqrt(1+n-a-c);this._w=(u-o)/t,this._x=.25*t,this._y=(r+s)/t,this._z=(i+l)/t}else if(a>c){const t=2*Math.sqrt(1+a-n-c);this._w=(i-l)/t,this._x=(r+s)/t,this._y=.25*t,this._z=(o+u)/t}else{const t=2*Math.sqrt(1+c-n-a);this._w=(s-r)/t,this._x=(i+l)/t,this._y=(o+u)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(kn(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,i=t._z,s=t._w,a=e._x,o=e._y,l=e._z,u=e._w;return this._x=n*u+s*a+r*l-i*o,this._y=r*u+s*o+i*a-n*l,this._z=i*u+s*l+n*o-r*a,this._w=s*u-n*a-r*o-i*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,r=this._y,i=this._z,s=this._w;let a=s*t._w+n*t._x+r*t._y+i*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=s,this._x=n,this._y=r,this._z=i,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*n+e*this._x,this._y=t*r+e*this._y,this._z=t*i+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(o),u=Math.atan2(l,a),c=Math.sin((1-e)*u)/l,h=Math.sin(e*u)/l;return this._w=s*c+this._w*h,this._x=n*c+this._x*h,this._y=r*c+this._y*h,this._z=i*c+this._z*h,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),r=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(e*Math.cos(r),n*Math.sin(i),n*Math.cos(i),e*Math.sin(r))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ur{constructor(t=0,e=0,n=0){ur.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(hr.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(hr.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6]*r,this.y=i[1]*e+i[4]*n+i[7]*r,this.z=i[2]*e+i[5]*n+i[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,i=t.elements,s=1/(i[3]*e+i[7]*n+i[11]*r+i[15]);return this.x=(i[0]*e+i[4]*n+i[8]*r+i[12])*s,this.y=(i[1]*e+i[5]*n+i[9]*r+i[13])*s,this.z=(i[2]*e+i[6]*n+i[10]*r+i[14])*s,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,i=t.x,s=t.y,a=t.z,o=t.w,l=o*e+s*r-a*n,u=o*n+a*e-i*r,c=o*r+i*n-s*e,h=-i*e-s*n-a*r;return this.x=l*o+h*-i+u*-a-c*-s,this.y=u*o+h*-s+c*-i-l*-a,this.z=c*o+h*-a+l*-s-u*-i,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,i=t.elements;return this.x=i[0]*e+i[4]*n+i[8]*r,this.y=i[1]*e+i[5]*n+i[9]*r,this.z=i[2]*e+i[6]*n+i[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,i=t.z,s=e.x,a=e.y,o=e.z;return this.x=r*o-i*a,this.y=i*s-n*o,this.z=n*a-r*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return cr.copy(this).projectOnVector(t),this.sub(cr)}reflect(t){return this.sub(cr.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(kn(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const cr=new ur,hr=new lr;class dr{constructor(t=new ur(1/0,1/0,1/0),e=new ur(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.length;o<l;o+=3){const l=t[o],u=t[o+1],c=t[o+2];l<e&&(e=l),u<n&&(n=u),c<r&&(r=c),l>i&&(i=l),u>s&&(s=u),c>a&&(a=c)}return this.min.set(e,n,r),this.max.set(i,s,a),this}setFromBufferAttribute(t){let e=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,a=-1/0;for(let o=0,l=t.count;o<l;o++){const l=t.getX(o),u=t.getY(o),c=t.getZ(o);l<e&&(e=l),u<n&&(n=u),c<r&&(r=c),l>i&&(i=l),u>s&&(s=u),c>a&&(a=c)}return this.min.set(e,n,r),this.max.set(i,s,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=fr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(void 0!==n)if(e&&null!=n.attributes&&void 0!==n.attributes.position){const e=n.attributes.position;for(let n=0,r=e.count;n<r;n++)fr.fromBufferAttribute(e,n).applyMatrix4(t.matrixWorld),this.expandByPoint(fr)}else null===n.boundingBox&&n.computeBoundingBox(),mr.copy(n.boundingBox),mr.applyMatrix4(t.matrixWorld),this.union(mr);const r=t.children;for(let t=0,n=r.length;t<n;t++)this.expandByObject(r[t],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,fr),fr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Sr),_r.subVectors(this.max,Sr),gr.subVectors(t.a,Sr),xr.subVectors(t.b,Sr),yr.subVectors(t.c,Sr),vr.subVectors(xr,gr),br.subVectors(yr,xr),wr.subVectors(gr,yr);let e=[0,-vr.z,vr.y,0,-br.z,br.y,0,-wr.z,wr.y,vr.z,0,-vr.x,br.z,0,-br.x,wr.z,0,-wr.x,-vr.y,vr.x,0,-br.y,br.x,0,-wr.y,wr.x,0];return!!Mr(e,gr,xr,yr,_r)&&(e=[1,0,0,0,1,0,0,0,1],!!Mr(e,gr,xr,yr,_r)&&(Ir.crossVectors(vr,br),e=[Ir.x,Ir.y,Ir.z],Mr(e,gr,xr,yr,_r)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return fr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(fr).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(pr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),pr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),pr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),pr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),pr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),pr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),pr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),pr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(pr)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const pr=[new ur,new ur,new ur,new ur,new ur,new ur,new ur,new ur],fr=new ur,mr=new dr,gr=new ur,xr=new ur,yr=new ur,vr=new ur,br=new ur,wr=new ur,Sr=new ur,_r=new ur,Ir=new ur,kr=new ur;function Mr(t,e,n,r,i){for(let s=0,a=t.length-3;s<=a;s+=3){kr.fromArray(t,s);const a=i.x*Math.abs(kr.x)+i.y*Math.abs(kr.y)+i.z*Math.abs(kr.z),o=e.dot(kr),l=n.dot(kr),u=r.dot(kr);if(Math.max(-Math.max(o,l,u),Math.min(o,l,u))>a)return!1}return!0}const Tr=new dr,Cr=new ur,Er=new ur,Ar=new ur;class Nr{constructor(t=new ur,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Tr.setFromPoints(t).getCenter(n);let r=0;for(let e=0,i=t.length;e<i;e++)r=Math.max(r,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Ar.subVectors(t,this.center);const e=Ar.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.add(Ar.multiplyScalar(n/t)),this.radius+=n}return this}union(t){return!0===this.center.equals(t.center)?Er.set(0,0,1).multiplyScalar(t.radius):Er.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Cr.copy(t.center).add(Er)),this.expandByPoint(Cr.copy(t.center).sub(Er)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Rr=new ur,Dr=new ur,Lr=new ur,Fr=new ur,$r=new ur,Pr=new ur,Or=new ur;class zr{constructor(t=new ur,e=new ur(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Rr)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Rr.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Rr.copy(this.direction).multiplyScalar(e).add(this.origin),Rr.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){Dr.copy(t).add(e).multiplyScalar(.5),Lr.copy(e).sub(t).normalize(),Fr.copy(this.origin).sub(Dr);const i=.5*t.distanceTo(e),s=-this.direction.dot(Lr),a=Fr.dot(this.direction),o=-Fr.dot(Lr),l=Fr.lengthSq(),u=Math.abs(1-s*s);let c,h,d,p;if(u>0)if(c=s*o-a,h=s*a-o,p=i*u,c>=0)if(h>=-p)if(h<=p){const t=1/u;c*=t,h*=t,d=c*(c+s*h+2*a)+h*(s*c+h+2*o)+l}else h=i,c=Math.max(0,-(s*h+a)),d=-c*c+h*(h+2*o)+l;else h=-i,c=Math.max(0,-(s*h+a)),d=-c*c+h*(h+2*o)+l;else h<=-p?(c=Math.max(0,-(-s*i+a)),h=c>0?-i:Math.min(Math.max(-i,-o),i),d=-c*c+h*(h+2*o)+l):h<=p?(c=0,h=Math.min(Math.max(-i,-o),i),d=h*(h+2*o)+l):(c=Math.max(0,-(s*i+a)),h=c>0?i:Math.min(Math.max(-i,-o),i),d=-c*c+h*(h+2*o)+l);else h=s>0?-i:i,c=Math.max(0,-(s*h+a)),d=-c*c+h*(h+2*o)+l;return n&&n.copy(this.direction).multiplyScalar(c).add(this.origin),r&&r.copy(Lr).multiplyScalar(h).add(Dr),d}intersectSphere(t,e){Rr.subVectors(t.center,this.origin);const n=Rr.dot(this.direction),r=Rr.dot(Rr)-n*n,i=t.radius*t.radius;if(r>i)return null;const s=Math.sqrt(i-r),a=n-s,o=n+s;return a<0&&o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,i,s,a,o;const l=1/this.direction.x,u=1/this.direction.y,c=1/this.direction.z,h=this.origin;return l>=0?(n=(t.min.x-h.x)*l,r=(t.max.x-h.x)*l):(n=(t.max.x-h.x)*l,r=(t.min.x-h.x)*l),u>=0?(i=(t.min.y-h.y)*u,s=(t.max.y-h.y)*u):(i=(t.max.y-h.y)*u,s=(t.min.y-h.y)*u),n>s||i>r?null:((i>n||n!=n)&&(n=i),(s<r||r!=r)&&(r=s),c>=0?(a=(t.min.z-h.z)*c,o=(t.max.z-h.z)*c):(a=(t.max.z-h.z)*c,o=(t.min.z-h.z)*c),n>o||a>r?null:((a>n||n!=n)&&(n=a),(o<r||r!=r)&&(r=o),r<0?null:this.at(n>=0?n:r,e)))}intersectsBox(t){return null!==this.intersectBox(t,Rr)}intersectTriangle(t,e,n,r,i){$r.subVectors(e,t),Pr.subVectors(n,t),Or.crossVectors($r,Pr);let s,a=this.direction.dot(Or);if(a>0){if(r)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}Fr.subVectors(this.origin,t);const o=s*this.direction.dot(Pr.crossVectors(Fr,Pr));if(o<0)return null;const l=s*this.direction.dot($r.cross(Fr));if(l<0)return null;if(o+l>a)return null;const u=-s*Fr.dot(Or);return u<0?null:this.at(u/a,i)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Br{constructor(){Br.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(t,e,n,r,i,s,a,o,l,u,c,h,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=r,g[1]=i,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=u,g[10]=c,g[14]=h,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Br).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/Ur.setFromMatrixColumn(t,0).length(),i=1/Ur.setFromMatrixColumn(t,1).length(),s=1/Ur.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*i,e[5]=n[5]*i,e[6]=n[6]*i,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,r=t.y,i=t.z,s=Math.cos(n),a=Math.sin(n),o=Math.cos(r),l=Math.sin(r),u=Math.cos(i),c=Math.sin(i);if("XYZ"===t.order){const t=s*u,n=s*c,r=a*u,i=a*c;e[0]=o*u,e[4]=-o*c,e[8]=l,e[1]=n+r*l,e[5]=t-i*l,e[9]=-a*o,e[2]=i-t*l,e[6]=r+n*l,e[10]=s*o}else if("YXZ"===t.order){const t=o*u,n=o*c,r=l*u,i=l*c;e[0]=t+i*a,e[4]=r*a-n,e[8]=s*l,e[1]=s*c,e[5]=s*u,e[9]=-a,e[2]=n*a-r,e[6]=i+t*a,e[10]=s*o}else if("ZXY"===t.order){const t=o*u,n=o*c,r=l*u,i=l*c;e[0]=t-i*a,e[4]=-s*c,e[8]=r+n*a,e[1]=n+r*a,e[5]=s*u,e[9]=i-t*a,e[2]=-s*l,e[6]=a,e[10]=s*o}else if("ZYX"===t.order){const t=s*u,n=s*c,r=a*u,i=a*c;e[0]=o*u,e[4]=r*l-n,e[8]=t*l+i,e[1]=o*c,e[5]=i*l+t,e[9]=n*l-r,e[2]=-l,e[6]=a*o,e[10]=s*o}else if("YZX"===t.order){const t=s*o,n=s*l,r=a*o,i=a*l;e[0]=o*u,e[4]=i-t*c,e[8]=r*c+n,e[1]=c,e[5]=s*u,e[9]=-a*u,e[2]=-l*u,e[6]=n*c+r,e[10]=t-i*c}else if("XZY"===t.order){const t=s*o,n=s*l,r=a*o,i=a*l;e[0]=o*u,e[4]=-c,e[8]=l*u,e[1]=t*c+i,e[5]=s*u,e[9]=n*c-r,e[2]=r*c-n,e[6]=a*u,e[10]=i*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Vr,t,Gr)}lookAt(t,e,n){const r=this.elements;return qr.subVectors(t,e),0===qr.lengthSq()&&(qr.z=1),qr.normalize(),Hr.crossVectors(n,qr),0===Hr.lengthSq()&&(1===Math.abs(n.z)?qr.x+=1e-4:qr.z+=1e-4,qr.normalize(),Hr.crossVectors(n,qr)),Hr.normalize(),jr.crossVectors(qr,Hr),r[0]=Hr.x,r[4]=jr.x,r[8]=qr.x,r[1]=Hr.y,r[5]=jr.y,r[9]=qr.y,r[2]=Hr.z,r[6]=jr.z,r[10]=qr.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,i=this.elements,s=n[0],a=n[4],o=n[8],l=n[12],u=n[1],c=n[5],h=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],x=n[3],y=n[7],v=n[11],b=n[15],w=r[0],S=r[4],_=r[8],I=r[12],k=r[1],M=r[5],T=r[9],C=r[13],E=r[2],A=r[6],N=r[10],R=r[14],D=r[3],L=r[7],F=r[11],$=r[15];return i[0]=s*w+a*k+o*E+l*D,i[4]=s*S+a*M+o*A+l*L,i[8]=s*_+a*T+o*N+l*F,i[12]=s*I+a*C+o*R+l*$,i[1]=u*w+c*k+h*E+d*D,i[5]=u*S+c*M+h*A+d*L,i[9]=u*_+c*T+h*N+d*F,i[13]=u*I+c*C+h*R+d*$,i[2]=p*w+f*k+m*E+g*D,i[6]=p*S+f*M+m*A+g*L,i[10]=p*_+f*T+m*N+g*F,i[14]=p*I+f*C+m*R+g*$,i[3]=x*w+y*k+v*E+b*D,i[7]=x*S+y*M+v*A+b*L,i[11]=x*_+y*T+v*N+b*F,i[15]=x*I+y*C+v*R+b*$,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],i=t[12],s=t[1],a=t[5],o=t[9],l=t[13],u=t[2],c=t[6],h=t[10],d=t[14];return t[3]*(+i*o*c-r*l*c-i*a*h+n*l*h+r*a*d-n*o*d)+t[7]*(+e*o*d-e*l*h+i*s*h-r*s*d+r*l*u-i*o*u)+t[11]*(+e*l*c-e*a*d-i*s*c+n*s*d+i*a*u-n*l*u)+t[15]*(-r*a*u-e*o*c+e*a*h+r*s*c-n*s*h+n*o*u)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],i=t[3],s=t[4],a=t[5],o=t[6],l=t[7],u=t[8],c=t[9],h=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],x=c*m*l-f*h*l+f*o*d-a*m*d-c*o*g+a*h*g,y=p*h*l-u*m*l-p*o*d+s*m*d+u*o*g-s*h*g,v=u*f*l-p*c*l+p*a*d-s*f*d-u*a*g+s*c*g,b=p*c*o-u*f*o-p*a*h+s*f*h+u*a*m-s*c*m,w=e*x+n*y+r*v+i*b;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/w;return t[0]=x*S,t[1]=(f*h*i-c*m*i-f*r*d+n*m*d+c*r*g-n*h*g)*S,t[2]=(a*m*i-f*o*i+f*r*l-n*m*l-a*r*g+n*o*g)*S,t[3]=(c*o*i-a*h*i-c*r*l+n*h*l+a*r*d-n*o*d)*S,t[4]=y*S,t[5]=(u*m*i-p*h*i+p*r*d-e*m*d-u*r*g+e*h*g)*S,t[6]=(p*o*i-s*m*i-p*r*l+e*m*l+s*r*g-e*o*g)*S,t[7]=(s*h*i-u*o*i+u*r*l-e*h*l-s*r*d+e*o*d)*S,t[8]=v*S,t[9]=(p*c*i-u*f*i-p*n*d+e*f*d+u*n*g-e*c*g)*S,t[10]=(s*f*i-p*a*i+p*n*l-e*f*l-s*n*g+e*a*g)*S,t[11]=(u*a*i-s*c*i-u*n*l+e*c*l+s*n*d-e*a*d)*S,t[12]=b*S,t[13]=(u*f*r-p*c*r+p*n*h-e*f*h-u*n*m+e*c*m)*S,t[14]=(p*a*r-s*f*r-p*n*o+e*f*o+s*n*m-e*a*m)*S,t[15]=(s*c*r-u*a*r+u*n*o-e*c*o-s*n*h+e*a*h)*S,this}scale(t){const e=this.elements,n=t.x,r=t.y,i=t.z;return e[0]*=n,e[4]*=r,e[8]*=i,e[1]*=n,e[5]*=r,e[9]*=i,e[2]*=n,e[6]*=r,e[10]*=i,e[3]*=n,e[7]*=r,e[11]*=i,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,r))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),i=1-n,s=t.x,a=t.y,o=t.z,l=i*s,u=i*a;return this.set(l*s+n,l*a-r*o,l*o+r*a,0,l*a+r*o,u*a+n,u*o-r*s,0,l*o-r*a,u*o+r*s,i*o*o+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,r,i,s){return this.set(1,n,i,0,t,1,s,0,e,r,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,i=e._x,s=e._y,a=e._z,o=e._w,l=i+i,u=s+s,c=a+a,h=i*l,d=i*u,p=i*c,f=s*u,m=s*c,g=a*c,x=o*l,y=o*u,v=o*c,b=n.x,w=n.y,S=n.z;return r[0]=(1-(f+g))*b,r[1]=(d+v)*b,r[2]=(p-y)*b,r[3]=0,r[4]=(d-v)*w,r[5]=(1-(h+g))*w,r[6]=(m+x)*w,r[7]=0,r[8]=(p+y)*S,r[9]=(m-x)*S,r[10]=(1-(h+f))*S,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let i=Ur.set(r[0],r[1],r[2]).length();const s=Ur.set(r[4],r[5],r[6]).length(),a=Ur.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),t.x=r[12],t.y=r[13],t.z=r[14],Wr.copy(this);const o=1/i,l=1/s,u=1/a;return Wr.elements[0]*=o,Wr.elements[1]*=o,Wr.elements[2]*=o,Wr.elements[4]*=l,Wr.elements[5]*=l,Wr.elements[6]*=l,Wr.elements[8]*=u,Wr.elements[9]*=u,Wr.elements[10]*=u,e.setFromRotationMatrix(Wr),n.x=i,n.y=s,n.z=a,this}makePerspective(t,e,n,r,i,s){const a=this.elements,o=2*i/(e-t),l=2*i/(n-r),u=(e+t)/(e-t),c=(n+r)/(n-r),h=-(s+i)/(s-i),d=-2*s*i/(s-i);return a[0]=o,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=l,a[9]=c,a[13]=0,a[2]=0,a[6]=0,a[10]=h,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,r,i,s){const a=this.elements,o=1/(e-t),l=1/(n-r),u=1/(s-i),c=(e+t)*o,h=(n+r)*l,d=(s+i)*u;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-c,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-h,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const Ur=new ur,Wr=new Br,Vr=new ur(0,0,0),Gr=new ur(1,1,1),Hr=new ur,jr=new ur,qr=new ur,Xr=new Br,Kr=new lr;class Yr{constructor(t=0,e=0,n=0,r=Yr.DefaultOrder){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r=this._order){return this._x=t,this._y=e,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const r=t.elements,i=r[0],s=r[4],a=r[8],o=r[1],l=r[5],u=r[9],c=r[2],h=r[6],d=r[10];switch(e){case"XYZ":this._y=Math.asin(kn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,d),this._z=Math.atan2(-s,i)):(this._x=Math.atan2(h,l),this._z=0);break;case"YXZ":this._x=Math.asin(-kn(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-c,i),this._z=0);break;case"ZXY":this._x=Math.asin(kn(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-c,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,i));break;case"ZYX":this._y=Math.asin(-kn(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(h,d),this._z=Math.atan2(o,i)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(kn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,l),this._y=Math.atan2(-c,i)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-kn(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(h,l),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-u,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Xr.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Xr,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Kr.setFromEuler(this),this.setFromQuaternion(Kr,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}Yr.DefaultOrder="XYZ",Yr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Zr{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}isEnabled(t){return 0!=(this.mask&(1<<t|0))}}let Jr=0;const Qr=new ur,ti=new lr,ei=new Br,ni=new ur,ri=new ur,ii=new ur,si=new lr,ai=new ur(1,0,0),oi=new ur(0,1,0),li=new ur(0,0,1),ui={type:"added"},ci={type:"removed"};class hi extends vn{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Jr++}),this.uuid=In(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=hi.DefaultUp.clone();const t=new ur,e=new Yr,n=new lr,r=new ur(1,1,1);e._onChange((function(){n.setFromEuler(e,!1)})),n._onChange((function(){e.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Br},normalMatrix:{value:new Dn}}),this.matrix=new Br,this.matrixWorld=new Br,this.matrixAutoUpdate=hi.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Zr,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return ti.setFromAxisAngle(t,e),this.quaternion.multiply(ti),this}rotateOnWorldAxis(t,e){return ti.setFromAxisAngle(t,e),this.quaternion.premultiply(ti),this}rotateX(t){return this.rotateOnAxis(ai,t)}rotateY(t){return this.rotateOnAxis(oi,t)}rotateZ(t){return this.rotateOnAxis(li,t)}translateOnAxis(t,e){return Qr.copy(t).applyQuaternion(this.quaternion),this.position.add(Qr.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(ai,t)}translateY(t){return this.translateOnAxis(oi,t)}translateZ(t){return this.translateOnAxis(li,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(ei.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?ni.copy(t):ni.set(t,e,n);const r=this.parent;this.updateWorldMatrix(!0,!1),ri.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ei.lookAt(ri,ni,this.up):ei.lookAt(ni,ri,this.up),this.quaternion.setFromRotationMatrix(ei),r&&(ei.extractRotation(r.matrixWorld),ti.setFromRotationMatrix(ei),this.quaternion.premultiply(ti.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(ui)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(ci)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(ci)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),ei.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),ei.multiply(t.parent.matrixWorld)),t.applyMatrix4(ei),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n].getObjectByProperty(t,e);if(void 0!==r)return r}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ri,t,ii),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ri,si,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function i(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(r.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,r=n.length;e<r;e++){const r=n[e];i(t.shapes,r)}else i(t.shapes,n)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(t.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,r=this.material.length;n<r;n++)e.push(i(t.materials,this.material[n]));r.material=e}else r.material=i(t.materials,this.material);if(this.children.length>0){r.children=[];for(let e=0;e<this.children.length;e++)r.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){r.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];r.animations.push(i(t.animations,n))}}if(e){const e=s(t.geometries),r=s(t.materials),i=s(t.textures),a=s(t.images),o=s(t.shapes),l=s(t.skeletons),u=s(t.animations),c=s(t.nodes);e.length>0&&(n.geometries=e),r.length>0&&(n.materials=r),i.length>0&&(n.textures=i),a.length>0&&(n.images=a),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),u.length>0&&(n.animations=u),c.length>0&&(n.nodes=c)}return n.object=r,n;function s(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}hi.DefaultUp=new ur(0,1,0),hi.DefaultMatrixAutoUpdate=!0;const di=new ur,pi=new ur,fi=new ur,mi=new ur,gi=new ur,xi=new ur,yi=new ur,vi=new ur,bi=new ur,wi=new ur;class Si{constructor(t=new ur,e=new ur,n=new ur){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,r){r.subVectors(n,e),di.subVectors(t,e),r.cross(di);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(t,e,n,r,i){di.subVectors(r,e),pi.subVectors(n,e),fi.subVectors(t,e);const s=di.dot(di),a=di.dot(pi),o=di.dot(fi),l=pi.dot(pi),u=pi.dot(fi),c=s*l-a*a;if(0===c)return i.set(-2,-1,-1);const h=1/c,d=(l*o-a*u)*h,p=(s*u-a*o)*h;return i.set(1-d-p,p,d)}static containsPoint(t,e,n,r){return this.getBarycoord(t,e,n,r,mi),mi.x>=0&&mi.y>=0&&mi.x+mi.y<=1}static getUV(t,e,n,r,i,s,a,o){return this.getBarycoord(t,e,n,r,mi),o.set(0,0),o.addScaledVector(i,mi.x),o.addScaledVector(s,mi.y),o.addScaledVector(a,mi.z),o}static isFrontFacing(t,e,n,r){return di.subVectors(n,e),pi.subVectors(t,e),di.cross(pi).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}setFromAttributeAndIndices(t,e,n,r){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,r),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return di.subVectors(this.c,this.b),pi.subVectors(this.a,this.b),.5*di.cross(pi).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Si.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Si.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,r,i){return Si.getUV(t,this.a,this.b,this.c,e,n,r,i)}containsPoint(t){return Si.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Si.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,r=this.b,i=this.c;let s,a;gi.subVectors(r,n),xi.subVectors(i,n),vi.subVectors(t,n);const o=gi.dot(vi),l=xi.dot(vi);if(o<=0&&l<=0)return e.copy(n);bi.subVectors(t,r);const u=gi.dot(bi),c=xi.dot(bi);if(u>=0&&c<=u)return e.copy(r);const h=o*c-u*l;if(h<=0&&o>=0&&u<=0)return s=o/(o-u),e.copy(n).addScaledVector(gi,s);wi.subVectors(t,i);const d=gi.dot(wi),p=xi.dot(wi);if(p>=0&&d<=p)return e.copy(i);const f=d*l-o*p;if(f<=0&&l>=0&&p<=0)return a=l/(l-p),e.copy(n).addScaledVector(xi,a);const m=u*p-d*c;if(m<=0&&c-u>=0&&d-p>=0)return yi.subVectors(i,r),a=(c-u)/(c-u+(d-p)),e.copy(r).addScaledVector(yi,a);const g=1/(m+f+h);return s=f*g,a=h*g,e.copy(n).addScaledVector(gi,s).addScaledVector(xi,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let _i=0;class Ii extends vn{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:_i++}),this.uuid=In(),this.name="",this.type="Material",this.blending=_,this.side=x,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=P,this.blendDst=O,this.blendEquation=C,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=q,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=an,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=He,this.stencilZFail=He,this.stencilZPass=He,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===b;continue}const r=this[e];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(n.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(n.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==_&&(n.blending=this.blending),this.side!==x&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=r(t.textures),i=r(t.images);e.length>0&&(n.textures=e),i.length>0&&(n.images=i)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let r=0;r!==t;++r)n[r]=e[r].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}class ki extends Ii{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Xn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=J,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const Mi=new ur,Ti=new Rn;class Ci{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=on,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[t+r]=e.array[n+r];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new Xn),e[n++]=i.r,e[n++]=i.g,e[n++]=i.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new Rn),e[n++]=i.x,e[n++]=i.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new ur),e[n++]=i.x,e[n++]=i.y,e[n++]=i.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let r=0,i=t.length;r<i;r++){let i=t[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new er),e[n++]=i.x,e[n++]=i.y,e[n++]=i.z,e[n++]=i.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)Ti.fromBufferAttribute(this,e),Ti.applyMatrix3(t),this.setXY(e,Ti.x,Ti.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)Mi.fromBufferAttribute(this,e),Mi.applyMatrix3(t),this.setXYZ(e,Mi.x,Mi.y,Mi.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)Mi.fromBufferAttribute(this,e),Mi.applyMatrix4(t),this.setXYZ(e,Mi.x,Mi.y,Mi.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Mi.fromBufferAttribute(this,e),Mi.applyNormalMatrix(t),this.setXYZ(e,Mi.x,Mi.y,Mi.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Mi.fromBufferAttribute(this,e),Mi.transformDirection(t),this.setXYZ(e,Mi.x,Mi.y,Mi.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this}setXYZW(t,e,n,r,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this.array[t+3]=i,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==on&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}}class Ei extends Ci{constructor(t,e,n){super(new Int8Array(t),e,n)}}class Ai extends Ci{constructor(t,e,n){super(new Uint8Array(t),e,n)}}class Ni extends Ci{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}}class Ri extends Ci{constructor(t,e,n){super(new Int16Array(t),e,n)}}class Di extends Ci{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Li extends Ci{constructor(t,e,n){super(new Int32Array(t),e,n)}}class Fi extends Ci{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class $i extends Ci{constructor(t,e,n){super(new Uint16Array(t),e,n),this.isFloat16BufferAttribute=!0}}class Pi extends Ci{constructor(t,e,n){super(new Float32Array(t),e,n)}}class Oi extends Ci{constructor(t,e,n){super(new Float64Array(t),e,n)}}let zi=0;const Bi=new Br,Ui=new hi,Wi=new ur,Vi=new dr,Gi=new dr,Hi=new ur;class ji extends vn{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:zi++}),this.uuid=In(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Ln(t)?Fi:Di)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new Dn).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(t),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Bi.makeRotationFromQuaternion(t),this.applyMatrix4(Bi),this}rotateX(t){return Bi.makeRotationX(t),this.applyMatrix4(Bi),this}rotateY(t){return Bi.makeRotationY(t),this.applyMatrix4(Bi),this}rotateZ(t){return Bi.makeRotationZ(t),this.applyMatrix4(Bi),this}translate(t,e,n){return Bi.makeTranslation(t,e,n),this.applyMatrix4(Bi),this}scale(t,e,n){return Bi.makeScale(t,e,n),this.applyMatrix4(Bi),this}lookAt(t){return Ui.lookAt(t),Ui.updateMatrix(),this.applyMatrix4(Ui.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Wi).negate(),this.translate(Wi.x,Wi.y,Wi.z),this}setFromPoints(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Pi(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new dr);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new ur(-1/0,-1/0,-1/0),new ur(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Vi.setFromBufferAttribute(n),this.morphTargetsRelative?(Hi.addVectors(this.boundingBox.min,Vi.min),this.boundingBox.expandByPoint(Hi),Hi.addVectors(this.boundingBox.max,Vi.max),this.boundingBox.expandByPoint(Hi)):(this.boundingBox.expandByPoint(Vi.min),this.boundingBox.expandByPoint(Vi.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Nr);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new ur,1/0);if(t){const n=this.boundingSphere.center;if(Vi.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Gi.setFromBufferAttribute(n),this.morphTargetsRelative?(Hi.addVectors(Vi.min,Gi.min),Vi.expandByPoint(Hi),Hi.addVectors(Vi.max,Gi.max),Vi.expandByPoint(Hi)):(Vi.expandByPoint(Gi.min),Vi.expandByPoint(Gi.max))}Vi.getCenter(n);let r=0;for(let e=0,i=t.count;e<i;e++)Hi.fromBufferAttribute(t,e),r=Math.max(r,n.distanceToSquared(Hi));if(e)for(let i=0,s=e.length;i<s;i++){const s=e[i],a=this.morphTargetsRelative;for(let e=0,i=s.count;e<i;e++)Hi.fromBufferAttribute(s,e),a&&(Wi.fromBufferAttribute(t,e),Hi.add(Wi)),r=Math.max(r,n.distanceToSquared(Hi))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,r=e.position.array,i=e.normal.array,s=e.uv.array,a=r.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Ci(new Float32Array(4*a),4));const o=this.getAttribute("tangent").array,l=[],u=[];for(let t=0;t<a;t++)l[t]=new ur,u[t]=new ur;const c=new ur,h=new ur,d=new ur,p=new Rn,f=new Rn,m=new Rn,g=new ur,x=new ur;function y(t,e,n){c.fromArray(r,3*t),h.fromArray(r,3*e),d.fromArray(r,3*n),p.fromArray(s,2*t),f.fromArray(s,2*e),m.fromArray(s,2*n),h.sub(c),d.sub(c),f.sub(p),m.sub(p);const i=1/(f.x*m.y-m.x*f.y);isFinite(i)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(i),x.copy(d).multiplyScalar(f.x).addScaledVector(h,-m.x).multiplyScalar(i),l[t].add(g),l[e].add(g),l[n].add(g),u[t].add(x),u[e].add(x),u[n].add(x))}let v=this.groups;0===v.length&&(v=[{start:0,count:n.length}]);for(let t=0,e=v.length;t<e;++t){const e=v[t],r=e.start;for(let t=r,i=r+e.count;t<i;t+=3)y(n[t+0],n[t+1],n[t+2])}const b=new ur,w=new ur,S=new ur,_=new ur;function I(t){S.fromArray(i,3*t),_.copy(S);const e=l[t];b.copy(e),b.sub(S.multiplyScalar(S.dot(e))).normalize(),w.crossVectors(_,e);const n=w.dot(u[t])<0?-1:1;o[4*t]=b.x,o[4*t+1]=b.y,o[4*t+2]=b.z,o[4*t+3]=n}for(let t=0,e=v.length;t<e;++t){const e=v[t],r=e.start;for(let t=r,i=r+e.count;t<i;t+=3)I(n[t+0]),I(n[t+1]),I(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new Ci(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const r=new ur,i=new ur,s=new ur,a=new ur,o=new ur,l=new ur,u=new ur,c=new ur;if(t)for(let h=0,d=t.count;h<d;h+=3){const d=t.getX(h+0),p=t.getX(h+1),f=t.getX(h+2);r.fromBufferAttribute(e,d),i.fromBufferAttribute(e,p),s.fromBufferAttribute(e,f),u.subVectors(s,i),c.subVectors(r,i),u.cross(c),a.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),a.add(u),o.add(u),l.add(u),n.setXYZ(d,a.x,a.y,a.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,a=e.count;t<a;t+=3)r.fromBufferAttribute(e,t+0),i.fromBufferAttribute(e,t+1),s.fromBufferAttribute(e,t+2),u.subVectors(s,i),c.subVectors(r,i),u.cross(c),n.setXYZ(t+0,u.x,u.y,u.z),n.setXYZ(t+1,u.x,u.y,u.z),n.setXYZ(t+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(void 0===t.attributes[r])continue;const i=n[r].array,s=t.attributes[r],a=s.array,o=s.itemSize*e,l=Math.min(a.length,i.length-o);for(let t=0,e=o;t<l;t++,e++)i[e]=a[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Hi.fromBufferAttribute(t,e),Hi.normalize(),t.setXYZ(e,Hi.x,Hi.y,Hi.z)}toNonIndexed(){function t(t,e){const n=t.array,r=t.itemSize,i=t.normalized,s=new n.constructor(e.length*r);let a=0,o=0;for(let i=0,l=e.length;i<l;i++){a=t.isInterleavedBufferAttribute?e[i]*t.data.stride+t.offset:e[i]*r;for(let t=0;t<r;t++)s[o++]=n[a++]}return new Ci(s,r,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new ji,n=this.index.array,r=this.attributes;for(const i in r){const s=t(r[i],n);e.setAttribute(i,s)}const i=this.morphAttributes;for(const r in i){const s=[],a=i[r];for(let e=0,r=a.length;e<r;e++){const r=t(a[e],n);s.push(r)}e.morphAttributes[r]=s}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let t=0,n=s.length;t<n;t++){const n=s[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const r=n[e];t.data.attributes[e]=r.toJSON(t.data)}const r={};let i=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],s=[];for(let e=0,r=n.length;e<r;e++){const r=n[e];s.push(r.toJSON(t.data))}s.length>0&&(r[e]=s,i=!0)}i&&(t.data.morphAttributes=r,t.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(t.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const r=t.attributes;for(const t in r){const n=r[t];this.setAttribute(t,n.clone(e))}const i=t.morphAttributes;for(const t in i){const n=[],r=i[t];for(let t=0,i=r.length;t<i;t++)n.push(r[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const s=t.groups;for(let t=0,e=s.length;t<e;t++){const e=s[t];this.addGroup(e.start,e.count,e.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const qi=new Br,Xi=new zr,Ki=new Nr,Yi=new ur,Zi=new ur,Ji=new ur,Qi=new ur,ts=new ur,es=new ur,ns=new ur,rs=new ur,is=new ur,ss=new Rn,as=new Rn,os=new Rn,ls=new ur,us=new ur;class cs extends hi{constructor(t=new ji,e=new ki){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}raycast(t,e){const n=this.geometry,r=this.material,i=this.matrixWorld;if(void 0===r)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),Ki.copy(n.boundingSphere),Ki.applyMatrix4(i),!1===t.ray.intersectsSphere(Ki))return;if(qi.copy(i).invert(),Xi.copy(t.ray).applyMatrix4(qi),null!==n.boundingBox&&!1===Xi.intersectsBox(n.boundingBox))return;let s;const a=n.index,o=n.attributes.position,l=n.morphAttributes.position,u=n.morphTargetsRelative,c=n.attributes.uv,h=n.attributes.uv2,d=n.groups,p=n.drawRange;if(null!==a)if(Array.isArray(r))for(let n=0,i=d.length;n<i;n++){const i=d[n],f=r[i.materialIndex];for(let n=Math.max(i.start,p.start),r=Math.min(a.count,Math.min(i.start+i.count,p.start+p.count));n<r;n+=3){const r=a.getX(n),d=a.getX(n+1),p=a.getX(n+2);s=hs(this,f,t,Xi,o,l,u,c,h,r,d,p),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,e.push(s))}}else for(let n=Math.max(0,p.start),i=Math.min(a.count,p.start+p.count);n<i;n+=3){const i=a.getX(n),d=a.getX(n+1),p=a.getX(n+2);s=hs(this,r,t,Xi,o,l,u,c,h,i,d,p),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}else if(void 0!==o)if(Array.isArray(r))for(let n=0,i=d.length;n<i;n++){const i=d[n],a=r[i.materialIndex];for(let n=Math.max(i.start,p.start),r=Math.min(o.count,Math.min(i.start+i.count,p.start+p.count));n<r;n+=3)s=hs(this,a,t,Xi,o,l,u,c,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,e.push(s))}else for(let n=Math.max(0,p.start),i=Math.min(o.count,p.start+p.count);n<i;n+=3)s=hs(this,r,t,Xi,o,l,u,c,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),e.push(s))}}function hs(t,e,n,r,i,s,a,o,l,u,c,h){Yi.fromBufferAttribute(i,u),Zi.fromBufferAttribute(i,c),Ji.fromBufferAttribute(i,h);const d=t.morphTargetInfluences;if(s&&d){ns.set(0,0,0),rs.set(0,0,0),is.set(0,0,0);for(let t=0,e=s.length;t<e;t++){const e=d[t],n=s[t];0!==e&&(Qi.fromBufferAttribute(n,u),ts.fromBufferAttribute(n,c),es.fromBufferAttribute(n,h),a?(ns.addScaledVector(Qi,e),rs.addScaledVector(ts,e),is.addScaledVector(es,e)):(ns.addScaledVector(Qi.sub(Yi),e),rs.addScaledVector(ts.sub(Zi),e),is.addScaledVector(es.sub(Ji),e)))}Yi.add(ns),Zi.add(rs),Ji.add(is)}t.isSkinnedMesh&&(t.boneTransform(u,Yi),t.boneTransform(c,Zi),t.boneTransform(h,Ji));const p=function(t,e,n,r,i,s,a,o){let l;if(l=e.side===y?r.intersectTriangle(a,s,i,!0,o):r.intersectTriangle(i,s,a,e.side!==v,o),null===l)return null;us.copy(o),us.applyMatrix4(t.matrixWorld);const u=n.ray.origin.distanceTo(us);return u<n.near||u>n.far?null:{distance:u,point:us.clone(),object:t}}(t,e,n,r,Yi,Zi,Ji,ls);if(p){o&&(ss.fromBufferAttribute(o,u),as.fromBufferAttribute(o,c),os.fromBufferAttribute(o,h),p.uv=Si.getUV(ls,Yi,Zi,Ji,ss,as,os,new Rn)),l&&(ss.fromBufferAttribute(l,u),as.fromBufferAttribute(l,c),os.fromBufferAttribute(l,h),p.uv2=Si.getUV(ls,Yi,Zi,Ji,ss,as,os,new Rn));const t={a:u,b:c,c:h,normal:new ur,materialIndex:0};Si.getNormal(Yi,Zi,Ji,t.normal),p.face=t}return p}class ds extends ji{constructor(t=1,e=1,n=1,r=1,i=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:i,depthSegments:s};const a=this;r=Math.floor(r),i=Math.floor(i),s=Math.floor(s);const o=[],l=[],u=[],c=[];let h=0,d=0;function p(t,e,n,r,i,s,p,f,m,g,x){const y=s/m,v=p/g,b=s/2,w=p/2,S=f/2,_=m+1,I=g+1;let k=0,M=0;const T=new ur;for(let s=0;s<I;s++){const a=s*v-w;for(let o=0;o<_;o++){const h=o*y-b;T[t]=h*r,T[e]=a*i,T[n]=S,l.push(T.x,T.y,T.z),T[t]=0,T[e]=0,T[n]=f>0?1:-1,u.push(T.x,T.y,T.z),c.push(o/m),c.push(1-s/g),k+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=h+e+_*t,r=h+e+_*(t+1),i=h+(e+1)+_*(t+1),s=h+(e+1)+_*t;o.push(n,r,s),o.push(r,i,s),M+=6}a.addGroup(d,M,x),d+=M,h+=k}p("z","y","x",-1,-1,n,e,t,s,i,0),p("z","y","x",1,-1,n,e,-t,s,i,1),p("x","z","y",1,1,t,n,e,r,s,2),p("x","z","y",1,-1,t,n,-e,r,s,3),p("x","y","z",1,-1,t,e,n,r,i,4),p("x","y","z",-1,-1,t,e,-n,r,i,5),this.setIndex(o),this.setAttribute("position",new Pi(l,3)),this.setAttribute("normal",new Pi(u,3)),this.setAttribute("uv",new Pi(c,2))}static fromJSON(t){return new ds(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function ps(t){const e={};for(const n in t){e[n]={};for(const r in t[n]){const i=t[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[n][r]=i.clone():Array.isArray(i)?e[n][r]=i.slice():e[n][r]=i}}return e}function fs(t){const e={};for(let n=0;n<t.length;n++){const r=ps(t[n]);for(const t in r)e[t]=r[t]}return e}const ms={clone:ps,merge:fs};class gs extends Ii{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=ps(t.uniforms),this.uniformsGroups=function(t){const e=[];for(let n=0;n<t.length;n++)e.push(t[n].clone());return e}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?e.uniforms[n]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[n]={type:"m4",value:r.toArray()}:e.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class xs extends hi{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Br,this.projectionMatrix=new Br,this.projectionMatrixInverse=new Br}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}class ys extends xs{constructor(t=50,e=1,n=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*_n*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Sn*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*_n*Math.atan(Math.tan(.5*Sn*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,r,i,s){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Sn*this.fov)/this.zoom,n=2*e,r=this.aspect*n,i=-.5*r;const s=this.view;if(null!==this.view&&this.view.enabled){const t=s.fullWidth,a=s.fullHeight;i+=s.offsetX*r/t,e-=s.offsetY*n/a,r*=s.width/t,n*=s.height/a}const a=this.filmOffset;0!==a&&(i+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const vs=90;class bs extends hi{constructor(t,e,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const r=new ys(vs,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new ur(1,0,0)),this.add(r);const i=new ys(vs,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new ur(-1,0,0)),this.add(i);const s=new ys(vs,1,t,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new ur(0,1,0)),this.add(s);const a=new ys(vs,1,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new ur(0,-1,0)),this.add(a);const o=new ys(vs,1,t,e);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new ur(0,0,1)),this.add(o);const l=new ys(vs,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new ur(0,0,-1)),this.add(l)}update(t,e){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[r,i,s,a,o,l]=this.children,u=t.getRenderTarget(),c=t.toneMapping,h=t.xr.enabled;t.toneMapping=et,t.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,r),t.setRenderTarget(n,1),t.render(e,i),t.setRenderTarget(n,2),t.render(e,s),t.setRenderTarget(n,3),t.render(e,a),t.setRenderTarget(n,4),t.render(e,o),n.texture.generateMipmaps=d,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(u),t.toneMapping=c,t.xr.enabled=h,n.texture.needsPMREMUpdate=!0}}class ws extends tr{constructor(t,e,n,r,i,s,a,o,l,u){super(t=void 0!==t?t:[],e=void 0!==e?e:lt,n,r,i,s,a,o,l,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class Ss extends nr{constructor(t,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},r=[n,n,n,n,n,n];this.texture=new ws(r,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:wt}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={tEquirect:{value:null}},r="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",i="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",s=new ds(5,5,5),a=new gs({name:"CubemapFromEquirect",uniforms:ps(n),vertexShader:r,fragmentShader:i,side:y,blending:S});a.uniforms.tEquirect.value=e;const o=new cs(s,a),l=e.minFilter;return e.minFilter===It&&(e.minFilter=wt),new bs(1,10,this).update(t,o),e.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(t,e,n,r){const i=t.getRenderTarget();for(let i=0;i<6;i++)t.setRenderTarget(this,i),t.clear(e,n,r);t.setRenderTarget(i)}}const _s=new ur,Is=new ur,ks=new Dn;class Ms{constructor(t=new ur(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,r){return this.normal.set(t,e,n),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const r=_s.subVectors(n,e).cross(Is.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(_s),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const i=-(t.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:e.copy(n).multiplyScalar(i).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||ks.getNormalMatrix(t),r=this.coplanarPoint(_s).applyMatrix4(t),i=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(i),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const Ts=new Nr,Cs=new ur;class Es{constructor(t=new Ms,e=new Ms,n=new Ms,r=new Ms,i=new Ms,s=new Ms){this.planes=[t,e,n,r,i,s]}set(t,e,n,r,i,s){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(r),a[4].copy(i),a[5].copy(s),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,r=n[0],i=n[1],s=n[2],a=n[3],o=n[4],l=n[5],u=n[6],c=n[7],h=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],x=n[14],y=n[15];return e[0].setComponents(a-r,c-o,f-h,y-m).normalize(),e[1].setComponents(a+r,c+o,f+h,y+m).normalize(),e[2].setComponents(a+i,c+l,f+d,y+g).normalize(),e[3].setComponents(a-i,c-l,f-d,y-g).normalize(),e[4].setComponents(a-s,c-u,f-p,y-x).normalize(),e[5].setComponents(a+s,c+u,f+p,y+x).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),Ts.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Ts)}intersectsSprite(t){return Ts.center.set(0,0,0),Ts.radius=.7071067811865476,Ts.applyMatrix4(t.matrixWorld),this.intersectsSphere(Ts)}intersectsSphere(t){const e=this.planes,n=t.center,r=-t.radius;for(let t=0;t<6;t++)if(e[t].distanceToPoint(n)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const r=e[n];if(Cs.x=r.normal.x>0?t.max.x:t.min.x,Cs.y=r.normal.y>0?t.max.y:t.min.y,Cs.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(Cs)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function As(){let t=null,e=!1,n=null,r=null;function i(e,s){n(e,s),r=t.requestAnimationFrame(i)}return{start:function(){!0!==e&&null!==n&&(r=t.requestAnimationFrame(i),e=!0)},stop:function(){t.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Ns(t,e){const n=e.isWebGL2,r=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),r.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=r.get(e);n&&(t.deleteBuffer(n.buffer),r.delete(e))},update:function(e,i){if(e.isGLBufferAttribute){const t=r.get(e);return void((!t||t.version<e.version)&&r.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const s=r.get(e);void 0===s?r.set(e,function(e,r){const i=e.array,s=e.usage,a=t.createBuffer();let o;if(t.bindBuffer(r,a),t.bufferData(r,i,s),e.onUploadCallback(),i instanceof Float32Array)o=5126;else if(i instanceof Uint16Array)if(e.isFloat16BufferAttribute){if(!n)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");o=5131}else o=5123;else if(i instanceof Int16Array)o=5122;else if(i instanceof Uint32Array)o=5125;else if(i instanceof Int32Array)o=5124;else if(i instanceof Int8Array)o=5120;else if(i instanceof Uint8Array)o=5121;else{if(!(i instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+i);o=5121}return{buffer:a,type:o,bytesPerElement:i.BYTES_PER_ELEMENT,version:e.version}}(e,i)):s.version<e.version&&(function(e,r,i){const s=r.array,a=r.updateRange;t.bindBuffer(i,e),-1===a.count?t.bufferSubData(i,0,s):(n?t.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):t.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}(s.buffer,e,i),s.version=e.version)}}}class Rs extends ji{constructor(t=1,e=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:r};const i=t/2,s=e/2,a=Math.floor(n),o=Math.floor(r),l=a+1,u=o+1,c=t/a,h=e/o,d=[],p=[],f=[],m=[];for(let t=0;t<u;t++){const e=t*h-s;for(let n=0;n<l;n++){const r=n*c-i;p.push(r,-e,0),f.push(0,0,1),m.push(n/a),m.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<a;e++){const n=e+l*t,r=e+l*(t+1),i=e+1+l*(t+1),s=e+1+l*t;d.push(n,r,s),d.push(r,i,s)}this.setIndex(d),this.setAttribute("position",new Pi(p,3)),this.setAttribute("normal",new Pi(f,3)),this.setAttribute("uv",new Pi(m,2))}static fromJSON(t){return new Rs(t.width,t.height,t.widthSegments,t.heightSegments)}}const Ds={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},Ls={common:{diffuse:{value:new Xn(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Dn},uv2Transform:{value:new Dn},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Rn(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Xn(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Xn(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Dn}},sprite:{diffuse:{value:new Xn(16777215)},opacity:{value:1},center:{value:new Rn(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Dn}}},Fs={basic:{uniforms:fs([Ls.common,Ls.specularmap,Ls.envmap,Ls.aomap,Ls.lightmap,Ls.fog]),vertexShader:Ds.meshbasic_vert,fragmentShader:Ds.meshbasic_frag},lambert:{uniforms:fs([Ls.common,Ls.specularmap,Ls.envmap,Ls.aomap,Ls.lightmap,Ls.emissivemap,Ls.fog,Ls.lights,{emissive:{value:new Xn(0)}}]),vertexShader:Ds.meshlambert_vert,fragmentShader:Ds.meshlambert_frag},phong:{uniforms:fs([Ls.common,Ls.specularmap,Ls.envmap,Ls.aomap,Ls.lightmap,Ls.emissivemap,Ls.bumpmap,Ls.normalmap,Ls.displacementmap,Ls.fog,Ls.lights,{emissive:{value:new Xn(0)},specular:{value:new Xn(1118481)},shininess:{value:30}}]),vertexShader:Ds.meshphong_vert,fragmentShader:Ds.meshphong_frag},standard:{uniforms:fs([Ls.common,Ls.envmap,Ls.aomap,Ls.lightmap,Ls.emissivemap,Ls.bumpmap,Ls.normalmap,Ls.displacementmap,Ls.roughnessmap,Ls.metalnessmap,Ls.fog,Ls.lights,{emissive:{value:new Xn(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ds.meshphysical_vert,fragmentShader:Ds.meshphysical_frag},toon:{uniforms:fs([Ls.common,Ls.aomap,Ls.lightmap,Ls.emissivemap,Ls.bumpmap,Ls.normalmap,Ls.displacementmap,Ls.gradientmap,Ls.fog,Ls.lights,{emissive:{value:new Xn(0)}}]),vertexShader:Ds.meshtoon_vert,fragmentShader:Ds.meshtoon_frag},matcap:{uniforms:fs([Ls.common,Ls.bumpmap,Ls.normalmap,Ls.displacementmap,Ls.fog,{matcap:{value:null}}]),vertexShader:Ds.meshmatcap_vert,fragmentShader:Ds.meshmatcap_frag},points:{uniforms:fs([Ls.points,Ls.fog]),vertexShader:Ds.points_vert,fragmentShader:Ds.points_frag},dashed:{uniforms:fs([Ls.common,Ls.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ds.linedashed_vert,fragmentShader:Ds.linedashed_frag},depth:{uniforms:fs([Ls.common,Ls.displacementmap]),vertexShader:Ds.depth_vert,fragmentShader:Ds.depth_frag},normal:{uniforms:fs([Ls.common,Ls.bumpmap,Ls.normalmap,Ls.displacementmap,{opacity:{value:1}}]),vertexShader:Ds.meshnormal_vert,fragmentShader:Ds.meshnormal_frag},sprite:{uniforms:fs([Ls.sprite,Ls.fog]),vertexShader:Ds.sprite_vert,fragmentShader:Ds.sprite_frag},background:{uniforms:{uvTransform:{value:new Dn},t2D:{value:null}},vertexShader:Ds.background_vert,fragmentShader:Ds.background_frag},cube:{uniforms:fs([Ls.envmap,{opacity:{value:1}}]),vertexShader:Ds.cube_vert,fragmentShader:Ds.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ds.equirect_vert,fragmentShader:Ds.equirect_frag},distanceRGBA:{uniforms:fs([Ls.common,Ls.displacementmap,{referencePosition:{value:new ur},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ds.distanceRGBA_vert,fragmentShader:Ds.distanceRGBA_frag},shadow:{uniforms:fs([Ls.lights,Ls.fog,{color:{value:new Xn(0)},opacity:{value:1}}]),vertexShader:Ds.shadow_vert,fragmentShader:Ds.shadow_frag}};function $s(t,e,n,r,i,s){const a=new Xn(0);let o,l,u=!0===i?0:1,c=null,h=0,d=null;function p(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,s)}return{getClearColor:function(){return a},setClearColor:function(t,e=1){a.set(t),u=e,p(a,u)},getClearAlpha:function(){return u},setClearAlpha:function(t){u=t,p(a,u)},render:function(n,i){let s=!1,f=!0===i.isScene?i.background:null;f&&f.isTexture&&(f=e.get(f));const m=t.xr,g=m.getSession&&m.getSession();g&&"additive"===g.environmentBlendMode&&(f=null),null===f?p(a,u):f&&f.isColor&&(p(f,1),s=!0),(t.autoClear||s)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),f&&(f.isCubeTexture||f.mapping===dt)?(void 0===l&&(l=new cs(new ds(1,1,1),new gs({name:"BackgroundCubeMaterial",uniforms:ps(Fs.cube.uniforms),vertexShader:Fs.cube.vertexShader,fragmentShader:Fs.cube.fragmentShader,side:y,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(l)),l.material.uniforms.envMap.value=f,l.material.uniforms.flipEnvMap.value=f.isCubeTexture&&!1===f.isRenderTargetTexture?-1:1,c===f&&h===f.version&&d===t.toneMapping||(l.material.needsUpdate=!0,c=f,h=f.version,d=t.toneMapping),l.layers.enableAll(),n.unshift(l,l.geometry,l.material,0,0,null)):f&&f.isTexture&&(void 0===o&&(o=new cs(new Rs(2,2),new gs({name:"BackgroundMaterial",uniforms:ps(Fs.background.uniforms),vertexShader:Fs.background.vertexShader,fragmentShader:Fs.background.fragmentShader,side:x,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(o)),o.material.uniforms.t2D.value=f,!0===f.matrixAutoUpdate&&f.updateMatrix(),o.material.uniforms.uvTransform.value.copy(f.matrix),c===f&&h===f.version&&d===t.toneMapping||(o.material.needsUpdate=!0,c=f,h=f.version,d=t.toneMapping),o.layers.enableAll(),n.unshift(o,o.geometry,o.material,0,0,null))}}}function Ps(t,e,n,r){const i=t.getParameter(34921),s=r.isWebGL2?null:e.get("OES_vertex_array_object"),a=r.isWebGL2||null!==s,o={},l=p(null);let u=l,c=!1;function h(e){return r.isWebGL2?t.bindVertexArray(e):s.bindVertexArrayOES(e)}function d(e){return r.isWebGL2?t.deleteVertexArray(e):s.deleteVertexArrayOES(e)}function p(t){const e=[],n=[],r=[];for(let t=0;t<i;t++)e[t]=0,n[t]=0,r[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:r,object:t,attributes:{},index:null}}function f(){const t=u.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function m(t){g(t,0)}function g(n,i){const s=u.newAttributes,a=u.enabledAttributes,o=u.attributeDivisors;s[n]=1,0===a[n]&&(t.enableVertexAttribArray(n),a[n]=1),o[n]!==i&&((r.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,i),o[n]=i)}function x(){const e=u.newAttributes,n=u.enabledAttributes;for(let r=0,i=n.length;r<i;r++)n[r]!==e[r]&&(t.disableVertexAttribArray(r),n[r]=0)}function y(e,n,i,s,a,o){!0!==r.isWebGL2||5124!==i&&5125!==i?t.vertexAttribPointer(e,n,i,s,a,o):t.vertexAttribIPointer(e,n,i,a,o)}function v(){b(),c=!0,u!==l&&(u=l,h(u.object))}function b(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(i,l,d,v,b){let w=!1;if(a){const e=function(e,n,i){const a=!0===i.wireframe;let l=o[e.id];void 0===l&&(l={},o[e.id]=l);let u=l[n.id];void 0===u&&(u={},l[n.id]=u);let c=u[a];return void 0===c&&(c=p(r.isWebGL2?t.createVertexArray():s.createVertexArrayOES()),u[a]=c),c}(v,d,l);u!==e&&(u=e,h(u.object)),w=function(t,e,n,r){const i=u.attributes,s=e.attributes;let a=0;const o=n.getAttributes();for(const e in o)if(o[e].location>=0){const n=i[e];let r=s[e];if(void 0===r&&("instanceMatrix"===e&&t.instanceMatrix&&(r=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(r=t.instanceColor)),void 0===n)return!0;if(n.attribute!==r)return!0;if(r&&n.data!==r.data)return!0;a++}return u.attributesNum!==a||u.index!==r}(i,v,d,b),w&&function(t,e,n,r){const i={},s=e.attributes;let a=0;const o=n.getAttributes();for(const e in o)if(o[e].location>=0){let n=s[e];void 0===n&&("instanceMatrix"===e&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(n=t.instanceColor));const r={};r.attribute=n,n&&n.data&&(r.data=n.data),i[e]=r,a++}u.attributes=i,u.attributesNum=a,u.index=r}(i,v,d,b)}else{const t=!0===l.wireframe;u.geometry===v.id&&u.program===d.id&&u.wireframe===t||(u.geometry=v.id,u.program=d.id,u.wireframe=t,w=!0)}null!==b&&n.update(b,34963),(w||c)&&(c=!1,function(i,s,a,o){if(!1===r.isWebGL2&&(i.isInstancedMesh||o.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;f();const l=o.attributes,u=a.getAttributes(),c=s.defaultAttributeValues;for(const e in u){const r=u[e];if(r.location>=0){let s=l[e];if(void 0===s&&("instanceMatrix"===e&&i.instanceMatrix&&(s=i.instanceMatrix),"instanceColor"===e&&i.instanceColor&&(s=i.instanceColor)),void 0!==s){const e=s.normalized,a=s.itemSize,l=n.get(s);if(void 0===l)continue;const u=l.buffer,c=l.type,h=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,l=n.stride,d=s.offset;if(n.isInstancedInterleavedBuffer){for(let t=0;t<r.locationSize;t++)g(r.location+t,n.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let t=0;t<r.locationSize;t++)m(r.location+t);t.bindBuffer(34962,u);for(let t=0;t<r.locationSize;t++)y(r.location+t,a/r.locationSize,c,e,l*h,(d+a/r.locationSize*t)*h)}else{if(s.isInstancedBufferAttribute){for(let t=0;t<r.locationSize;t++)g(r.location+t,s.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let t=0;t<r.locationSize;t++)m(r.location+t);t.bindBuffer(34962,u);for(let t=0;t<r.locationSize;t++)y(r.location+t,a/r.locationSize,c,e,a*h,a/r.locationSize*t*h)}}else if(void 0!==c){const n=c[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(r.location,n);break;case 3:t.vertexAttrib3fv(r.location,n);break;case 4:t.vertexAttrib4fv(r.location,n);break;default:t.vertexAttrib1fv(r.location,n)}}}}x()}(i,l,d,v),null!==b&&t.bindBuffer(34963,n.get(b).buffer))},reset:v,resetDefaultState:b,dispose:function(){v();for(const t in o){const e=o[t];for(const t in e){const n=e[t];for(const t in n)d(n[t].object),delete n[t];delete e[t]}delete o[t]}},releaseStatesOfGeometry:function(t){if(void 0===o[t.id])return;const e=o[t.id];for(const t in e){const n=e[t];for(const t in n)d(n[t].object),delete n[t];delete e[t]}delete o[t.id]},releaseStatesOfProgram:function(t){for(const e in o){const n=o[e];if(void 0===n[t.id])continue;const r=n[t.id];for(const t in r)d(r[t].object),delete r[t];delete n[t.id]}},initAttributes:f,enableAttribute:m,disableUnusedAttributes:x}}function Os(t,e,n,r){const i=r.isWebGL2;let s;this.setMode=function(t){s=t},this.render=function(e,r){t.drawArrays(s,e,r),n.update(r,s,1)},this.renderInstances=function(r,a,o){if(0===o)return;let l,u;if(i)l=t,u="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),u="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[u](s,r,a,o),n.update(a,s,o)}}function zs(t,e,n){let r;function i(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const o=i(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=s||e.has("WEBGL_draw_buffers"),u=!0===n.logarithmicDepthBuffer,c=t.getParameter(34930),h=t.getParameter(35660),d=t.getParameter(3379),p=t.getParameter(34076),f=t.getParameter(34921),m=t.getParameter(36347),g=t.getParameter(36348),x=t.getParameter(36349),y=h>0,v=s||e.has("OES_texture_float");return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==r)return r;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");r=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:i,precision:a,logarithmicDepthBuffer:u,maxTextures:c,maxVertexTextures:h,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:x,vertexTextures:y,floatFragmentTextures:v,floatVertexTextures:y&&v,maxSamples:s?t.getParameter(36183):0}}function Bs(t){const e=this;let n=null,r=0,i=!1,s=!1;const a=new Ms,o=new Dn,l={value:null,needsUpdate:!1};function u(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function c(t,n,r,i){const s=null!==t?t.length:0;let u=null;if(0!==s){if(u=l.value,!0!==i||null===u){const e=r+4*s,i=n.matrixWorldInverse;o.getNormalMatrix(i),(null===u||u.length<e)&&(u=new Float32Array(e));for(let e=0,n=r;e!==s;++e,n+=4)a.copy(t[e]).applyMatrix4(i,o),a.normal.toArray(u,n),u[n+3]=a.constant}l.value=u,l.needsUpdate=!0}return e.numPlanes=s,e.numIntersection=0,u}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,s){const a=0!==t.length||e||0!==r||i;return i=e,n=c(t,s,0),r=t.length,a},this.beginShadows=function(){s=!0,c(null)},this.endShadows=function(){s=!1,u()},this.setState=function(e,a,o){const h=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(!i||null===h||0===h.length||s&&!p)s?c(null):u();else{const t=s?0:r,e=4*t;let i=f.clippingState||null;l.value=i,i=c(h,a,e,o);for(let t=0;t!==e;++t)i[t]=n[t];f.clippingState=i,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function Us(t){let e=new WeakMap;function n(t,e){return e===ct?t.mapping=lt:e===ht&&(t.mapping=ut),t}function r(t){const n=t.target;n.removeEventListener("dispose",r);const i=e.get(n);void 0!==i&&(e.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture&&!1===i.isRenderTargetTexture){const s=i.mapping;if(s===ct||s===ht){if(e.has(i))return n(e.get(i).texture,i.mapping);{const s=i.image;if(s&&s.height>0){const a=new Ss(s.height/2);return a.fromEquirectangularTexture(t,i),e.set(i,a),i.addEventListener("dispose",r),n(a.texture,i.mapping)}return null}}}return i},dispose:function(){e=new WeakMap}}}Fs.physical={uniforms:fs([Fs.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Rn(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new Xn(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Rn},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Xn(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Xn(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Ds.meshphysical_vert,fragmentShader:Ds.meshphysical_frag};class Ws extends xs{constructor(t=-1,e=1,n=1,r=-1,i=.1,s=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=r,this.near=i,this.far=s,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,r,i,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=n-t,s=n+t,a=r+e,o=r-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=t*this.view.offsetX,s=i+t*this.view.width,a-=e*this.view.offsetY,o=a-e*this.view.height}this.projectionMatrix.makeOrthographic(i,s,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}const Vs=[.125,.215,.35,.446,.526,.582],Gs=20,Hs=new Ws,js=new Xn;let qs=null;const Xs=(1+Math.sqrt(5))/2,Ks=1/Xs,Ys=[new ur(1,1,1),new ur(-1,1,1),new ur(1,1,-1),new ur(-1,1,-1),new ur(0,Xs,Ks),new ur(0,Xs,-Ks),new ur(Ks,0,Xs),new ur(-Ks,0,Xs),new ur(Xs,Ks,0),new ur(-Xs,Ks,0)];class Zs{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,r=100){qs=this._renderer.getRenderTarget(),this._setSize(256);const i=this._allocateTargets();return i.depthBuffer=!0,this._sceneToCubeUV(t,n,r,i),e>0&&this._blur(i,0,0,e),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=ea(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=ta(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(qs),t.scissorTest=!1,Qs(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===lt||t.mapping===ut?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),qs=this._renderer.getRenderTarget();const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:wt,minFilter:wt,generateMipmaps:!1,type:Dt,format:zt,encoding:Fe,depthBuffer:!1},r=Js(t,e,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Js(t,e,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(t){const e=[],n=[],r=[];let i=t;const s=t-4+1+Vs.length;for(let a=0;a<s;a++){const s=Math.pow(2,i);n.push(s);let o=1/s;a>t-4?o=Vs[a-t+4-1]:0===a&&(o=0),r.push(o);const l=1/(s-2),u=-l,c=1+l,h=[u,u,c,u,c,c,u,u,c,c,u,c],d=6,p=6,f=3,m=2,g=1,x=new Float32Array(f*p*d),y=new Float32Array(m*p*d),v=new Float32Array(g*p*d);for(let t=0;t<d;t++){const e=t%3*2/3-1,n=t>2?0:-1,r=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];x.set(r,f*p*t),y.set(h,m*p*t);const i=[t,t,t,t,t,t];v.set(i,g*p*t)}const b=new ji;b.setAttribute("position",new Ci(x,f)),b.setAttribute("uv",new Ci(y,m)),b.setAttribute("faceIndex",new Ci(v,g)),e.push(b),i>4&&i--}return{lodPlanes:e,sizeLods:n,sigmas:r}}(r)),this._blurMaterial=function(t,e,n){const r=new Float32Array(Gs),i=new ur(0,1,0);return new gs({name:"SphericalGaussianBlur",defines:{n:Gs,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:S,depthTest:!1,depthWrite:!1})}(r,t,e)}return r}_compileMaterial(t){const e=new cs(this._lodPlanes[0],t);this._renderer.compile(e,Hs)}_sceneToCubeUV(t,e,n,r){const i=new ys(90,1,e,n),s=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,u=o.toneMapping;o.getClearColor(js),o.toneMapping=et,o.autoClear=!1;const c=new ki({name:"PMREM.Background",side:y,depthWrite:!1,depthTest:!1}),h=new cs(new ds,c);let d=!1;const p=t.background;p?p.isColor&&(c.color.copy(p),t.background=null,d=!0):(c.color.copy(js),d=!0);for(let e=0;e<6;e++){const n=e%3;0===n?(i.up.set(0,s[e],0),i.lookAt(a[e],0,0)):1===n?(i.up.set(0,0,s[e]),i.lookAt(0,a[e],0)):(i.up.set(0,s[e],0),i.lookAt(0,0,a[e]));const l=this._cubeSize;Qs(r,n*l,e>2?l:0,l,l),o.setRenderTarget(r),d&&o.render(h,i),o.render(t,i)}h.geometry.dispose(),h.material.dispose(),o.toneMapping=u,o.autoClear=l,t.background=p}_textureToCubeUV(t,e){const n=this._renderer,r=t.mapping===lt||t.mapping===ut;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=ea()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=ta());const i=r?this._cubemapMaterial:this._equirectMaterial,s=new cs(this._lodPlanes[0],i);i.uniforms.envMap.value=t;const a=this._cubeSize;Qs(e,0,0,3*a,2*a),n.setRenderTarget(e),n.render(s,Hs)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let e=1;e<this._lodPlanes.length;e++){const n=Math.sqrt(this._sigmas[e]*this._sigmas[e]-this._sigmas[e-1]*this._sigmas[e-1]),r=Ys[(e-1)%Ys.length];this._blur(t,e-1,e,n,r)}e.autoClear=n}_blur(t,e,n,r,i){const s=this._pingPongRenderTarget;this._halfBlur(t,s,e,n,r,"latitudinal",i),this._halfBlur(s,t,n,n,r,"longitudinal",i)}_halfBlur(t,e,n,r,i,s,a){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const u=new cs(this._lodPlanes[r],l),c=l.uniforms,h=this._sizeLods[n]-1,d=isFinite(i)?Math.PI/(2*h):2*Math.PI/39,p=i/d,f=isFinite(i)?1+Math.floor(3*p):Gs;f>Gs&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let t=0;t<Gs;++t){const e=t/p,n=Math.exp(-e*e/2);m.push(n),0===t?g+=n:t<f&&(g+=2*n)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;c.envMap.value=t.texture,c.samples.value=f,c.weights.value=m,c.latitudinal.value="latitudinal"===s,a&&(c.poleAxis.value=a);const{_lodMax:x}=this;c.dTheta.value=d,c.mipInt.value=x-n;const y=this._sizeLods[r];Qs(e,3*y*(r>x-4?r-x+4:0),4*(this._cubeSize-y),3*y,2*y),o.setRenderTarget(e),o.render(u,Hs)}}function Js(t,e,n){const r=new nr(t,e,n);return r.texture.mapping=dt,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function Qs(t,e,n,r,i){t.viewport.set(e,n,r,i),t.scissor.set(e,n,r,i)}function ta(){return new gs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:S,depthTest:!1,depthWrite:!1})}function ea(){return new gs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:S,depthTest:!1,depthWrite:!1})}function na(t){let e=new WeakMap,n=null;function r(t){const n=t.target;n.removeEventListener("dispose",r);const i=e.get(n);void 0!==i&&(e.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const s=i.mapping,a=s===ct||s===ht,o=s===lt||s===ut;if(a||o){if(i.isRenderTargetTexture&&!0===i.needsPMREMUpdate){i.needsPMREMUpdate=!1;let r=e.get(i);return null===n&&(n=new Zs(t)),r=a?n.fromEquirectangular(i,r):n.fromCubemap(i,r),e.set(i,r),r.texture}if(e.has(i))return e.get(i).texture;{const s=i.image;if(a&&s&&s.height>0||o&&s&&function(t){let e=0;for(let n=0;n<6;n++)void 0!==t[n]&&e++;return 6===e}(s)){null===n&&(n=new Zs(t));const s=a?n.fromEquirectangular(i):n.fromCubemap(i);return e.set(i,s),i.addEventListener("dispose",r),s.texture}return null}}}return i},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function ra(t){const e={};function n(n){if(void 0!==e[n])return e[n];let r;switch(n){case"WEBGL_depth_texture":r=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=t.getExtension(n)}return e[n]=r,r}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function ia(t,e,n,r){const i={},s=new WeakMap;function a(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const t in o.attributes)e.remove(o.attributes[t]);o.removeEventListener("dispose",a),delete i[o.id];const l=s.get(o);l&&(e.remove(l),s.delete(o)),r.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(t){const n=[],r=t.index,i=t.attributes.position;let a=0;if(null!==r){const t=r.array;a=r.version;for(let e=0,r=t.length;e<r;e+=3){const r=t[e+0],i=t[e+1],s=t[e+2];n.push(r,i,i,s,s,r)}}else{const t=i.array;a=i.version;for(let e=0,r=t.length/3-1;e<r;e+=3){const t=e+0,r=e+1,i=e+2;n.push(t,r,r,i,i,t)}}const o=new(Ln(n)?Fi:Di)(n,1);o.version=a;const l=s.get(t);l&&e.remove(l),s.set(t,o)}return{get:function(t,e){return!0===i[e.id]||(e.addEventListener("dispose",a),i[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const t in n)e.update(n[t],34962);const r=t.morphAttributes;for(const t in r){const n=r[t];for(let t=0,r=n.length;t<r;t++)e.update(n[t],34962)}},getWireframeAttribute:function(t){const e=s.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&o(t)}else o(t);return s.get(t)}}}function sa(t,e,n,r){const i=r.isWebGL2;let s,a,o;this.setMode=function(t){s=t},this.setIndex=function(t){a=t.type,o=t.bytesPerElement},this.render=function(e,r){t.drawElements(s,r,a,e*o),n.update(r,s,1)},this.renderInstances=function(r,l,u){if(0===u)return;let c,h;if(i)c=t,h="drawElementsInstanced";else if(c=e.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===c)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[h](s,l,a,r*o,u),n.update(l,s,u)}}function aa(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,r){switch(e.calls++,n){case 4:e.triangles+=r*(t/3);break;case 1:e.lines+=r*(t/2);break;case 3:e.lines+=r*(t-1);break;case 2:e.lines+=r*t;break;case 0:e.points+=r*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function oa(t,e){return t[0]-e[0]}function la(t,e){return Math.abs(e[1])-Math.abs(t[1])}function ua(t,e){let n=1;const r=e.isInterleavedBufferAttribute?e.data.array:e.array;r instanceof Int8Array?n=127:r instanceof Uint8Array?n=255:r instanceof Uint16Array?n=65535:r instanceof Int16Array?n=32767:r instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",r),t.divideScalar(n)}function ca(t,e,n){const r={},i=new Float32Array(8),s=new WeakMap,a=new er,o=[];for(let t=0;t<8;t++)o[t]=[t,0];return{update:function(l,u,c,h){const d=l.morphTargetInfluences;if(!0===e.isWebGL2){const p=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,f=void 0!==p?p.length:0;let m=s.get(u);if(void 0===m||m.count!==f){void 0!==m&&m.texture.dispose();const y=void 0!==u.morphAttributes.position,v=void 0!==u.morphAttributes.normal,b=void 0!==u.morphAttributes.color,w=u.morphAttributes.position||[],S=u.morphAttributes.normal||[],_=u.morphAttributes.color||[];let I=0;!0===y&&(I=1),!0===v&&(I=2),!0===b&&(I=3);let k=u.attributes.position.count*I,M=1;k>e.maxTextureSize&&(M=Math.ceil(k/e.maxTextureSize),k=e.maxTextureSize);const T=new Float32Array(k*M*4*f),C=new rr(T,k,M,f);C.type=Rt,C.needsUpdate=!0;const E=4*I;for(let N=0;N<f;N++){const R=w[N],D=S[N],L=_[N],F=k*M*4*N;for(let $=0;$<R.count;$++){const P=$*E;!0===y&&(a.fromBufferAttribute(R,$),!0===R.normalized&&ua(a,R),T[F+P+0]=a.x,T[F+P+1]=a.y,T[F+P+2]=a.z,T[F+P+3]=0),!0===v&&(a.fromBufferAttribute(D,$),!0===D.normalized&&ua(a,D),T[F+P+4]=a.x,T[F+P+5]=a.y,T[F+P+6]=a.z,T[F+P+7]=0),!0===b&&(a.fromBufferAttribute(L,$),!0===L.normalized&&ua(a,L),T[F+P+8]=a.x,T[F+P+9]=a.y,T[F+P+10]=a.z,T[F+P+11]=4===L.itemSize?a.w:1)}}function A(){C.dispose(),s.delete(u),u.removeEventListener("dispose",A)}m={count:f,texture:C,size:new Rn(k,M)},s.set(u,m),u.addEventListener("dispose",A)}let g=0;for(let O=0;O<d.length;O++)g+=d[O];const x=u.morphTargetsRelative?1:1-g;h.getUniforms().setValue(t,"morphTargetBaseInfluence",x),h.getUniforms().setValue(t,"morphTargetInfluences",d),h.getUniforms().setValue(t,"morphTargetsTexture",m.texture,n),h.getUniforms().setValue(t,"morphTargetsTextureSize",m.size)}else{const z=void 0===d?0:d.length;let B=r[u.id];if(void 0===B||B.length!==z){B=[];for(let H=0;H<z;H++)B[H]=[H,0];r[u.id]=B}for(let j=0;j<z;j++){const q=B[j];q[0]=j,q[1]=d[j]}B.sort(la);for(let X=0;X<8;X++)X<z&&B[X][1]?(o[X][0]=B[X][0],o[X][1]=B[X][1]):(o[X][0]=Number.MAX_SAFE_INTEGER,o[X][1]=0);o.sort(oa);const U=u.morphAttributes.position,W=u.morphAttributes.normal;let V=0;for(let K=0;K<8;K++){const Y=o[K],Z=Y[0],J=Y[1];Z!==Number.MAX_SAFE_INTEGER&&J?(U&&u.getAttribute("morphTarget"+K)!==U[Z]&&u.setAttribute("morphTarget"+K,U[Z]),W&&u.getAttribute("morphNormal"+K)!==W[Z]&&u.setAttribute("morphNormal"+K,W[Z]),i[K]=J,V+=J):(U&&!0===u.hasAttribute("morphTarget"+K)&&u.deleteAttribute("morphTarget"+K),W&&!0===u.hasAttribute("morphNormal"+K)&&u.deleteAttribute("morphNormal"+K),i[K]=0)}const G=u.morphTargetsRelative?1:1-V;h.getUniforms().setValue(t,"morphTargetBaseInfluence",G),h.getUniforms().setValue(t,"morphTargetInfluences",i)}}}}function ha(t,e,n,r){let i=new WeakMap;function s(t){const e=t.target;e.removeEventListener("dispose",s),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const a=r.render.frame,o=t.geometry,l=e.get(t,o);return i.get(l)!==a&&(e.update(l),i.set(l,a)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",s)&&t.addEventListener("dispose",s),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),l},dispose:function(){i=new WeakMap}}}const da=new tr,pa=new rr,fa=new sr,ma=new ws,ga=[],xa=[],ya=new Float32Array(16),va=new Float32Array(9),ba=new Float32Array(4);function wa(t,e,n){const r=t[0];if(r<=0||r>0)return t;const i=e*n;let s=ga[i];if(void 0===s&&(s=new Float32Array(i),ga[i]=s),0!==e){r.toArray(s,0);for(let r=1,i=0;r!==e;++r)i+=n,t[r].toArray(s,i)}return s}function Sa(t,e){if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}function _a(t,e){for(let n=0,r=e.length;n<r;n++)t[n]=e[n]}function Ia(t,e){let n=xa[e];void 0===n&&(n=new Int32Array(e),xa[e]=n);for(let r=0;r!==e;++r)n[r]=t.allocateTextureUnit();return n}function ka(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function Ma(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Sa(n,e))return;t.uniform2fv(this.addr,e),_a(n,e)}}function Ta(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(Sa(n,e))return;t.uniform3fv(this.addr,e),_a(n,e)}}function Ca(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Sa(n,e))return;t.uniform4fv(this.addr,e),_a(n,e)}}function Ea(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(Sa(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),_a(n,e)}else{if(Sa(n,r))return;ba.set(r),t.uniformMatrix2fv(this.addr,!1,ba),_a(n,r)}}function Aa(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(Sa(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),_a(n,e)}else{if(Sa(n,r))return;va.set(r),t.uniformMatrix3fv(this.addr,!1,va),_a(n,r)}}function Na(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(Sa(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),_a(n,e)}else{if(Sa(n,r))return;ya.set(r),t.uniformMatrix4fv(this.addr,!1,ya),_a(n,r)}}function Ra(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function Da(t,e){const n=this.cache;Sa(n,e)||(t.uniform2iv(this.addr,e),_a(n,e))}function La(t,e){const n=this.cache;Sa(n,e)||(t.uniform3iv(this.addr,e),_a(n,e))}function Fa(t,e){const n=this.cache;Sa(n,e)||(t.uniform4iv(this.addr,e),_a(n,e))}function $a(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function Pa(t,e){const n=this.cache;Sa(n,e)||(t.uniform2uiv(this.addr,e),_a(n,e))}function Oa(t,e){const n=this.cache;Sa(n,e)||(t.uniform3uiv(this.addr,e),_a(n,e))}function za(t,e){const n=this.cache;Sa(n,e)||(t.uniform4uiv(this.addr,e),_a(n,e))}function Ba(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture2D(e||da,i)}function Ua(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(e||fa,i)}function Wa(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTextureCube(e||ma,i)}function Va(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(e||pa,i)}function Ga(t,e){t.uniform1fv(this.addr,e)}function Ha(t,e){const n=wa(e,this.size,2);t.uniform2fv(this.addr,n)}function ja(t,e){const n=wa(e,this.size,3);t.uniform3fv(this.addr,n)}function qa(t,e){const n=wa(e,this.size,4);t.uniform4fv(this.addr,n)}function Xa(t,e){const n=wa(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function Ka(t,e){const n=wa(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function Ya(t,e){const n=wa(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function Za(t,e){t.uniform1iv(this.addr,e)}function Ja(t,e){t.uniform2iv(this.addr,e)}function Qa(t,e){t.uniform3iv(this.addr,e)}function to(t,e){t.uniform4iv(this.addr,e)}function eo(t,e){t.uniform1uiv(this.addr,e)}function no(t,e){t.uniform2uiv(this.addr,e)}function ro(t,e){t.uniform3uiv(this.addr,e)}function io(t,e){t.uniform4uiv(this.addr,e)}function so(t,e,n){const r=e.length,i=Ia(n,r);t.uniform1iv(this.addr,i);for(let t=0;t!==r;++t)n.setTexture2D(e[t]||da,i[t])}function ao(t,e,n){const r=e.length,i=Ia(n,r);t.uniform1iv(this.addr,i);for(let t=0;t!==r;++t)n.setTexture3D(e[t]||fa,i[t])}function oo(t,e,n){const r=e.length,i=Ia(n,r);t.uniform1iv(this.addr,i);for(let t=0;t!==r;++t)n.setTextureCube(e[t]||ma,i[t])}function lo(t,e,n){const r=e.length,i=Ia(n,r);t.uniform1iv(this.addr,i);for(let t=0;t!==r;++t)n.setTexture2DArray(e[t]||pa,i[t])}class uo{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return ka;case 35664:return Ma;case 35665:return Ta;case 35666:return Ca;case 35674:return Ea;case 35675:return Aa;case 35676:return Na;case 5124:case 35670:return Ra;case 35667:case 35671:return Da;case 35668:case 35672:return La;case 35669:case 35673:return Fa;case 5125:return $a;case 36294:return Pa;case 36295:return Oa;case 36296:return za;case 35678:case 36198:case 36298:case 36306:case 35682:return Ba;case 35679:case 36299:case 36307:return Ua;case 35680:case 36300:case 36308:case 36293:return Wa;case 36289:case 36303:case 36311:case 36292:return Va}}(e.type)}}class co{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return Ga;case 35664:return Ha;case 35665:return ja;case 35666:return qa;case 35674:return Xa;case 35675:return Ka;case 35676:return Ya;case 5124:case 35670:return Za;case 35667:case 35671:return Ja;case 35668:case 35672:return Qa;case 35669:case 35673:return to;case 5125:return eo;case 36294:return no;case 36295:return ro;case 36296:return io;case 35678:case 36198:case 36298:case 36306:case 35682:return so;case 35679:case 36299:case 36307:return ao;case 35680:case 36300:case 36308:case 36293:return oo;case 36289:case 36303:case 36311:case 36292:return lo}}(e.type)}}class ho{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const r=this.seq;for(let i=0,s=r.length;i!==s;++i){const s=r[i];s.setValue(t,e[s.id],n)}}}const po=/(\w+)(\])?(\[|\.)?/g;function fo(t,e){t.seq.push(e),t.map[e.id]=e}function mo(t,e,n){const r=t.name,i=r.length;for(po.lastIndex=0;;){const s=po.exec(r),a=po.lastIndex;let o=s[1];const l="]"===s[2],u=s[3];if(l&&(o|=0),void 0===u||"["===u&&a+2===i){fo(n,void 0===u?new uo(o,t,e):new co(o,t,e));break}{let t=n.map[o];void 0===t&&(t=new ho(o),fo(n,t)),n=t}}}class go{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let r=0;r<n;++r){const n=t.getActiveUniform(e,r);mo(n,t.getUniformLocation(e,n.name),this)}}setValue(t,e,n,r){const i=this.map[e];void 0!==i&&i.setValue(t,n,r)}setOptional(t,e,n){const r=e[n];void 0!==r&&this.setValue(t,n,r)}static upload(t,e,n,r){for(let i=0,s=e.length;i!==s;++i){const s=e[i],a=n[s.id];!1!==a.needsUpdate&&s.setValue(t,a.value,r)}}static seqWithValue(t,e){const n=[];for(let r=0,i=t.length;r!==i;++r){const i=t[r];i.id in e&&n.push(i)}return n}}function xo(t,e,n){const r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),r}let yo=0;function vo(t,e,n){const r=t.getShaderParameter(e,35713),i=t.getShaderInfoLog(e).trim();if(r&&""===i)return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const r=parseInt(s[1]);return n.toUpperCase()+"\n\n"+i+"\n\n"+function(t,e){const n=t.split("\n"),r=[],i=Math.max(e-6,0),s=Math.min(e+6,n.length);for(let t=i;t<s;t++){const i=t+1;r.push(`${i===e?">":" "} ${i}: ${n[t]}`)}return r.join("\n")}(t.getShaderSource(e),r)}return i}function bo(t,e){const n=function(t){switch(t){case Fe:return["Linear","( value )"];case $e:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function wo(t,e){let n;switch(e){case nt:n="Linear";break;case rt:n="Reinhard";break;case it:n="OptimizedCineon";break;case st:n="ACESFilmic";break;case at:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function So(t){return""!==t}function _o(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Io(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const ko=/^[ \t]*#include +<([\w\d./]+)>/gm;function Mo(t){return t.replace(ko,To)}function To(t,e){const n=Ds[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return Mo(n)}const Co=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Eo=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Ao(t){return t.replace(Eo,Ro).replace(Co,No)}function No(t,e,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Ro(0,e,n,r)}function Ro(t,e,n,r){let i="";for(let t=parseInt(e);t<parseInt(n);t++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return i}function Do(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Lo(t,e,n,r){const i=t.getContext(),s=n.defines;let a=n.vertexShader,o=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===f?e="SHADOWMAP_TYPE_PCF":t.shadowMapType===m?e="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===g&&(e="SHADOWMAP_TYPE_VSM"),e}(n),u=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case lt:case ut:e="ENVMAP_TYPE_CUBE";break;case dt:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),c=function(t){let e="ENVMAP_MODE_REFLECTION";return t.envMap&&t.envMapMode===ut&&(e="ENVMAP_MODE_REFRACTION"),e}(n),h=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case J:e="ENVMAP_BLENDING_MULTIPLY";break;case Q:e="ENVMAP_BLENDING_MIX";break;case tt:e="ENVMAP_BLENDING_ADD"}return e}(n),d=function(t){const e=t.envMapCubeUVHeight;if(null===e)return null;const n=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:r,maxMip:n}}(n),p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUVHeight||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(So).join("\n")}(n),x=function(t){const e=[];for(const n in t){const r=t[n];!1!==r&&e.push("#define "+n+" "+r)}return e.join("\n")}(s),y=i.createProgram();let v,b,w=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(v=[x].filter(So).join("\n"),v.length>0&&(v+="\n"),b=[p,x].filter(So).join("\n"),b.length>0&&(b+="\n")):(v=[Do(n),"#define SHADER_NAME "+n.shaderName,x,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors&&n.isWebGL2?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(So).join("\n"),b=[p,Do(n),"#define SHADER_NAME "+n.shaderName,x,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.envMap?"#define "+c:"",n.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==et?"#define TONE_MAPPING":"",n.toneMapping!==et?Ds.tonemapping_pars_fragment:"",n.toneMapping!==et?wo("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Ds.encodings_pars_fragment,bo("linearToOutputTexel",n.outputEncoding),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(So).join("\n")),a=Mo(a),a=_o(a,n),a=Io(a,n),o=Mo(o),o=_o(o,n),o=Io(o,n),a=Ao(a),o=Ao(o),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(w="#version 300 es\n",v=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+v,b=["#define varying in",n.glslVersion===xn?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===xn?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+b);const S=w+b+o,_=xo(i,35633,w+v+a),I=xo(i,35632,S);if(i.attachShader(y,_),i.attachShader(y,I),void 0!==n.index0AttributeName?i.bindAttribLocation(y,0,n.index0AttributeName):!0===n.morphTargets&&i.bindAttribLocation(y,0,"position"),i.linkProgram(y),t.debug.checkShaderErrors){const t=i.getProgramInfoLog(y).trim(),e=i.getShaderInfoLog(_).trim(),n=i.getShaderInfoLog(I).trim();let r=!0,s=!0;if(!1===i.getProgramParameter(y,35714)){r=!1;const e=vo(i,_,"vertex"),n=vo(i,I,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(y,35715)+"\n\nProgram Info Log: "+t+"\n"+e+"\n"+n)}else""!==t?console.warn("THREE.WebGLProgram: Program Info Log:",t):""!==e&&""!==n||(s=!1);s&&(this.diagnostics={runnable:r,programLog:t,vertexShader:{log:e,prefix:v},fragmentShader:{log:n,prefix:b}})}let k,M;return i.deleteShader(_),i.deleteShader(I),this.getUniforms=function(){return void 0===k&&(k=new go(i,y)),k},this.getAttributes=function(){return void 0===M&&(M=function(t,e){const n={},r=t.getProgramParameter(e,35721);for(let i=0;i<r;i++){const r=t.getActiveAttrib(e,i),s=r.name;let a=1;35674===r.type&&(a=2),35675===r.type&&(a=3),35676===r.type&&(a=4),n[s]={type:r.type,location:t.getAttribLocation(e,s),locationSize:a}}return n}(i,y)),M},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(y),this.program=void 0},this.name=n.shaderName,this.id=yo++,this.cacheKey=e,this.usedTimes=1,this.program=y,this.vertexShader=_,this.fragmentShader=I,this}let Fo=0;class $o{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,r=this._getShaderStage(e),i=this._getShaderStage(n),s=this._getShaderCacheForMaterial(t);return!1===s.has(r)&&(s.add(r),r.usedTimes++),!1===s.has(i)&&(s.add(i),i.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const t of e)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;return!1===e.has(t)&&e.set(t,new Set),e.get(t)}_getShaderStage(t){const e=this.shaderCache;if(!1===e.has(t)){const n=new Po(t);e.set(t,n)}return e.get(t)}}class Po{constructor(t){this.id=Fo++,this.code=t,this.usedTimes=0}}function Oo(t,e,n,r,i,s,a){const o=new Zr,l=new $o,u=[],c=i.isWebGL2,h=i.logarithmicDepthBuffer,d=i.vertexTextures;let p=i.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(s,o,u,m,g){const x=m.fog,b=g.geometry,w=s.isMeshStandardMaterial?m.environment:null,S=(s.isMeshStandardMaterial?n:e).get(s.envMap||w),I=S&&S.mapping===dt?S.image.height:null,k=f[s.type];null!==s.precision&&(p=i.getMaxPrecision(s.precision),p!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",p,"instead."));const M=b.morphAttributes.position||b.morphAttributes.normal||b.morphAttributes.color,T=void 0!==M?M.length:0;let C,E,A,N,R=0;if(void 0!==b.morphAttributes.position&&(R=1),void 0!==b.morphAttributes.normal&&(R=2),void 0!==b.morphAttributes.color&&(R=3),k){const t=Fs[k];C=t.vertexShader,E=t.fragmentShader}else C=s.vertexShader,E=s.fragmentShader,l.update(s),A=l.getVertexShaderID(s),N=l.getFragmentShaderID(s);const D=t.getRenderTarget(),L=s.alphaTest>0,F=s.clearcoat>0,$=s.iridescence>0;return{isWebGL2:c,shaderID:k,shaderName:s.type,vertexShader:C,fragmentShader:E,defines:s.defines,customVertexShaderID:A,customFragmentShaderID:N,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:p,instancing:!0===g.isInstancedMesh,instancingColor:!0===g.isInstancedMesh&&null!==g.instanceColor,supportsVertexTextures:d,outputEncoding:null===D?t.outputEncoding:!0===D.isXRRenderTarget?D.texture.encoding:Fe,map:!!s.map,matcap:!!s.matcap,envMap:!!S,envMapMode:S&&S.mapping,envMapCubeUVHeight:I,lightMap:!!s.lightMap,aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:s.normalMapType===Be,tangentSpaceNormalMap:s.normalMapType===ze,decodeVideoTexture:!!s.map&&!0===s.map.isVideoTexture&&s.map.encoding===$e,clearcoat:F,clearcoatMap:F&&!!s.clearcoatMap,clearcoatRoughnessMap:F&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:F&&!!s.clearcoatNormalMap,iridescence:$,iridescenceMap:$&&!!s.iridescenceMap,iridescenceThicknessMap:$&&!!s.iridescenceThicknessMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularColorMap:!!s.specularColorMap,opaque:!1===s.transparent&&s.blending===_,alphaMap:!!s.alphaMap,alphaTest:L,gradientMap:!!s.gradientMap,sheen:s.sheen>0,sheenColorMap:!!s.sheenColorMap,sheenRoughnessMap:!!s.sheenRoughnessMap,transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!b.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!b.attributes.color&&4===b.attributes.color.itemSize,vertexUvs:!!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatMap||s.clearcoatRoughnessMap||s.clearcoatNormalMap||s.iridescenceMap||s.iridescenceThicknessMap||s.displacementMap||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheenColorMap||s.sheenRoughnessMap),uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.iridescenceMap||s.iridescenceThicknessMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheen>0||s.sheenColorMap||s.sheenRoughnessMap||!s.displacementMap),fog:!!x,useFog:!0===s.fog,fogExp2:x&&x.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:h,skinning:!0===g.isSkinnedMesh,morphTargets:void 0!==b.morphAttributes.position,morphNormals:void 0!==b.morphAttributes.normal,morphColors:void 0!==b.morphAttributes.color,morphTargetsCount:T,morphTextureStride:R,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:s.dithering,shadowMapEnabled:t.shadowMap.enabled&&u.length>0,shadowMapType:t.shadowMap.type,toneMapping:s.toneMapped?t.toneMapping:et,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:s.side===v,flipSided:s.side===y,useDepthPacking:!!s.depthPacking,depthPacking:s.depthPacking||0,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:c||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||r.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.customVertexShaderID),n.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(function(t,e){t.push(e.precision),t.push(e.outputEncoding),t.push(e.envMapMode),t.push(e.envMapCubeUVHeight),t.push(e.combine),t.push(e.vertexUvs),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.morphTargetsCount),t.push(e.morphAttributeCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.depthPacking)}(n,e),function(t,e){o.disableAll(),e.isWebGL2&&o.enable(0),e.supportsVertexTextures&&o.enable(1),e.instancing&&o.enable(2),e.instancingColor&&o.enable(3),e.map&&o.enable(4),e.matcap&&o.enable(5),e.envMap&&o.enable(6),e.lightMap&&o.enable(7),e.aoMap&&o.enable(8),e.emissiveMap&&o.enable(9),e.bumpMap&&o.enable(10),e.normalMap&&o.enable(11),e.objectSpaceNormalMap&&o.enable(12),e.tangentSpaceNormalMap&&o.enable(13),e.clearcoat&&o.enable(14),e.clearcoatMap&&o.enable(15),e.clearcoatRoughnessMap&&o.enable(16),e.clearcoatNormalMap&&o.enable(17),e.iridescence&&o.enable(18),e.iridescenceMap&&o.enable(19),e.iridescenceThicknessMap&&o.enable(20),e.displacementMap&&o.enable(21),e.specularMap&&o.enable(22),e.roughnessMap&&o.enable(23),e.metalnessMap&&o.enable(24),e.gradientMap&&o.enable(25),e.alphaMap&&o.enable(26),e.alphaTest&&o.enable(27),e.vertexColors&&o.enable(28),e.vertexAlphas&&o.enable(29),e.vertexUvs&&o.enable(30),e.vertexTangents&&o.enable(31),e.uvsVertexOnly&&o.enable(32),e.fog&&o.enable(33),t.push(o.mask),o.disableAll(),e.useFog&&o.enable(0),e.flatShading&&o.enable(1),e.logarithmicDepthBuffer&&o.enable(2),e.skinning&&o.enable(3),e.morphTargets&&o.enable(4),e.morphNormals&&o.enable(5),e.morphColors&&o.enable(6),e.premultipliedAlpha&&o.enable(7),e.shadowMapEnabled&&o.enable(8),e.physicallyCorrectLights&&o.enable(9),e.doubleSided&&o.enable(10),e.flipSided&&o.enable(11),e.useDepthPacking&&o.enable(12),e.dithering&&o.enable(13),e.specularIntensityMap&&o.enable(14),e.specularColorMap&&o.enable(15),e.transmission&&o.enable(16),e.transmissionMap&&o.enable(17),e.thicknessMap&&o.enable(18),e.sheen&&o.enable(19),e.sheenColorMap&&o.enable(20),e.sheenRoughnessMap&&o.enable(21),e.decodeVideoTexture&&o.enable(22),e.opaque&&o.enable(23),t.push(o.mask)}(n,e),n.push(t.outputEncoding)),n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=f[t.type];let n;if(e){const t=Fs[e];n=ms.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let r;for(let t=0,e=u.length;t<e;t++){const e=u[t];if(e.cacheKey===n){r=e,++r.usedTimes;break}}return void 0===r&&(r=new Lo(t,n,e,s),u.push(r)),r},releaseProgram:function(t){if(0==--t.usedTimes){const e=u.indexOf(t);u[e]=u[u.length-1],u.pop(),t.destroy()}},releaseShaderCache:function(t){l.remove(t)},programs:u,dispose:function(){l.dispose()}}}function zo(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,r){t.get(e)[n]=r},dispose:function(){t=new WeakMap}}}function Bo(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Uo(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Wo(){const t=[];let e=0;const n=[],r=[],i=[];function s(n,r,i,s,a,o){let l=t[e];return void 0===l?(l={id:n.id,object:n,geometry:r,material:i,groupOrder:s,renderOrder:n.renderOrder,z:a,group:o},t[e]=l):(l.id=n.id,l.object=n,l.geometry=r,l.material=i,l.groupOrder=s,l.renderOrder=n.renderOrder,l.z=a,l.group=o),e++,l}return{opaque:n,transmissive:r,transparent:i,init:function(){e=0,n.length=0,r.length=0,i.length=0},push:function(t,e,a,o,l,u){const c=s(t,e,a,o,l,u);a.transmission>0?r.push(c):!0===a.transparent?i.push(c):n.push(c)},unshift:function(t,e,a,o,l,u){const c=s(t,e,a,o,l,u);a.transmission>0?r.unshift(c):!0===a.transparent?i.unshift(c):n.unshift(c)},finish:function(){for(let n=e,r=t.length;n<r;n++){const e=t[n];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){n.length>1&&n.sort(t||Bo),r.length>1&&r.sort(e||Uo),i.length>1&&i.sort(e||Uo)}}}function Vo(){let t=new WeakMap;return{get:function(e,n){let r;return!1===t.has(e)?(r=new Wo,t.set(e,[r])):n>=t.get(e).length?(r=new Wo,t.get(e).push(r)):r=t.get(e)[n],r},dispose:function(){t=new WeakMap}}}function Go(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new ur,color:new Xn};break;case"SpotLight":n={position:new ur,direction:new ur,color:new Xn,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new ur,color:new Xn,distance:0,decay:0};break;case"HemisphereLight":n={direction:new ur,skyColor:new Xn,groundColor:new Xn};break;case"RectAreaLight":n={color:new Xn,position:new ur,halfWidth:new ur,halfHeight:new ur}}return t[e.id]=n,n}}}let Ho=0;function jo(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function qo(t,e){const n=new Go,r=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Rn};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Rn,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let t=0;t<9;t++)i.probe.push(new ur);const s=new ur,a=new Br,o=new Br;return{setup:function(s,a){let o=0,l=0,u=0;for(let t=0;t<9;t++)i.probe[t].set(0,0,0);let c=0,h=0,d=0,p=0,f=0,m=0,g=0,x=0;s.sort(jo);const y=!0!==a?Math.PI:1;for(let t=0,e=s.length;t<e;t++){const e=s[t],a=e.color,v=e.intensity,b=e.distance,w=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=a.r*v*y,l+=a.g*v*y,u+=a.b*v*y;else if(e.isLightProbe)for(let t=0;t<9;t++)i.probe[t].addScaledVector(e.sh.coefficients[t],v);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*y),e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,i.directionalShadow[c]=n,i.directionalShadowMap[c]=w,i.directionalShadowMatrix[c]=e.shadow.matrix,m++}i.directional[c]=t,c++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(a).multiplyScalar(v*y),t.distance=b,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,i.spotShadow[d]=n,i.spotShadowMap[d]=w,i.spotShadowMatrix[d]=e.shadow.matrix,x++}i.spot[d]=t,d++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(a).multiplyScalar(v),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),i.rectArea[p]=t,p++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*y),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,i.pointShadow[h]=n,i.pointShadowMap[h]=w,i.pointShadowMatrix[h]=e.shadow.matrix,g++}i.point[h]=t,h++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(v*y),t.groundColor.copy(e.groundColor).multiplyScalar(v*y),i.hemi[f]=t,f++}}p>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(i.rectAreaLTC1=Ls.LTC_FLOAT_1,i.rectAreaLTC2=Ls.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(i.rectAreaLTC1=Ls.LTC_HALF_1,i.rectAreaLTC2=Ls.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=o,i.ambient[1]=l,i.ambient[2]=u;const v=i.hash;v.directionalLength===c&&v.pointLength===h&&v.spotLength===d&&v.rectAreaLength===p&&v.hemiLength===f&&v.numDirectionalShadows===m&&v.numPointShadows===g&&v.numSpotShadows===x||(i.directional.length=c,i.spot.length=d,i.rectArea.length=p,i.point.length=h,i.hemi.length=f,i.directionalShadow.length=m,i.directionalShadowMap.length=m,i.pointShadow.length=g,i.pointShadowMap.length=g,i.spotShadow.length=x,i.spotShadowMap.length=x,i.directionalShadowMatrix.length=m,i.pointShadowMatrix.length=g,i.spotShadowMatrix.length=x,v.directionalLength=c,v.pointLength=h,v.spotLength=d,v.rectAreaLength=p,v.hemiLength=f,v.numDirectionalShadows=m,v.numPointShadows=g,v.numSpotShadows=x,i.version=Ho++)},setupView:function(t,e){let n=0,r=0,l=0,u=0,c=0;const h=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=i.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),n++}else if(d.isSpotLight){const t=i.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(h),l++}else if(d.isRectAreaLight){const t=i.rectArea[u];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),o.identity(),a.copy(d.matrixWorld),a.premultiply(h),o.extractRotation(a),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(o),t.halfHeight.applyMatrix4(o),u++}else if(d.isPointLight){const t=i.point[r];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),r++}else if(d.isHemisphereLight){const t=i.hemi[c];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(h),c++}}},state:i}}function Xo(t,e){const n=new qo(t,e),r=[],i=[];return{init:function(){r.length=0,i.length=0},state:{lightsArray:r,shadowsArray:i,lights:n},setupLights:function(t){n.setup(r,t)},setupLightsView:function(t){n.setupView(r,t)},pushLight:function(t){r.push(t)},pushShadow:function(t){i.push(t)}}}function Ko(t,e){let n=new WeakMap;return{get:function(r,i=0){let s;return!1===n.has(r)?(s=new Xo(t,e),n.set(r,[s])):i>=n.get(r).length?(s=new Xo(t,e),n.get(r).push(s)):s=n.get(r)[i],s},dispose:function(){n=new WeakMap}}}class Yo extends Ii{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=Pe,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class Zo extends Ii{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new ur,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}const Jo="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",Qo="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function tl(t,e,n){let r=new Es;const i=new Rn,s=new Rn,a=new er,o=new Yo({depthPacking:Oe}),l=new Zo,u={},c=n.maxTextureSize,h={0:y,1:x,2:v},d=new gs({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Rn},radius:{value:4}},vertexShader:Jo,fragmentShader:Qo}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const m=new ji;m.setAttribute("position",new Ci(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const b=new cs(m,d),w=this;function _(n,r){const s=e.update(b);d.defines.VSM_SAMPLES!==n.blurSamples&&(d.defines.VSM_SAMPLES=n.blurSamples,p.defines.VSM_SAMPLES=n.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),null===n.mapPass&&(n.mapPass=new nr(i.x,i.y)),d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(r,null,s,d,b,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(r,null,s,p,b,null)}function I(e,n,r,i,s,a){let c=null;const d=!0===r.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(c=void 0!==d?d:!0===r.isPointLight?l:o,t.localClippingEnabled&&!0===n.clipShadows&&Array.isArray(n.clippingPlanes)&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0){const t=c.uuid,e=n.uuid;let r=u[t];void 0===r&&(r={},u[t]=r);let i=r[e];void 0===i&&(i=c.clone(),r[e]=i),c=i}return c.visible=n.visible,c.wireframe=n.wireframe,c.side=a===g?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:h[n.side],c.alphaMap=n.alphaMap,c.alphaTest=n.alphaTest,c.clipShadows=n.clipShadows,c.clippingPlanes=n.clippingPlanes,c.clipIntersection=n.clipIntersection,c.displacementMap=n.displacementMap,c.displacementScale=n.displacementScale,c.displacementBias=n.displacementBias,c.wireframeLinewidth=n.wireframeLinewidth,c.linewidth=n.linewidth,!0===r.isPointLight&&!0===c.isMeshDistanceMaterial&&(c.referencePosition.setFromMatrixPosition(r.matrixWorld),c.nearDistance=i,c.farDistance=s),c}function k(n,i,s,a,o){if(!1===n.visible)return;if(n.layers.test(i.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&o===g)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const r=e.update(n),i=n.material;if(Array.isArray(i)){const e=r.groups;for(let l=0,u=e.length;l<u;l++){const u=e[l],c=i[u.materialIndex];if(c&&c.visible){const e=I(n,c,a,s.near,s.far,o);t.renderBufferDirect(s,null,r,e,n,u)}}}else if(i.visible){const e=I(n,i,a,s.near,s.far,o);t.renderBufferDirect(s,null,r,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)k(l[t],i,s,a,o)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=f,this.render=function(e,n,o){if(!1===w.enabled)return;if(!1===w.autoUpdate&&!1===w.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),u=t.getActiveCubeFace(),h=t.getActiveMipmapLevel(),d=t.state;d.setBlending(S),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let l=0,u=e.length;l<u;l++){const u=e[l],h=u.shadow;if(void 0===h){console.warn("THREE.WebGLShadowMap:",u,"has no shadow.");continue}if(!1===h.autoUpdate&&!1===h.needsUpdate)continue;i.copy(h.mapSize);const p=h.getFrameExtents();if(i.multiply(p),s.copy(h.mapSize),(i.x>c||i.y>c)&&(i.x>c&&(s.x=Math.floor(c/p.x),i.x=s.x*p.x,h.mapSize.x=s.x),i.y>c&&(s.y=Math.floor(c/p.y),i.y=s.y*p.y,h.mapSize.y=s.y)),null===h.map){const t=this.type!==g?{minFilter:gt,magFilter:gt}:{};h.map=new nr(i.x,i.y,t),h.map.texture.name=u.name+".shadowMap",h.camera.updateProjectionMatrix()}t.setRenderTarget(h.map),t.clear();const f=h.getViewportCount();for(let t=0;t<f;t++){const e=h.getViewport(t);a.set(s.x*e.x,s.y*e.y,s.x*e.z,s.y*e.w),d.viewport(a),h.updateMatrices(u,t),r=h.getFrustum(),k(n,o,h.camera,u,this.type)}!0!==h.isPointLightShadow&&this.type===g&&_(h,o),h.needsUpdate=!1}w.needsUpdate=!1,t.setRenderTarget(l,u,h)}}function el(t,e,n){const r=n.isWebGL2,i=new function(){let e=!1;const n=new er;let r=null;const i=new er(0,0,0,0);return{setMask:function(n){r===n||e||(t.colorMask(n,n,n,n),r=n)},setLocked:function(t){e=t},setClear:function(e,r,s,a,o){!0===o&&(e*=a,r*=a,s*=a),n.set(e,r,s,a),!1===i.equals(n)&&(t.clearColor(e,r,s,a),i.copy(n))},reset:function(){e=!1,r=null,i.set(-1,0,0,0)}}},s=new function(){let e=!1,n=null,r=null,i=null;return{setTest:function(t){t?wt(2929):St(2929)},setMask:function(r){n===r||e||(t.depthMask(r),n=r)},setFunc:function(e){if(r!==e){if(e)switch(e){case G:t.depthFunc(512);break;case H:t.depthFunc(519);break;case j:t.depthFunc(513);break;case q:t.depthFunc(515);break;case X:t.depthFunc(514);break;case K:t.depthFunc(518);break;case Y:t.depthFunc(516);break;case Z:t.depthFunc(517);break;default:t.depthFunc(515)}else t.depthFunc(515);r=e}},setLocked:function(t){e=t},setClear:function(e){i!==e&&(t.clearDepth(e),i=e)},reset:function(){e=!1,n=null,r=null,i=null}}},a=new function(){let e=!1,n=null,r=null,i=null,s=null,a=null,o=null,l=null,u=null;return{setTest:function(t){e||(t?wt(2960):St(2960))},setMask:function(r){n===r||e||(t.stencilMask(r),n=r)},setFunc:function(e,n,a){r===e&&i===n&&s===a||(t.stencilFunc(e,n,a),r=e,i=n,s=a)},setOp:function(e,n,r){a===e&&o===n&&l===r||(t.stencilOp(e,n,r),a=e,o=n,l=r)},setLocked:function(t){e=t},setClear:function(e){u!==e&&(t.clearStencil(e),u=e)},reset:function(){e=!1,n=null,r=null,i=null,s=null,a=null,o=null,l=null,u=null}}},o=new WeakMap,l=new WeakMap;let d={},p={},f=new WeakMap,m=[],g=null,x=!1,b=null,w=null,J=null,Q=null,tt=null,et=null,nt=null,rt=!1,it=null,st=null,at=null,ot=null,lt=null;const ut=t.getParameter(35661);let ct=!1,ht=0;const dt=t.getParameter(7938);-1!==dt.indexOf("WebGL")?(ht=parseFloat(/^WebGL (\d)/.exec(dt)[1]),ct=ht>=1):-1!==dt.indexOf("OpenGL ES")&&(ht=parseFloat(/^OpenGL ES (\d)/.exec(dt)[1]),ct=ht>=2);let pt=null,ft={};const mt=t.getParameter(3088),gt=t.getParameter(2978),xt=(new er).fromArray(mt),yt=(new er).fromArray(gt);function vt(e,n,r){const i=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let e=0;e<r;e++)t.texImage2D(n+e,0,6408,1,1,0,6408,5121,i);return s}const bt={};function wt(e){!0!==d[e]&&(t.enable(e),d[e]=!0)}function St(e){!1!==d[e]&&(t.disable(e),d[e]=!1)}bt[3553]=vt(3553,3553,1),bt[34067]=vt(34067,34069,6),i.setClear(0,0,0,1),s.setClear(1),a.setClear(0),wt(2929),s.setFunc(q),Mt(!1),Tt(c),wt(2884),kt(S);const _t={[C]:32774,[E]:32778,[A]:32779};if(r)_t[N]=32775,_t[R]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(_t[N]=t.MIN_EXT,_t[R]=t.MAX_EXT)}const It={[D]:0,[L]:1,[F]:768,[P]:770,[V]:776,[U]:774,[z]:772,[$]:769,[O]:771,[W]:775,[B]:773};function kt(e,n,r,i,s,a,o,l){if(e!==S){if(!1===x&&(wt(3042),x=!0),e===T)s=s||n,a=a||r,o=o||i,n===w&&s===tt||(t.blendEquationSeparate(_t[n],_t[s]),w=n,tt=s),r===J&&i===Q&&a===et&&o===nt||(t.blendFuncSeparate(It[r],It[i],It[a],It[o]),J=r,Q=i,et=a,nt=o),b=e,rt=null;else if(e!==b||l!==rt){if(w===C&&tt===C||(t.blendEquation(32774),w=C,tt=C),l)switch(e){case _:t.blendFuncSeparate(1,771,1,771);break;case I:t.blendFunc(1,1);break;case k:t.blendFuncSeparate(0,769,0,1);break;case M:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case _:t.blendFuncSeparate(770,771,1,771);break;case I:t.blendFunc(770,1);break;case k:t.blendFuncSeparate(0,769,0,1);break;case M:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}J=null,Q=null,et=null,nt=null,b=e,rt=l}}else!0===x&&(St(3042),x=!1)}function Mt(e){it!==e&&(e?t.frontFace(2304):t.frontFace(2305),it=e)}function Tt(e){e!==u?(wt(2884),e!==st&&(e===c?t.cullFace(1029):e===h?t.cullFace(1028):t.cullFace(1032))):St(2884),st=e}function Ct(e,n,r){e?(wt(32823),ot===n&&lt===r||(t.polygonOffset(n,r),ot=n,lt=r)):St(32823)}function Et(e){void 0===e&&(e=33984+ut-1),pt!==e&&(t.activeTexture(e),pt=e)}return{buffers:{color:i,depth:s,stencil:a},enable:wt,disable:St,bindFramebuffer:function(e,n){return p[e]!==n&&(t.bindFramebuffer(e,n),p[e]=n,r&&(36009===e&&(p[36160]=n),36160===e&&(p[36009]=n)),!0)},drawBuffers:function(r,i){let s=m,a=!1;if(r)if(s=f.get(i),void 0===s&&(s=[],f.set(i,s)),r.isWebGLMultipleRenderTargets){const t=r.texture;if(s.length!==t.length||36064!==s[0]){for(let e=0,n=t.length;e<n;e++)s[e]=36064+e;s.length=t.length,a=!0}}else 36064!==s[0]&&(s[0]=36064,a=!0);else 1029!==s[0]&&(s[0]=1029,a=!0);a&&(n.isWebGL2?t.drawBuffers(s):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))},useProgram:function(e){return g!==e&&(t.useProgram(e),g=e,!0)},setBlending:kt,setMaterial:function(t,e){t.side===v?St(2884):wt(2884);let n=t.side===y;e&&(n=!n),Mt(n),t.blending===_&&!1===t.transparent?kt(S):kt(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),s.setFunc(t.depthFunc),s.setTest(t.depthTest),s.setMask(t.depthWrite),i.setMask(t.colorWrite);const r=t.stencilWrite;a.setTest(r),r&&(a.setMask(t.stencilWriteMask),a.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),a.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),Ct(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?wt(32926):St(32926)},setFlipSided:Mt,setCullFace:Tt,setLineWidth:function(e){e!==at&&(ct&&t.lineWidth(e),at=e)},setPolygonOffset:Ct,setScissorTest:function(t){t?wt(3089):St(3089)},activeTexture:Et,bindTexture:function(e,n){null===pt&&Et();let r=ft[pt];void 0===r&&(r={type:void 0,texture:void 0},ft[pt]=r),r.type===e&&r.texture===n||(t.bindTexture(e,n||bt[e]),r.type=e,r.texture=n)},unbindTexture:function(){const e=ft[pt];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},updateUBOMapping:function(e,n){let r=l.get(n);void 0===r&&(r=new WeakMap,l.set(n,r));let i=r.get(e);void 0===i&&(i=t.getUniformBlockIndex(n,e.name),r.set(e,i))},uniformBlockBinding:function(e,n){const r=l.get(n).get(e);o.get(e)!==r&&(t.uniformBlockBinding(n,r,e.__bindingPointIndex),o.set(e,r))},texStorage2D:function(){try{t.texStorage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===xt.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),xt.copy(e))},viewport:function(e){!1===yt.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),yt.copy(e))},reset:function(){t.disable(3042),t.disable(2884),t.disable(2929),t.disable(32823),t.disable(3089),t.disable(2960),t.disable(32926),t.blendEquation(32774),t.blendFunc(1,0),t.blendFuncSeparate(1,0,1,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(513),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(519,0,4294967295),t.stencilOp(7680,7680,7680),t.clearStencil(0),t.cullFace(1029),t.frontFace(2305),t.polygonOffset(0,0),t.activeTexture(33984),t.bindFramebuffer(36160,null),!0===r&&(t.bindFramebuffer(36009,null),t.bindFramebuffer(36008,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),d={},pt=null,ft={},p={},f=new WeakMap,m=[],g=null,x=!1,b=null,w=null,J=null,Q=null,tt=null,et=null,nt=null,rt=!1,it=null,st=null,at=null,ot=null,lt=null,xt.set(0,0,t.canvas.width,t.canvas.height),yt.set(0,0,t.canvas.width,t.canvas.height),i.reset(),s.reset(),a.reset()}}}function nl(t,e,n,r,i,s,a){const o=i.isWebGL2,l=i.maxTextures,u=i.maxCubemapSize,c=i.maxTextureSize,h=i.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p=/OculusBrowser/g.test(navigator.userAgent),f=new WeakMap;let m;const g=new WeakMap;let x=!1;try{x="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function y(t,e){return x?new OffscreenCanvas(t,e):Pn("canvas")}function v(t,e,n,r){let i=1;if((t.width>r||t.height>r)&&(i=r/Math.max(t.width,t.height)),i<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const r=e?An:Math.floor,s=r(i*t.width),a=r(i*t.height);void 0===m&&(m=y(s,a));const o=n?y(s,a):m;return o.width=s,o.height=a,o.getContext("2d").drawImage(t,0,0,s,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+s+"x"+a+")."),o}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function b(t){return Cn(t.width)&&Cn(t.height)}function w(t,e){return t.generateMipmaps&&e&&t.minFilter!==gt&&t.minFilter!==wt}function S(e){t.generateMipmap(e)}function _(n,r,i,s,a=!1){if(!1===o)return r;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let l=r;return 6403===r&&(5126===i&&(l=33326),5131===i&&(l=33325),5121===i&&(l=33321)),33319===r&&(5126===i&&(l=33328),5131===i&&(l=33327),5121===i&&(l=33323)),6408===r&&(5126===i&&(l=34836),5131===i&&(l=34842),5121===i&&(l=s===$e&&!1===a?35907:32856),32819===i&&(l=32854),32820===i&&(l=32855)),33325!==l&&33326!==l&&33327!==l&&33328!==l&&34842!==l&&34836!==l||e.get("EXT_color_buffer_float"),l}function I(t,e,n){return!0===w(t,n)||t.isFramebufferTexture&&t.minFilter!==gt&&t.minFilter!==wt?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function k(t){return t===gt||t===xt||t===vt?9728:9729}function M(t){const e=t.target;e.removeEventListener("dispose",M),function(t){const e=r.get(t);if(void 0===e.__webglInit)return;const n=t.source,i=g.get(n);if(i){const r=i[e.__cacheKey];r.usedTimes--,0===r.usedTimes&&C(t),0===Object.keys(i).length&&g.delete(n)}r.remove(t)}(e),e.isVideoTexture&&f.delete(e)}function T(e){const n=e.target;n.removeEventListener("dispose",T),function(e){const n=e.texture,i=r.get(e),s=r.get(n);if(void 0!==s.__webglTexture&&(t.deleteTexture(s.__webglTexture),a.memory.textures--),e.depthTexture&&e.depthTexture.dispose(),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(i.__webglFramebuffer[e]),i.__webglDepthbuffer&&t.deleteRenderbuffer(i.__webglDepthbuffer[e]);else{if(t.deleteFramebuffer(i.__webglFramebuffer),i.__webglDepthbuffer&&t.deleteRenderbuffer(i.__webglDepthbuffer),i.__webglMultisampledFramebuffer&&t.deleteFramebuffer(i.__webglMultisampledFramebuffer),i.__webglColorRenderbuffer)for(let e=0;e<i.__webglColorRenderbuffer.length;e++)i.__webglColorRenderbuffer[e]&&t.deleteRenderbuffer(i.__webglColorRenderbuffer[e]);i.__webglDepthRenderbuffer&&t.deleteRenderbuffer(i.__webglDepthRenderbuffer)}if(e.isWebGLMultipleRenderTargets)for(let e=0,i=n.length;e<i;e++){const i=r.get(n[e]);i.__webglTexture&&(t.deleteTexture(i.__webglTexture),a.memory.textures--),r.remove(n[e])}r.remove(n),r.remove(e)}(n)}function C(e){const n=r.get(e);t.deleteTexture(n.__webglTexture);const i=e.source;delete g.get(i)[n.__cacheKey],a.memory.textures--}let E=0;function A(t,e){const i=r.get(t);if(t.isVideoTexture&&function(t){const e=a.render.frame;f.get(t)!==e&&(f.set(t,e),t.update())}(t),!1===t.isRenderTargetTexture&&t.version>0&&i.__version!==t.version){const n=t.image;if(null===n)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==n.complete)return void F(i,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+e),n.bindTexture(3553,i.__webglTexture)}const N={[pt]:10497,[ft]:33071,[mt]:33648},R={[gt]:9728,[xt]:9984,[vt]:9986,[wt]:9729,[St]:9985,[It]:9987};function D(n,s,a){if(a?(t.texParameteri(n,10242,N[s.wrapS]),t.texParameteri(n,10243,N[s.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,N[s.wrapR]),t.texParameteri(n,10240,R[s.magFilter]),t.texParameteri(n,10241,R[s.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),s.wrapS===ft&&s.wrapT===ft||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,10240,k(s.magFilter)),t.texParameteri(n,10241,k(s.minFilter)),s.minFilter!==gt&&s.minFilter!==wt&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){const a=e.get("EXT_texture_filter_anisotropic");if(s.type===Rt&&!1===e.has("OES_texture_float_linear"))return;if(!1===o&&s.type===Dt&&!1===e.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||r.get(s).__currentAnisotropy)&&(t.texParameterf(n,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,i.getMaxAnisotropy())),r.get(s).__currentAnisotropy=s.anisotropy)}}function L(e,n){let r=!1;void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",M));const i=n.source;let s=g.get(i);void 0===s&&(s={},g.set(i,s));const o=function(t){const e=[];return e.push(t.wrapS),e.push(t.wrapT),e.push(t.magFilter),e.push(t.minFilter),e.push(t.anisotropy),e.push(t.internalFormat),e.push(t.format),e.push(t.type),e.push(t.generateMipmaps),e.push(t.premultiplyAlpha),e.push(t.flipY),e.push(t.unpackAlignment),e.push(t.encoding),e.join()}(n);if(o!==e.__cacheKey){void 0===s[o]&&(s[o]={texture:t.createTexture(),usedTimes:0},a.memory.textures++,r=!0),s[o].usedTimes++;const i=s[e.__cacheKey];void 0!==i&&(s[e.__cacheKey].usedTimes--,0===i.usedTimes&&C(n)),e.__cacheKey=o,e.__webglTexture=s[o].texture}return r}function F(e,r,i){let a=3553;r.isDataArrayTexture&&(a=35866),r.isData3DTexture&&(a=32879);const l=L(e,r),u=r.source;if(n.activeTexture(33984+i),n.bindTexture(a,e.__webglTexture),u.version!==u.__currentVersion||!0===l){t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment),t.pixelStorei(37443,0);const e=function(t){return!o&&(t.wrapS!==ft||t.wrapT!==ft||t.minFilter!==gt&&t.minFilter!==wt)}(r)&&!1===b(r.image);let i=v(r.image,e,!1,c);i=U(r,i);const h=b(i)||o,d=s.convert(r.format,r.encoding);let p,f=s.convert(r.type),m=_(r.internalFormat,d,f,r.encoding,r.isVideoTexture);D(a,r,h);const g=r.mipmaps,x=o&&!0!==r.isVideoTexture,y=void 0===u.__currentVersion||!0===l,k=I(r,i,h);if(r.isDepthTexture)m=6402,o?m=r.type===Rt?36012:r.type===Nt?33190:r.type===$t?35056:33189:r.type===Rt&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===Wt&&6402===m&&r.type!==Et&&r.type!==Nt&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=Nt,f=s.convert(r.type)),r.format===Vt&&6402===m&&(m=34041,r.type!==$t&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=$t,f=s.convert(r.type))),y&&(x?n.texStorage2D(3553,1,m,i.width,i.height):n.texImage2D(3553,0,m,i.width,i.height,0,d,f,null));else if(r.isDataTexture)if(g.length>0&&h){x&&y&&n.texStorage2D(3553,k,m,g[0].width,g[0].height);for(let t=0,e=g.length;t<e;t++)p=g[t],x?n.texSubImage2D(3553,t,0,0,p.width,p.height,d,f,p.data):n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data);r.generateMipmaps=!1}else x?(y&&n.texStorage2D(3553,k,m,i.width,i.height),n.texSubImage2D(3553,0,0,0,i.width,i.height,d,f,i.data)):n.texImage2D(3553,0,m,i.width,i.height,0,d,f,i.data);else if(r.isCompressedTexture){x&&y&&n.texStorage2D(3553,k,m,g[0].width,g[0].height);for(let t=0,e=g.length;t<e;t++)p=g[t],r.format!==zt?null!==d?x?n.compressedTexSubImage2D(3553,t,0,0,p.width,p.height,d,p.data):n.compressedTexImage2D(3553,t,m,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):x?n.texSubImage2D(3553,t,0,0,p.width,p.height,d,f,p.data):n.texImage2D(3553,t,m,p.width,p.height,0,d,f,p.data)}else if(r.isDataArrayTexture)x?(y&&n.texStorage3D(35866,k,m,i.width,i.height,i.depth),n.texSubImage3D(35866,0,0,0,0,i.width,i.height,i.depth,d,f,i.data)):n.texImage3D(35866,0,m,i.width,i.height,i.depth,0,d,f,i.data);else if(r.isData3DTexture)x?(y&&n.texStorage3D(32879,k,m,i.width,i.height,i.depth),n.texSubImage3D(32879,0,0,0,0,i.width,i.height,i.depth,d,f,i.data)):n.texImage3D(32879,0,m,i.width,i.height,i.depth,0,d,f,i.data);else if(r.isFramebufferTexture){if(y)if(x)n.texStorage2D(3553,k,m,i.width,i.height);else{let t=i.width,e=i.height;for(let r=0;r<k;r++)n.texImage2D(3553,r,m,t,e,0,d,f,null),t>>=1,e>>=1}}else if(g.length>0&&h){x&&y&&n.texStorage2D(3553,k,m,g[0].width,g[0].height);for(let t=0,e=g.length;t<e;t++)p=g[t],x?n.texSubImage2D(3553,t,0,0,d,f,p):n.texImage2D(3553,t,m,d,f,p);r.generateMipmaps=!1}else x?(y&&n.texStorage2D(3553,k,m,i.width,i.height),n.texSubImage2D(3553,0,0,0,d,f,i)):n.texImage2D(3553,0,m,d,f,i);w(r,h)&&S(a),u.__currentVersion=u.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}function $(e,i,a,o,l){const u=s.convert(a.format,a.encoding),c=s.convert(a.type),h=_(a.internalFormat,u,c,a.encoding);r.get(i).__hasExternalTextures||(32879===l||35866===l?n.texImage3D(l,0,h,i.width,i.height,i.depth,0,u,c,null):n.texImage2D(l,0,h,i.width,i.height,0,u,c,null)),n.bindFramebuffer(36160,e),B(i)?d.framebufferTexture2DMultisampleEXT(36160,o,l,r.get(a).__webglTexture,0,z(i)):t.framebufferTexture2D(36160,o,l,r.get(a).__webglTexture,0),n.bindFramebuffer(36160,null)}function P(e,n,r){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let i=33189;if(r||B(n)){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===Rt?i=36012:e.type===Nt&&(i=33190));const r=z(n);B(n)?d.renderbufferStorageMultisampleEXT(36161,r,i,n.width,n.height):t.renderbufferStorageMultisample(36161,r,i,n.width,n.height)}else t.renderbufferStorage(36161,i,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){const i=z(n);r&&!1===B(n)?t.renderbufferStorageMultisample(36161,i,35056,n.width,n.height):B(n)?d.renderbufferStorageMultisampleEXT(36161,i,35056,n.width,n.height):t.renderbufferStorage(36161,34041,n.width,n.height),t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture];for(let i=0;i<e.length;i++){const a=e[i],o=s.convert(a.format,a.encoding),l=s.convert(a.type),u=_(a.internalFormat,o,l,a.encoding),c=z(n);r&&!1===B(n)?t.renderbufferStorageMultisample(36161,c,u,n.width,n.height):B(n)?d.renderbufferStorageMultisampleEXT(36161,c,u,n.width,n.height):t.renderbufferStorage(36161,u,n.width,n.height)}}t.bindRenderbuffer(36161,null)}function O(e){const i=r.get(e),s=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!i.__autoAllocateDepthBuffer){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,i){if(i&&i.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,e),!i.depthTexture||!i.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(i.depthTexture).__webglTexture&&i.depthTexture.image.width===i.width&&i.depthTexture.image.height===i.height||(i.depthTexture.image.width=i.width,i.depthTexture.image.height=i.height,i.depthTexture.needsUpdate=!0),A(i.depthTexture,0);const s=r.get(i.depthTexture).__webglTexture,a=z(i);if(i.depthTexture.format===Wt)B(i)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,s,0,a):t.framebufferTexture2D(36160,36096,3553,s,0);else{if(i.depthTexture.format!==Vt)throw new Error("Unknown depthTexture format");B(i)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,s,0,a):t.framebufferTexture2D(36160,33306,3553,s,0)}}(i.__webglFramebuffer,e)}else if(s){i.__webglDepthbuffer=[];for(let r=0;r<6;r++)n.bindFramebuffer(36160,i.__webglFramebuffer[r]),i.__webglDepthbuffer[r]=t.createRenderbuffer(),P(i.__webglDepthbuffer[r],e,!1)}else n.bindFramebuffer(36160,i.__webglFramebuffer),i.__webglDepthbuffer=t.createRenderbuffer(),P(i.__webglDepthbuffer,e,!1);n.bindFramebuffer(36160,null)}function z(t){return Math.min(h,t.samples)}function B(t){const n=r.get(t);return o&&t.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function U(t,n){const r=t.encoding,i=t.format,s=t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||t.format===yn||r!==Fe&&(r===$e?!1===o?!0===e.has("EXT_sRGB")&&i===zt?(t.format=yn,t.minFilter=wt,t.generateMipmaps=!1):n=Yn.sRGBToLinear(n):i===zt&&s===Mt||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",r)),n}this.allocateTextureUnit=function(){const t=E;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),E+=1,t},this.resetTextureUnits=function(){E=0},this.setTexture2D=A,this.setTexture2DArray=function(t,e){const i=r.get(t);t.version>0&&i.__version!==t.version?F(i,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,i.__webglTexture))},this.setTexture3D=function(t,e){const i=r.get(t);t.version>0&&i.__version!==t.version?F(i,t,e):(n.activeTexture(33984+e),n.bindTexture(32879,i.__webglTexture))},this.setTextureCube=function(e,i){const a=r.get(e);e.version>0&&a.__version!==e.version?function(e,r,i){if(6!==r.image.length)return;const a=L(e,r),l=r.source;if(n.activeTexture(33984+i),n.bindTexture(34067,e.__webglTexture),l.version!==l.__currentVersion||!0===a){t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment),t.pixelStorei(37443,0);const e=r.isCompressedTexture||r.image[0].isCompressedTexture,i=r.image[0]&&r.image[0].isDataTexture,c=[];for(let t=0;t<6;t++)c[t]=e||i?i?r.image[t].image:r.image[t]:v(r.image[t],!1,!0,u),c[t]=U(r,c[t]);const h=c[0],d=b(h)||o,p=s.convert(r.format,r.encoding),f=s.convert(r.type),m=_(r.internalFormat,p,f,r.encoding),g=o&&!0!==r.isVideoTexture,x=void 0===l.__currentVersion||!0===a;let y,k=I(r,h,d);if(D(34067,r,d),e){g&&x&&n.texStorage2D(34067,k,m,h.width,h.height);for(let t=0;t<6;t++){y=c[t].mipmaps;for(let e=0;e<y.length;e++){const i=y[e];r.format!==zt?null!==p?g?n.compressedTexSubImage2D(34069+t,e,0,0,i.width,i.height,p,i.data):n.compressedTexImage2D(34069+t,e,m,i.width,i.height,0,i.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):g?n.texSubImage2D(34069+t,e,0,0,i.width,i.height,p,f,i.data):n.texImage2D(34069+t,e,m,i.width,i.height,0,p,f,i.data)}}}else{y=r.mipmaps,g&&x&&(y.length>0&&k++,n.texStorage2D(34067,k,m,c[0].width,c[0].height));for(let t=0;t<6;t++)if(i){g?n.texSubImage2D(34069+t,0,0,0,c[t].width,c[t].height,p,f,c[t].data):n.texImage2D(34069+t,0,m,c[t].width,c[t].height,0,p,f,c[t].data);for(let e=0;e<y.length;e++){const r=y[e].image[t].image;g?n.texSubImage2D(34069+t,e+1,0,0,r.width,r.height,p,f,r.data):n.texImage2D(34069+t,e+1,m,r.width,r.height,0,p,f,r.data)}}else{g?n.texSubImage2D(34069+t,0,0,0,p,f,c[t]):n.texImage2D(34069+t,0,m,p,f,c[t]);for(let e=0;e<y.length;e++){const r=y[e];g?n.texSubImage2D(34069+t,e+1,0,0,p,f,r.image[t]):n.texImage2D(34069+t,e+1,m,p,f,r.image[t])}}}w(r,d)&&S(34067),l.__currentVersion=l.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}(a,e,i):(n.activeTexture(33984+i),n.bindTexture(34067,a.__webglTexture))},this.rebindTextures=function(t,e,n){const i=r.get(t);void 0!==e&&$(i.__webglFramebuffer,t,t.texture,36064,3553),void 0!==n&&O(t)},this.setupRenderTarget=function(e){const l=e.texture,u=r.get(e),c=r.get(l);e.addEventListener("dispose",T),!0!==e.isWebGLMultipleRenderTargets&&(void 0===c.__webglTexture&&(c.__webglTexture=t.createTexture()),c.__version=l.version,a.memory.textures++);const h=!0===e.isWebGLCubeRenderTarget,d=!0===e.isWebGLMultipleRenderTargets,p=b(e)||o;if(h){u.__webglFramebuffer=[];for(let e=0;e<6;e++)u.__webglFramebuffer[e]=t.createFramebuffer()}else{if(u.__webglFramebuffer=t.createFramebuffer(),d)if(i.drawBuffers){const n=e.texture;for(let e=0,i=n.length;e<i;e++){const i=r.get(n[e]);void 0===i.__webglTexture&&(i.__webglTexture=t.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(o&&e.samples>0&&!1===B(e)){const r=d?l:[l];u.__webglMultisampledFramebuffer=t.createFramebuffer(),u.__webglColorRenderbuffer=[],n.bindFramebuffer(36160,u.__webglMultisampledFramebuffer);for(let n=0;n<r.length;n++){const i=r[n];u.__webglColorRenderbuffer[n]=t.createRenderbuffer(),t.bindRenderbuffer(36161,u.__webglColorRenderbuffer[n]);const a=s.convert(i.format,i.encoding),o=s.convert(i.type),l=_(i.internalFormat,a,o,i.encoding),c=z(e);t.renderbufferStorageMultisample(36161,c,l,e.width,e.height),t.framebufferRenderbuffer(36160,36064+n,36161,u.__webglColorRenderbuffer[n])}t.bindRenderbuffer(36161,null),e.depthBuffer&&(u.__webglDepthRenderbuffer=t.createRenderbuffer(),P(u.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(36160,null)}}if(h){n.bindTexture(34067,c.__webglTexture),D(34067,l,p);for(let t=0;t<6;t++)$(u.__webglFramebuffer[t],e,l,36064,34069+t);w(l,p)&&S(34067),n.unbindTexture()}else if(d){const t=e.texture;for(let i=0,s=t.length;i<s;i++){const s=t[i],a=r.get(s);n.bindTexture(3553,a.__webglTexture),D(3553,s,p),$(u.__webglFramebuffer,e,s,36064+i,3553),w(s,p)&&S(3553)}n.unbindTexture()}else{let t=3553;(e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(o?t=e.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),n.bindTexture(t,c.__webglTexture),D(t,l,p),$(u.__webglFramebuffer,e,l,36064,t),w(l,p)&&S(t),n.unbindTexture()}e.depthBuffer&&O(e)},this.updateRenderTargetMipmap=function(t){const e=b(t)||o,i=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture];for(let s=0,a=i.length;s<a;s++){const a=i[s];if(w(a,e)){const e=t.isWebGLCubeRenderTarget?34067:3553,i=r.get(a).__webglTexture;n.bindTexture(e,i),S(e),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(o&&e.samples>0&&!1===B(e)){const i=e.isWebGLMultipleRenderTargets?e.texture:[e.texture],s=e.width,a=e.height;let o=16384;const l=[],u=e.stencilBuffer?33306:36096,c=r.get(e),h=!0===e.isWebGLMultipleRenderTargets;if(h)for(let e=0;e<i.length;e++)n.bindFramebuffer(36160,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064+e,36161,null),n.bindFramebuffer(36160,c.__webglFramebuffer),t.framebufferTexture2D(36009,36064+e,3553,null,0);n.bindFramebuffer(36008,c.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,c.__webglFramebuffer);for(let n=0;n<i.length;n++){l.push(36064+n),e.depthBuffer&&l.push(u);const d=void 0!==c.__ignoreDepthValues&&c.__ignoreDepthValues;if(!1===d&&(e.depthBuffer&&(o|=256),e.stencilBuffer&&(o|=1024)),h&&t.framebufferRenderbuffer(36008,36064,36161,c.__webglColorRenderbuffer[n]),!0===d&&(t.invalidateFramebuffer(36008,[u]),t.invalidateFramebuffer(36009,[u])),h){const e=r.get(i[n]).__webglTexture;t.framebufferTexture2D(36009,36064,3553,e,0)}t.blitFramebuffer(0,0,s,a,0,0,s,a,o,9728),p&&t.invalidateFramebuffer(36008,l)}if(n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,null),h)for(let e=0;e<i.length;e++){n.bindFramebuffer(36160,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064+e,36161,c.__webglColorRenderbuffer[e]);const s=r.get(i[e]).__webglTexture;n.bindFramebuffer(36160,c.__webglFramebuffer),t.framebufferTexture2D(36009,36064+e,3553,s,0)}n.bindFramebuffer(36009,c.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=O,this.setupFrameBufferTexture=$,this.useMultisampledRTT=B}function rl(t,e,n){const r=n.isWebGL2;return{convert:function(n,i=null){let s;if(n===Mt)return 5121;if(n===Lt)return 32819;if(n===Ft)return 32820;if(n===Tt)return 5120;if(n===Ct)return 5122;if(n===Et)return 5123;if(n===At)return 5124;if(n===Nt)return 5125;if(n===Rt)return 5126;if(n===Dt)return r?5131:(s=e.get("OES_texture_half_float"),null!==s?s.HALF_FLOAT_OES:null);if(n===Pt)return 6406;if(n===zt)return 6408;if(n===Bt)return 6409;if(n===Ut)return 6410;if(n===Wt)return 6402;if(n===Vt)return 34041;if(n===Gt)return 6403;if(n===Ot)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(n===yn)return s=e.get("EXT_sRGB"),null!==s?s.SRGB_ALPHA_EXT:null;if(n===Ht)return 36244;if(n===jt)return 33319;if(n===qt)return 33320;if(n===Xt)return 36249;if(n===Kt||n===Yt||n===Zt||n===Jt)if(i===$e){if(s=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(n===Kt)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===Yt)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===Zt)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Jt)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=e.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(n===Kt)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Yt)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===Zt)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Jt)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===Qt||n===te||n===ee||n===ne){if(s=e.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(n===Qt)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===te)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===ee)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===ne)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===re)return s=e.get("WEBGL_compressed_texture_etc1"),null!==s?s.COMPRESSED_RGB_ETC1_WEBGL:null;if(n===ie||n===se){if(s=e.get("WEBGL_compressed_texture_etc"),null===s)return null;if(n===ie)return i===$e?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(n===se)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(n===ae||n===oe||n===le||n===ue||n===ce||n===he||n===de||n===pe||n===fe||n===me||n===ge||n===xe||n===ye||n===ve){if(s=e.get("WEBGL_compressed_texture_astc"),null===s)return null;if(n===ae)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===oe)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===le)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===ue)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===ce)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===he)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===de)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===pe)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===fe)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===me)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===ge)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===xe)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===ye)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===ve)return i===$e?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===be){if(s=e.get("EXT_texture_compression_bptc"),null===s)return null;if(n===be)return i===$e?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT}return n===$t?r?34042:(s=e.get("WEBGL_depth_texture"),null!==s?s.UNSIGNED_INT_24_8_WEBGL:null):void 0!==t[n]?t[n]:null}}}class il extends ys{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class sl extends hi{constructor(){super(),this.isGroup=!0,this.type="Group"}}const al={type:"move"};class ol{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new sl,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new sl,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new ur,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new ur),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new sl,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new ur,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new ur),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let r=null,i=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState){if(l&&t.hand){s=!0;for(const r of t.hand.values()){const t=e.getJointPose(r,n);if(void 0===l.joints[r.jointName]){const t=new sl;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[r.jointName]=t,l.add(t)}const i=l.joints[r.jointName];null!==t&&(i.matrix.fromArray(t.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.jointRadius=t.radius),i.visible=null!==t}const r=l.joints["index-finger-tip"],i=l.joints["thumb-tip"],a=r.position.distanceTo(i.position),o=.02,u=.005;l.inputState.pinching&&a>o+u?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&a<=o-u&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(i=e.getPose(t.gripSpace,n),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1));null!==a&&(r=e.getPose(t.targetRaySpace,n),null===r&&null!==i&&(r=i),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(al)))}return null!==a&&(a.visible=null!==r),null!==o&&(o.visible=null!==i),null!==l&&(l.visible=null!==s),this}}class ll extends tr{constructor(t,e,n,r,i,s,a,o,l,u){if((u=void 0!==u?u:Wt)!==Wt&&u!==Vt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&u===Wt&&(n=Nt),void 0===n&&u===Vt&&(n=$t),super(null,r,i,s,a,o,u,n,l),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=void 0!==a?a:gt,this.minFilter=void 0!==o?o:gt,this.flipY=!1,this.generateMipmaps=!1}}class ul extends vn{constructor(t,e){super();const n=this;let r=null,i=1,s=null,a="local-floor",o=null,l=null,u=null,c=null,h=null,d=null;const p=e.getContextAttributes();let f=null,m=null;const g=[],x=[],y=new ys;y.layers.enable(1),y.viewport=new er;const v=new ys;v.layers.enable(2),v.viewport=new er;const b=[y,v],w=new il;w.layers.enable(1),w.layers.enable(2);let S=null,_=null;function I(t){const e=x.indexOf(t.inputSource);if(-1===e)return;const n=g[e];void 0!==n&&n.dispatchEvent({type:t.type,data:t.inputSource})}function k(){r.removeEventListener("select",I),r.removeEventListener("selectstart",I),r.removeEventListener("selectend",I),r.removeEventListener("squeeze",I),r.removeEventListener("squeezestart",I),r.removeEventListener("squeezeend",I),r.removeEventListener("end",k),r.removeEventListener("inputsourceschange",M);for(let t=0;t<g.length;t++){const e=x[t];null!==e&&(x[t]=null,g[t].disconnect(e))}S=null,_=null,t.setRenderTarget(f),h=null,c=null,u=null,r=null,m=null,N.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function M(t){for(let e=0;e<t.removed.length;e++){const n=t.removed[e],r=x.indexOf(n);r>=0&&(x[r]=null,g[r].dispatchEvent({type:"disconnected",data:n}))}for(let e=0;e<t.added.length;e++){const n=t.added[e];let r=x.indexOf(n);if(-1===r){for(let t=0;t<g.length;t++){if(t>=x.length){x.push(n),r=t;break}if(null===x[t]){x[t]=n,r=t;break}}if(-1===r)break}const i=g[r];i&&i.dispatchEvent({type:"connected",data:n})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=g[t];return void 0===e&&(e=new ol,g[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=g[t];return void 0===e&&(e=new ol,g[t]=e),e.getGripSpace()},this.getHand=function(t){let e=g[t];return void 0===e&&(e=new ol,g[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){i=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){a=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o||s},this.setReferenceSpace=function(t){o=t},this.getBaseLayer=function(){return null!==c?c:h},this.getBinding=function(){return u},this.getFrame=function(){return d},this.getSession=function(){return r},this.setSession=async function(l){if(r=l,null!==r){if(f=t.getRenderTarget(),r.addEventListener("select",I),r.addEventListener("selectstart",I),r.addEventListener("selectend",I),r.addEventListener("squeeze",I),r.addEventListener("squeezestart",I),r.addEventListener("squeezeend",I),r.addEventListener("end",k),r.addEventListener("inputsourceschange",M),!0!==p.xrCompatible&&await e.makeXRCompatible(),void 0===r.renderState.layers||!1===t.capabilities.isWebGL2){const n={antialias:void 0!==r.renderState.layers||p.antialias,alpha:p.alpha,depth:p.depth,stencil:p.stencil,framebufferScaleFactor:i};h=new XRWebGLLayer(r,e,n),r.updateRenderState({baseLayer:h}),m=new nr(h.framebufferWidth,h.framebufferHeight,{format:zt,type:Mt,encoding:t.outputEncoding})}else{let n=null,s=null,a=null;p.depth&&(a=p.stencil?35056:33190,n=p.stencil?Vt:Wt,s=p.stencil?$t:Nt);const o={colorFormat:32856,depthFormat:a,scaleFactor:i};u=new XRWebGLBinding(r,e),c=u.createProjectionLayer(o),r.updateRenderState({layers:[c]}),m=new nr(c.textureWidth,c.textureHeight,{format:zt,type:Mt,depthTexture:new ll(c.textureWidth,c.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:p.stencil,encoding:t.outputEncoding,samples:p.antialias?4:0}),t.properties.get(m).__ignoreDepthValues=c.ignoreDepthValues}m.isXRRenderTarget=!0,this.setFoveation(1),o=null,s=await r.requestReferenceSpace(a),N.setContext(r),N.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const T=new ur,C=new ur;function E(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===r)return;w.near=v.near=y.near=t.near,w.far=v.far=y.far=t.far,S===w.near&&_===w.far||(r.updateRenderState({depthNear:w.near,depthFar:w.far}),S=w.near,_=w.far);const e=t.parent,n=w.cameras;E(w,e);for(let t=0;t<n.length;t++)E(n[t],e);w.matrixWorld.decompose(w.position,w.quaternion,w.scale),t.position.copy(w.position),t.quaternion.copy(w.quaternion),t.scale.copy(w.scale),t.matrix.copy(w.matrix),t.matrixWorld.copy(w.matrixWorld);const i=t.children;for(let t=0,e=i.length;t<e;t++)i[t].updateMatrixWorld(!0);2===n.length?function(t,e,n){T.setFromMatrixPosition(e.matrixWorld),C.setFromMatrixPosition(n.matrixWorld);const r=T.distanceTo(C),i=e.projectionMatrix.elements,s=n.projectionMatrix.elements,a=i[14]/(i[10]-1),o=i[14]/(i[10]+1),l=(i[9]+1)/i[5],u=(i[9]-1)/i[5],c=(i[8]-1)/i[0],h=(s[8]+1)/s[0],d=a*c,p=a*h,f=r/(-c+h),m=f*-c;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=a+f,x=o+f,y=d-m,v=p+(r-m),b=l*o/x*g,w=u*o/x*g;t.projectionMatrix.makePerspective(y,v,b,w,g,x)}(w,y,v):w.projectionMatrix.copy(y.projectionMatrix)},this.getCamera=function(){return w},this.getFoveation=function(){return null!==c?c.fixedFoveation:null!==h?h.fixedFoveation:void 0},this.setFoveation=function(t){null!==c&&(c.fixedFoveation=t),null!==h&&void 0!==h.fixedFoveation&&(h.fixedFoveation=t)};let A=null;const N=new As;N.setAnimationLoop((function(e,n){if(l=n.getViewerPose(o||s),d=n,null!==l){const e=l.views;null!==h&&(t.setRenderTargetFramebuffer(m,h.framebuffer),t.setRenderTarget(m));let n=!1;e.length!==w.cameras.length&&(w.cameras.length=0,n=!0);for(let r=0;r<e.length;r++){const i=e[r];let s=null;if(null!==h)s=h.getViewport(i);else{const e=u.getViewSubImage(c,i);s=e.viewport,0===r&&(t.setRenderTargetTextures(m,e.colorTexture,c.ignoreDepthValues?void 0:e.depthStencilTexture),t.setRenderTarget(m))}let a=b[r];void 0===a&&(a=new ys,a.layers.enable(r),a.viewport=new er,b[r]=a),a.matrix.fromArray(i.transform.matrix),a.projectionMatrix.fromArray(i.projectionMatrix),a.viewport.set(s.x,s.y,s.width,s.height),0===r&&w.matrix.copy(a.matrix),!0===n&&w.cameras.push(a)}}for(let t=0;t<g.length;t++){const e=x[t],r=g[t];null!==e&&void 0!==r&&r.update(e,n,o||s)}A&&A(e,n),d=null})),this.setAnimationLoop=function(t){A=t},this.dispose=function(){}}}function cl(t,e){function n(n,r){n.opacity.value=r.opacity,r.color&&n.diffuse.value.copy(r.color),r.emissive&&n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(n.map.value=r.map),r.alphaMap&&(n.alphaMap.value=r.alphaMap),r.bumpMap&&(n.bumpMap.value=r.bumpMap,n.bumpScale.value=r.bumpScale,r.side===y&&(n.bumpScale.value*=-1)),r.displacementMap&&(n.displacementMap.value=r.displacementMap,n.displacementScale.value=r.displacementScale,n.displacementBias.value=r.displacementBias),r.emissiveMap&&(n.emissiveMap.value=r.emissiveMap),r.normalMap&&(n.normalMap.value=r.normalMap,n.normalScale.value.copy(r.normalScale),r.side===y&&n.normalScale.value.negate()),r.specularMap&&(n.specularMap.value=r.specularMap),r.alphaTest>0&&(n.alphaTest.value=r.alphaTest);const i=e.get(r).envMap;if(i&&(n.envMap.value=i,n.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,n.reflectivity.value=r.reflectivity,n.ior.value=r.ior,n.refractionRatio.value=r.refractionRatio),r.lightMap){n.lightMap.value=r.lightMap;const e=!0!==t.physicallyCorrectLights?Math.PI:1;n.lightMapIntensity.value=r.lightMapIntensity*e}let s,a;r.aoMap&&(n.aoMap.value=r.aoMap,n.aoMapIntensity.value=r.aoMapIntensity),r.map?s=r.map:r.specularMap?s=r.specularMap:r.displacementMap?s=r.displacementMap:r.normalMap?s=r.normalMap:r.bumpMap?s=r.bumpMap:r.roughnessMap?s=r.roughnessMap:r.metalnessMap?s=r.metalnessMap:r.alphaMap?s=r.alphaMap:r.emissiveMap?s=r.emissiveMap:r.clearcoatMap?s=r.clearcoatMap:r.clearcoatNormalMap?s=r.clearcoatNormalMap:r.clearcoatRoughnessMap?s=r.clearcoatRoughnessMap:r.iridescenceMap?s=r.iridescenceMap:r.iridescenceThicknessMap?s=r.iridescenceThicknessMap:r.specularIntensityMap?s=r.specularIntensityMap:r.specularColorMap?s=r.specularColorMap:r.transmissionMap?s=r.transmissionMap:r.thicknessMap?s=r.thicknessMap:r.sheenColorMap?s=r.sheenColorMap:r.sheenRoughnessMap&&(s=r.sheenRoughnessMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),n.uvTransform.value.copy(s.matrix)),r.aoMap?a=r.aoMap:r.lightMap&&(a=r.lightMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),n.uv2Transform.value.copy(a.matrix))}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,r,i,s,a){r.isMeshBasicMaterial||r.isMeshLambertMaterial?n(t,r):r.isMeshToonMaterial?(n(t,r),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap)}(t,r)):r.isMeshPhongMaterial?(n(t,r),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4)}(t,r)):r.isMeshStandardMaterial?(n(t,r),function(t,n){t.roughness.value=n.roughness,t.metalness.value=n.metalness,n.roughnessMap&&(t.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(t.metalnessMap.value=n.metalnessMap);e.get(n).envMap&&(t.envMapIntensity.value=n.envMapIntensity)}(t,r),r.isMeshPhysicalMaterial&&function(t,e,n){t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap)),e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,e.side===y&&t.clearcoatNormalScale.value.negate())),e.iridescence>0&&(t.iridescence.value=e.iridescence,t.iridescenceIOR.value=e.iridescenceIOR,t.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],t.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(t.iridescenceMap.value=e.iridescenceMap),e.iridescenceThicknessMap&&(t.iridescenceThicknessMap.value=e.iridescenceThicknessMap)),e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=n.texture,t.transmissionSamplerSize.value.set(n.width,n.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor)),t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap)}(t,r,a)):r.isMeshMatcapMaterial?(n(t,r),function(t,e){e.matcap&&(t.matcap.value=e.matcap)}(t,r)):r.isMeshDepthMaterial?n(t,r):r.isMeshDistanceMaterial?(n(t,r),function(t,e){t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,r)):r.isMeshNormalMaterial?n(t,r):r.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,r),r.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,r)):r.isPointsMaterial?function(t,e,n,r){let i;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*r,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest),e.map?i=e.map:e.alphaMap&&(i=e.alphaMap),void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),t.uvTransform.value.copy(i.matrix))}(t,r,i,s):r.isSpriteMaterial?function(t,e){let n;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest),e.map?n=e.map:e.alphaMap&&(n=e.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,r):r.isShadowMaterial?(t.color.value.copy(r.color),t.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function hl(t,e,n,r){let i={},s={},a=[];const o=n.isWebGL2?t.getParameter(35375):0;function l(t,e,n){const r=t.value;if(void 0===n[e])return n[e]="number"==typeof r?r:r.clone(),!0;if("number"==typeof r){if(n[e]!==r)return n[e]=r,!0}else{const t=n[e];if(!1===t.equals(r))return t.copy(r),!0}return!1}function u(t){const e=t.value,n={boundary:0,storage:0};return"number"==typeof e?(n.boundary=4,n.storage=4):e.isVector2?(n.boundary=8,n.storage=8):e.isVector3||e.isColor?(n.boundary=16,n.storage=12):e.isVector4?(n.boundary=16,n.storage=16):e.isMatrix3?(n.boundary=48,n.storage=48):e.isMatrix4?(n.boundary=64,n.storage=64):e.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",e),n}function c(e){const n=e.target;n.removeEventListener("dispose",c);const r=a.indexOf(n.__bindingPointIndex);a.splice(r,1),t.deleteBuffer(i[n.id]),delete i[n.id],delete s[n.id]}return{bind:function(t,e){const n=e.program;r.uniformBlockBinding(t,n)},update:function(n,h){let d=i[n.id];void 0===d&&(function(t){const e=t.uniforms;let n=0;let r=0;for(let t=0,i=e.length;t<i;t++){const i=e[t],s=u(i);i.__data=new Float32Array(s.storage/Float32Array.BYTES_PER_ELEMENT),i.__offset=n,t>0&&(r=n%16,0!==r&&16-r-s.boundary<0&&(n+=16-r,i.__offset=n)),n+=s.storage}r=n%16,r>0&&(n+=16-r),t.__size=n,t.__cache={}}(n),d=function(e){const n=function(){for(let t=0;t<o;t++)if(-1===a.indexOf(t))return a.push(t),t;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.__bindingPointIndex=n;const r=t.createBuffer(),i=e.__size,s=e.usage;return t.bindBuffer(35345,r),t.bufferData(35345,i,s),t.bindBuffer(35345,null),t.bindBufferBase(35345,n,r),r}(n),i[n.id]=d,n.addEventListener("dispose",c));const p=h.program;r.updateUBOMapping(n,p);const f=e.render.frame;s[n.id]!==f&&(function(e){const n=i[e.id],r=e.uniforms,s=e.__cache;t.bindBuffer(35345,n);for(let e=0,n=r.length;e<n;e++){const n=r[e];if(!0===l(n,e,s)){const e=n.value,r=n.__offset;"number"==typeof e?(n.__data[0]=e,t.bufferSubData(35345,r,n.__data)):(n.value.isMatrix3?(n.__data[0]=n.value.elements[0],n.__data[1]=n.value.elements[1],n.__data[2]=n.value.elements[2],n.__data[3]=n.value.elements[0],n.__data[4]=n.value.elements[3],n.__data[5]=n.value.elements[4],n.__data[6]=n.value.elements[5],n.__data[7]=n.value.elements[0],n.__data[8]=n.value.elements[6],n.__data[9]=n.value.elements[7],n.__data[10]=n.value.elements[8],n.__data[11]=n.value.elements[0]):e.toArray(n.__data),t.bufferSubData(35345,r,n.__data))}}t.bindBuffer(35345,null)}(n),s[n.id]=f)},dispose:function(){for(const e in i)t.deleteBuffer(i[e]);a=[],i={},s={}}}}function dl(t={}){this.isWebGLRenderer=!0;const e=void 0!==t.canvas?t.canvas:function(){const t=Pn("canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,r=void 0===t.depth||t.depth,i=void 0===t.stencil||t.stencil,s=void 0!==t.antialias&&t.antialias,o=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,u=void 0!==t.powerPreference?t.powerPreference:"default",c=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let h;h=null!==n?n.getContextAttributes().alpha:void 0!==t.alpha&&t.alpha;let d=null,p=null;const f=[],m=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Fe,this.physicallyCorrectLights=!1,this.toneMapping=et,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const g=this;let b=!1,w=0,S=0,_=null,I=-1,k=null;const M=new er,T=new er;let C=null,E=e.width,A=e.height,N=1,R=null,D=null;const L=new er(0,0,E,A),F=new er(0,0,E,A);let $=!1;const P=new Es;let O=!1,z=!1,B=null;const U=new Br,W=new Rn,V=new ur,G={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function H(){return null===_?N:1}let j,q,X,K,Y,Z,J,Q,tt,nt,rt,it,st,at,ot,lt,ut,ct,ht,dt,pt,ft,mt,gt,xt=n;function yt(t,n){for(let r=0;r<t.length;r++){const i=t[r],s=e.getContext(i,n);if(null!==s)return s}return null}try{const t={alpha:!0,depth:r,stencil:i,antialias:s,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:u,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${a}`),e.addEventListener("webglcontextlost",wt,!1),e.addEventListener("webglcontextrestored",St,!1),e.addEventListener("webglcontextcreationerror",_t,!1),null===xt){const e=["webgl2","webgl","experimental-webgl"];if(!0===g.isWebGL1Renderer&&e.shift(),xt=yt(e,t),null===xt)throw yt(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===xt.getShaderPrecisionFormat&&(xt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function vt(){j=new ra(xt),q=new zs(xt,j,t),j.init(q),ft=new rl(xt,j,q),X=new el(xt,j,q),K=new aa,Y=new zo,Z=new nl(xt,j,X,Y,q,ft,K),J=new Us(g),Q=new na(g),tt=new Ns(xt,q),mt=new Ps(xt,j,tt,q),nt=new ia(xt,tt,K,mt),rt=new ha(xt,nt,tt,K),ht=new ca(xt,q,Z),lt=new Bs(Y),it=new Oo(g,J,Q,j,q,mt,lt),st=new cl(g,Y),at=new Vo,ot=new Ko(j,q),ct=new $s(g,J,X,rt,h,o),ut=new tl(g,rt,q),gt=new hl(xt,K,q,X),dt=new Os(xt,j,K,q),pt=new sa(xt,j,K,q),K.programs=it.programs,g.capabilities=q,g.extensions=j,g.properties=Y,g.renderLists=at,g.shadowMap=ut,g.state=X,g.info=K}vt();const bt=new ul(g,xt);function wt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),b=!0}function St(){console.log("THREE.WebGLRenderer: Context Restored."),b=!1;const t=K.autoReset,e=ut.enabled,n=ut.autoUpdate,r=ut.needsUpdate,i=ut.type;vt(),K.autoReset=t,ut.enabled=e,ut.autoUpdate=n,ut.needsUpdate=r,ut.type=i}function _t(t){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",t.statusMessage)}function kt(t){const e=t.target;e.removeEventListener("dispose",kt),function(t){(function(t){const e=Y.get(t).programs;void 0!==e&&(e.forEach((function(t){it.releaseProgram(t)})),t.isShaderMaterial&&it.releaseShaderCache(t))})(t),Y.remove(t)}(e)}this.xr=bt,this.getContext=function(){return xt},this.getContextAttributes=function(){return xt.getContextAttributes()},this.forceContextLoss=function(){const t=j.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=j.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return N},this.setPixelRatio=function(t){void 0!==t&&(N=t,this.setSize(E,A,!1))},this.getSize=function(t){return t.set(E,A)},this.setSize=function(t,n,r){bt.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(E=t,A=n,e.width=Math.floor(t*N),e.height=Math.floor(n*N),!1!==r&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(E*N,A*N).floor()},this.setDrawingBufferSize=function(t,n,r){E=t,A=n,N=r,e.width=Math.floor(t*r),e.height=Math.floor(n*r),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(M)},this.getViewport=function(t){return t.copy(L)},this.setViewport=function(t,e,n,r){t.isVector4?L.set(t.x,t.y,t.z,t.w):L.set(t,e,n,r),X.viewport(M.copy(L).multiplyScalar(N).floor())},this.getScissor=function(t){return t.copy(F)},this.setScissor=function(t,e,n,r){t.isVector4?F.set(t.x,t.y,t.z,t.w):F.set(t,e,n,r),X.scissor(T.copy(F).multiplyScalar(N).floor())},this.getScissorTest=function(){return $},this.setScissorTest=function(t){X.setScissorTest($=t)},this.setOpaqueSort=function(t){R=t},this.setTransparentSort=function(t){D=t},this.getClearColor=function(t){return t.copy(ct.getClearColor())},this.setClearColor=function(){ct.setClearColor.apply(ct,arguments)},this.getClearAlpha=function(){return ct.getClearAlpha()},this.setClearAlpha=function(){ct.setClearAlpha.apply(ct,arguments)},this.clear=function(t=!0,e=!0,n=!0){let r=0;t&&(r|=16384),e&&(r|=256),n&&(r|=1024),xt.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",wt,!1),e.removeEventListener("webglcontextrestored",St,!1),e.removeEventListener("webglcontextcreationerror",_t,!1),at.dispose(),ot.dispose(),Y.dispose(),J.dispose(),Q.dispose(),rt.dispose(),mt.dispose(),gt.dispose(),it.dispose(),bt.dispose(),bt.removeEventListener("sessionstart",Ct),bt.removeEventListener("sessionend",Et),B&&(B.dispose(),B=null),At.stop()},this.renderBufferDirect=function(t,e,n,r,i,s){null===e&&(e=G);const a=i.isMesh&&i.matrixWorld.determinant()<0,o=function(t,e,n,r,i){!0!==e.isScene&&(e=G),Z.resetTextureUnits();const s=e.fog,a=r.isMeshStandardMaterial?e.environment:null,o=null===_?g.outputEncoding:!0===_.isXRRenderTarget?_.texture.encoding:Fe,l=(r.isMeshStandardMaterial?Q:J).get(r.envMap||a),u=!0===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,c=!!r.normalMap&&!!n.attributes.tangent,h=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,f=!!n.morphAttributes.color,m=r.toneMapped?g.toneMapping:et,x=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,y=void 0!==x?x.length:0,v=Y.get(r),b=p.state.lights;if(!0===O&&(!0===z||t!==k)){const e=t===k&&r.id===I;lt.setState(r,t,e)}let w=!1;r.version===v.__version?v.needsLights&&v.lightsStateVersion!==b.state.version||v.outputEncoding!==o||i.isInstancedMesh&&!1===v.instancing?w=!0:i.isInstancedMesh||!0!==v.instancing?i.isSkinnedMesh&&!1===v.skinning?w=!0:i.isSkinnedMesh||!0!==v.skinning?v.envMap!==l||!0===r.fog&&v.fog!==s?w=!0:void 0===v.numClippingPlanes||v.numClippingPlanes===lt.numPlanes&&v.numIntersection===lt.numIntersection?(v.vertexAlphas!==u||v.vertexTangents!==c||v.morphTargets!==h||v.morphNormals!==d||v.morphColors!==f||v.toneMapping!==m||!0===q.isWebGL2&&v.morphTargetsCount!==y)&&(w=!0):w=!0:w=!0:w=!0:(w=!0,v.__version=r.version);let S=v.currentProgram;!0===w&&(S=Pt(r,e,i));let M=!1,T=!1,C=!1;const E=S.getUniforms(),R=v.uniforms;if(X.useProgram(S.program)&&(M=!0,T=!0,C=!0),r.id!==I&&(I=r.id,T=!0),M||k!==t){if(E.setValue(xt,"projectionMatrix",t.projectionMatrix),q.logarithmicDepthBuffer&&E.setValue(xt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),k!==t&&(k=t,T=!0,C=!0),r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){const e=E.map.cameraPosition;void 0!==e&&e.setValue(xt,V.setFromMatrixPosition(t.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&E.setValue(xt,"isOrthographic",!0===t.isOrthographicCamera),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||i.isSkinnedMesh)&&E.setValue(xt,"viewMatrix",t.matrixWorldInverse)}if(i.isSkinnedMesh){E.setOptional(xt,i,"bindMatrix"),E.setOptional(xt,i,"bindMatrixInverse");const t=i.skeleton;t&&(q.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),E.setValue(xt,"boneTexture",t.boneTexture,Z),E.setValue(xt,"boneTextureSize",t.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const D=n.morphAttributes;var L,F;if((void 0!==D.position||void 0!==D.normal||void 0!==D.color&&!0===q.isWebGL2)&&ht.update(i,n,r,S),(T||v.receiveShadow!==i.receiveShadow)&&(v.receiveShadow=i.receiveShadow,E.setValue(xt,"receiveShadow",i.receiveShadow)),T&&(E.setValue(xt,"toneMappingExposure",g.toneMappingExposure),v.needsLights&&(F=C,(L=R).ambientLightColor.needsUpdate=F,L.lightProbe.needsUpdate=F,L.directionalLights.needsUpdate=F,L.directionalLightShadows.needsUpdate=F,L.pointLights.needsUpdate=F,L.pointLightShadows.needsUpdate=F,L.spotLights.needsUpdate=F,L.spotLightShadows.needsUpdate=F,L.rectAreaLights.needsUpdate=F,L.hemisphereLights.needsUpdate=F),s&&!0===r.fog&&st.refreshFogUniforms(R,s),st.refreshMaterialUniforms(R,r,N,A,B),go.upload(xt,v.uniformsList,R,Z)),r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(go.upload(xt,v.uniformsList,R,Z),r.uniformsNeedUpdate=!1),r.isSpriteMaterial&&E.setValue(xt,"center",i.center),E.setValue(xt,"modelViewMatrix",i.modelViewMatrix),E.setValue(xt,"normalMatrix",i.normalMatrix),E.setValue(xt,"modelMatrix",i.matrixWorld),r.isShaderMaterial||r.isRawShaderMaterial){const t=r.uniformsGroups;for(let e=0,n=t.length;e<n;e++)if(q.isWebGL2){const n=t[e];gt.update(n,S),gt.bind(n,S)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return S}(t,e,n,r,i);X.setMaterial(r,a);let l=n.index;const u=n.attributes.position;if(null===l){if(void 0===u||0===u.count)return}else if(0===l.count)return;let c,h=1;!0===r.wireframe&&(l=nt.getWireframeAttribute(n),h=2),mt.setup(i,r,o,n,l);let d=dt;null!==l&&(c=tt.get(l),d=pt,d.setIndex(c));const f=null!==l?l.count:u.count,m=n.drawRange.start*h,x=n.drawRange.count*h,y=null!==s?s.start*h:0,v=null!==s?s.count*h:1/0,b=Math.max(m,y),w=Math.min(f,m+x,y+v)-1,S=Math.max(0,w-b+1);if(0!==S){if(i.isMesh)!0===r.wireframe?(X.setLineWidth(r.wireframeLinewidth*H()),d.setMode(1)):d.setMode(4);else if(i.isLine){let t=r.linewidth;void 0===t&&(t=1),X.setLineWidth(t*H()),i.isLineSegments?d.setMode(1):i.isLineLoop?d.setMode(2):d.setMode(3)}else i.isPoints?d.setMode(0):i.isSprite&&d.setMode(4);if(i.isInstancedMesh)d.renderInstances(b,S,i.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(b,S,t)}else d.render(b,S)}},this.compile=function(t,e){p=ot.get(t),p.init(),m.push(p),t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(p.pushLight(t),t.castShadow&&p.pushShadow(t))})),p.setupLights(g.physicallyCorrectLights),t.traverse((function(e){const n=e.material;if(n)if(Array.isArray(n))for(let r=0;r<n.length;r++)Pt(n[r],t,e);else Pt(n,t,e)})),m.pop(),p=null};let Tt=null;function Ct(){At.stop()}function Et(){At.start()}const At=new As;function Nt(t,e,n,r){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)p.pushLight(t),t.castShadow&&p.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||P.intersectsSprite(t)){r&&V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);const e=rt.update(t),i=t.material;i.visible&&d.push(t,e,i,n,V.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==K.render.frame&&(t.skeleton.update(),t.skeleton.frame=K.render.frame),!t.frustumCulled||P.intersectsObject(t))){r&&V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);const e=rt.update(t),i=t.material;if(Array.isArray(i)){const r=e.groups;for(let s=0,a=r.length;s<a;s++){const a=r[s],o=i[a.materialIndex];o&&o.visible&&d.push(t,e,o,n,V.z,a)}}else i.visible&&d.push(t,e,i,n,V.z,null)}const i=t.children;for(let t=0,s=i.length;t<s;t++)Nt(i[t],e,n,r)}function Lt(t,e,n,r){const i=t.opaque,a=t.transmissive,o=t.transparent;p.setupLightsView(n),a.length>0&&function(t,e,n){const r=q.isWebGL2;null===B&&(B=new nr(1,1,{generateMipmaps:!0,type:j.has("EXT_color_buffer_half_float")?Dt:Mt,minFilter:It,samples:r&&!0===s?4:0})),g.getDrawingBufferSize(W),r?B.setSize(W.x,W.y):B.setSize(An(W.x),An(W.y));const i=g.getRenderTarget();g.setRenderTarget(B),g.clear();const a=g.toneMapping;g.toneMapping=et,Ft(t,e,n),g.toneMapping=a,Z.updateMultisampleRenderTarget(B),Z.updateRenderTargetMipmap(B),g.setRenderTarget(i)}(i,e,n),r&&X.viewport(M.copy(r)),i.length>0&&Ft(i,e,n),a.length>0&&Ft(a,e,n),o.length>0&&Ft(o,e,n),X.buffers.depth.setTest(!0),X.buffers.depth.setMask(!0),X.buffers.color.setMask(!0),X.setPolygonOffset(!1)}function Ft(t,e,n){const r=!0===e.isScene?e.overrideMaterial:null;for(let i=0,s=t.length;i<s;i++){const s=t[i],a=s.object,o=s.geometry,l=null===r?s.material:r,u=s.group;a.layers.test(n.layers)&&$t(a,e,n,o,l,u)}}function $t(t,e,n,r,i,s){t.onBeforeRender(g,e,n,r,i,s),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),i.onBeforeRender(g,e,n,r,t,s),!0===i.transparent&&i.side===v?(i.side=y,i.needsUpdate=!0,g.renderBufferDirect(n,e,r,i,t,s),i.side=x,i.needsUpdate=!0,g.renderBufferDirect(n,e,r,i,t,s),i.side=v):g.renderBufferDirect(n,e,r,i,t,s),t.onAfterRender(g,e,n,r,i,s)}function Pt(t,e,n){!0!==e.isScene&&(e=G);const r=Y.get(t),i=p.state.lights,s=p.state.shadowsArray,a=i.state.version,o=it.getParameters(t,i.state,s,e,n),l=it.getProgramCacheKey(o);let u=r.programs;r.environment=t.isMeshStandardMaterial?e.environment:null,r.fog=e.fog,r.envMap=(t.isMeshStandardMaterial?Q:J).get(t.envMap||r.environment),void 0===u&&(t.addEventListener("dispose",kt),u=new Map,r.programs=u);let c=u.get(l);if(void 0!==c){if(r.currentProgram===c&&r.lightsStateVersion===a)return Ot(t,o),c}else o.uniforms=it.getUniforms(t),t.onBuild(n,o,g),t.onBeforeCompile(o,g),c=it.acquireProgram(o,l),u.set(l,c),r.uniforms=o.uniforms;const h=r.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(h.clippingPlanes=lt.uniform),Ot(t,o),r.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),r.lightsStateVersion=a,r.needsLights&&(h.ambientLightColor.value=i.state.ambient,h.lightProbe.value=i.state.probe,h.directionalLights.value=i.state.directional,h.directionalLightShadows.value=i.state.directionalShadow,h.spotLights.value=i.state.spot,h.spotLightShadows.value=i.state.spotShadow,h.rectAreaLights.value=i.state.rectArea,h.ltc_1.value=i.state.rectAreaLTC1,h.ltc_2.value=i.state.rectAreaLTC2,h.pointLights.value=i.state.point,h.pointLightShadows.value=i.state.pointShadow,h.hemisphereLights.value=i.state.hemi,h.directionalShadowMap.value=i.state.directionalShadowMap,h.directionalShadowMatrix.value=i.state.directionalShadowMatrix,h.spotShadowMap.value=i.state.spotShadowMap,h.spotShadowMatrix.value=i.state.spotShadowMatrix,h.pointShadowMap.value=i.state.pointShadowMap,h.pointShadowMatrix.value=i.state.pointShadowMatrix);const d=c.getUniforms(),f=go.seqWithValue(d.seq,h);return r.currentProgram=c,r.uniformsList=f,c}function Ot(t,e){const n=Y.get(t);n.outputEncoding=e.outputEncoding,n.instancing=e.instancing,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.morphColors=e.morphColors,n.morphTargetsCount=e.morphTargetsCount,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents,n.toneMapping=e.toneMapping}At.setAnimationLoop((function(t){Tt&&Tt(t)})),"undefined"!=typeof self&&At.setContext(self),this.setAnimationLoop=function(t){Tt=t,bt.setAnimationLoop(t),null===t?At.stop():At.start()},bt.addEventListener("sessionstart",Ct),bt.addEventListener("sessionend",Et),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===b)return;!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===bt.enabled&&!0===bt.isPresenting&&(!0===bt.cameraAutoUpdate&&bt.updateCamera(e),e=bt.getCamera()),!0===t.isScene&&t.onBeforeRender(g,t,e,_),p=ot.get(t,m.length),p.init(),m.push(p),U.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),P.setFromProjectionMatrix(U),z=this.localClippingEnabled,O=lt.init(this.clippingPlanes,z,e),d=at.get(t,f.length),d.init(),f.push(d),Nt(t,e,0,g.sortObjects),d.finish(),!0===g.sortObjects&&d.sort(R,D),!0===O&&lt.beginShadows();const n=p.state.shadowsArray;if(ut.render(n,t,e),!0===O&&lt.endShadows(),!0===this.info.autoReset&&this.info.reset(),ct.render(d,t),p.setupLights(g.physicallyCorrectLights),e.isArrayCamera){const n=e.cameras;for(let e=0,r=n.length;e<r;e++){const r=n[e];Lt(d,t,r,r.viewport)}}else Lt(d,t,e);null!==_&&(Z.updateMultisampleRenderTarget(_),Z.updateRenderTargetMipmap(_)),!0===t.isScene&&t.onAfterRender(g,t,e),mt.resetDefaultState(),I=-1,k=null,m.pop(),p=m.length>0?m[m.length-1]:null,f.pop(),d=f.length>0?f[f.length-1]:null},this.getActiveCubeFace=function(){return w},this.getActiveMipmapLevel=function(){return S},this.getRenderTarget=function(){return _},this.setRenderTargetTextures=function(t,e,n){Y.get(t.texture).__webglTexture=e,Y.get(t.depthTexture).__webglTexture=n;const r=Y.get(t);r.__hasExternalTextures=!0,r.__hasExternalTextures&&(r.__autoAllocateDepthBuffer=void 0===n,r.__autoAllocateDepthBuffer||!0===j.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),r.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(t,e){const n=Y.get(t);n.__webglFramebuffer=e,n.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(t,e=0,n=0){_=t,w=e,S=n;let r=!0;if(t){const e=Y.get(t);void 0!==e.__useDefaultFramebuffer?(X.bindFramebuffer(36160,null),r=!1):void 0===e.__webglFramebuffer?Z.setupRenderTarget(t):e.__hasExternalTextures&&Z.rebindTextures(t,Y.get(t.texture).__webglTexture,Y.get(t.depthTexture).__webglTexture)}let i=null,s=!1,a=!1;if(t){const n=t.texture;(n.isData3DTexture||n.isDataArrayTexture)&&(a=!0);const r=Y.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(i=r[e],s=!0):i=q.isWebGL2&&t.samples>0&&!1===Z.useMultisampledRTT(t)?Y.get(t).__webglMultisampledFramebuffer:r,M.copy(t.viewport),T.copy(t.scissor),C=t.scissorTest}else M.copy(L).multiplyScalar(N).floor(),T.copy(F).multiplyScalar(N).floor(),C=$;if(X.bindFramebuffer(36160,i)&&q.drawBuffers&&r&&X.drawBuffers(t,i),X.viewport(M),X.scissor(T),X.setScissorTest(C),s){const r=Y.get(t.texture);xt.framebufferTexture2D(36160,36064,34069+e,r.__webglTexture,n)}else if(a){const r=Y.get(t.texture),i=e||0;xt.framebufferTextureLayer(36160,36064,r.__webglTexture,n||0,i)}I=-1},this.readRenderTargetPixels=function(t,e,n,r,i,s,a){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=Y.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){X.bindFramebuffer(36160,o);try{const a=t.texture,o=a.format,l=a.type;if(o!==zt&&ft.convert(o)!==xt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const u=l===Dt&&(j.has("EXT_color_buffer_half_float")||q.isWebGL2&&j.has("EXT_color_buffer_float"));if(!(l===Mt||ft.convert(l)===xt.getParameter(35738)||l===Rt&&(q.isWebGL2||j.has("OES_texture_float")||j.has("WEBGL_color_buffer_float"))||u))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=t.width-r&&n>=0&&n<=t.height-i&&xt.readPixels(e,n,r,i,ft.convert(o),ft.convert(l),s)}finally{const t=null!==_?Y.get(_).__webglFramebuffer:null;X.bindFramebuffer(36160,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){const r=Math.pow(2,-n),i=Math.floor(e.image.width*r),s=Math.floor(e.image.height*r);Z.setTexture2D(e,0),xt.copyTexSubImage2D(3553,n,0,0,t.x,t.y,i,s),X.unbindTexture()},this.copyTextureToTexture=function(t,e,n,r=0){const i=e.image.width,s=e.image.height,a=ft.convert(n.format),o=ft.convert(n.type);Z.setTexture2D(n,0),xt.pixelStorei(37440,n.flipY),xt.pixelStorei(37441,n.premultiplyAlpha),xt.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?xt.texSubImage2D(3553,r,t.x,t.y,i,s,a,o,e.image.data):e.isCompressedTexture?xt.compressedTexSubImage2D(3553,r,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,a,e.mipmaps[0].data):xt.texSubImage2D(3553,r,t.x,t.y,a,o,e.image),0===r&&n.generateMipmaps&&xt.generateMipmap(3553),X.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,r,i=0){if(g.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=t.max.x-t.min.x+1,a=t.max.y-t.min.y+1,o=t.max.z-t.min.z+1,l=ft.convert(r.format),u=ft.convert(r.type);let c;if(r.isData3DTexture)Z.setTexture3D(r,0),c=32879;else{if(!r.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");Z.setTexture2DArray(r,0),c=35866}xt.pixelStorei(37440,r.flipY),xt.pixelStorei(37441,r.premultiplyAlpha),xt.pixelStorei(3317,r.unpackAlignment);const h=xt.getParameter(3314),d=xt.getParameter(32878),p=xt.getParameter(3316),f=xt.getParameter(3315),m=xt.getParameter(32877),x=n.isCompressedTexture?n.mipmaps[0]:n.image;xt.pixelStorei(3314,x.width),xt.pixelStorei(32878,x.height),xt.pixelStorei(3316,t.min.x),xt.pixelStorei(3315,t.min.y),xt.pixelStorei(32877,t.min.z),n.isDataTexture||n.isData3DTexture?xt.texSubImage3D(c,i,e.x,e.y,e.z,s,a,o,l,u,x.data):n.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),xt.compressedTexSubImage3D(c,i,e.x,e.y,e.z,s,a,o,l,x.data)):xt.texSubImage3D(c,i,e.x,e.y,e.z,s,a,o,l,u,x),xt.pixelStorei(3314,h),xt.pixelStorei(32878,d),xt.pixelStorei(3316,p),xt.pixelStorei(3315,f),xt.pixelStorei(32877,m),0===i&&r.generateMipmaps&&xt.generateMipmap(c),X.unbindTexture()},this.initTexture=function(t){t.isCubeTexture?Z.setTextureCube(t,0):t.isData3DTexture?Z.setTexture3D(t,0):t.isDataArrayTexture?Z.setTexture2DArray(t,0):Z.setTexture2D(t,0),X.unbindTexture()},this.resetState=function(){w=0,S=0,_=null,X.reset(),mt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class pl extends dl{}pl.prototype.isWebGL1Renderer=!0;class fl{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new Xn(t),this.density=e}clone(){return new fl(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class ml{constructor(t,e=1,n=1e3){this.isFog=!0,this.name="",this.color=new Xn(t),this.near=e,this.far=n}clone(){return new ml(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class gl extends hi{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}class xl{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=on,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=In()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let r=0,i=this.stride;r<i;r++)this.array[t+r]=e.array[n+r];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=In()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=In()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const yl=new ur;class vl{constructor(t,e,n,r=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)yl.fromBufferAttribute(this,e),yl.applyMatrix4(t),this.setXYZ(e,yl.x,yl.y,yl.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)yl.fromBufferAttribute(this,e),yl.applyNormalMatrix(t),this.setXYZ(e,yl.x,yl.y,yl.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)yl.fromBufferAttribute(this,e),yl.transformDirection(t),this.setXYZ(e,yl.x,yl.y,yl.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this}setXYZW(t,e,n,r,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this.data.array[t+3]=i,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new Ci(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new vl(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class bl extends Ii{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Xn(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let wl;const Sl=new ur,_l=new ur,Il=new ur,kl=new Rn,Ml=new Rn,Tl=new Br,Cl=new ur,El=new ur,Al=new ur,Nl=new Rn,Rl=new Rn,Dl=new Rn;class Ll extends hi{constructor(t){if(super(),this.isSprite=!0,this.type="Sprite",void 0===wl){wl=new ji;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new xl(t,5);wl.setIndex([0,1,2,0,2,3]),wl.setAttribute("position",new vl(e,3,0,!1)),wl.setAttribute("uv",new vl(e,2,3,!1))}this.geometry=wl,this.material=void 0!==t?t:new bl,this.center=new Rn(.5,.5)}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),_l.setFromMatrixScale(this.matrixWorld),Tl.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Il.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&_l.multiplyScalar(-Il.z);const n=this.material.rotation;let r,i;0!==n&&(i=Math.cos(n),r=Math.sin(n));const s=this.center;Fl(Cl.set(-.5,-.5,0),Il,s,_l,r,i),Fl(El.set(.5,-.5,0),Il,s,_l,r,i),Fl(Al.set(.5,.5,0),Il,s,_l,r,i),Nl.set(0,0),Rl.set(1,0),Dl.set(1,1);let a=t.ray.intersectTriangle(Cl,El,Al,!1,Sl);if(null===a&&(Fl(El.set(-.5,.5,0),Il,s,_l,r,i),Rl.set(0,1),a=t.ray.intersectTriangle(Cl,Al,El,!1,Sl),null===a))return;const o=t.ray.origin.distanceTo(Sl);o<t.near||o>t.far||e.push({distance:o,point:Sl.clone(),uv:Si.getUV(Sl,Cl,El,Al,Nl,Rl,Dl,new Rn),face:null,object:this})}copy(t,e){return super.copy(t,e),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function Fl(t,e,n,r,i,s){kl.subVectors(t,n).addScalar(.5).multiply(r),void 0!==i?(Ml.x=s*kl.x-i*kl.y,Ml.y=i*kl.x+s*kl.y):Ml.copy(kl),t.copy(e),t.x+=Ml.x,t.y+=Ml.y,t.applyMatrix4(Tl)}const $l=new ur,Pl=new ur;class Ol extends hi{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.addLevel(n.object.clone(),n.distance)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0){e=Math.abs(e);const n=this.levels;let r;for(r=0;r<n.length&&!(e<n[r].distance);r++);return n.splice(r,0,{distance:e,object:t}),this.add(t),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,r;for(n=1,r=e.length;n<r&&!(t<e[n].distance);n++);return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){$l.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo($l);this.getObjectForDistance(n).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){$l.setFromMatrixPosition(t.matrixWorld),Pl.setFromMatrixPosition(this.matrixWorld);const n=$l.distanceTo(Pl)/t.zoom;let r,i;for(e[0].object.visible=!0,r=1,i=e.length;r<i&&n>=e[r].distance;r++)e[r-1].object.visible=!1,e[r].object.visible=!0;for(this._currentLevel=r-1;r<i;r++)e[r].object.visible=!1}}toJSON(t){const e=super.toJSON(t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let t=0,r=n.length;t<r;t++){const r=n[t];e.object.levels.push({object:r.object.uuid,distance:r.distance})}return e}}const zl=new ur,Bl=new er,Ul=new er,Wl=new ur,Vl=new Br;class Gl extends cs{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Br,this.bindMatrixInverse=new Br}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new er,e=this.geometry.attributes.skinWeight;for(let n=0,r=e.count;n<r;n++){t.fromBufferAttribute(e,n);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,r=this.geometry;Bl.fromBufferAttribute(r.attributes.skinIndex,t),Ul.fromBufferAttribute(r.attributes.skinWeight,t),zl.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const r=Ul.getComponent(t);if(0!==r){const i=Bl.getComponent(t);Vl.multiplyMatrices(n.bones[i].matrixWorld,n.boneInverses[i]),e.addScaledVector(Wl.copy(zl).applyMatrix4(Vl),r)}}return e.applyMatrix4(this.bindMatrixInverse)}}class Hl extends hi{constructor(){super(),this.isBone=!0,this.type="Bone"}}class jl extends tr{constructor(t=null,e=1,n=1,r,i,s,a,o,l=gt,u=gt,c,h){super(null,s,a,o,l,u,r,i,c,h),this.isDataTexture=!0,this.image={data:t,width:e,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const ql=new Br,Xl=new Br;class Kl{constructor(t=[],e=[]){this.uuid=In(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new Br)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new Br;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,r=this.boneTexture;for(let r=0,i=t.length;r<i;r++){const i=t[r]?t[r].matrixWorld:Xl;ql.multiplyMatrices(i,e[r]),ql.toArray(n,16*r)}null!==r&&(r.needsUpdate=!0)}clone(){return new Kl(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=En(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new jl(e,t,t,zt,Rt);return n.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=n,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,r=t.bones.length;n<r;n++){const r=t.bones[n];let i=e[r];void 0===i&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),i=new Hl),this.bones.push(i),this.boneInverses.push((new Br).fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let r=0,i=e.length;r<i;r++){const i=e[r];t.bones.push(i.uuid);const s=n[r];t.boneInverses.push(s.toArray())}return t}}class Yl extends Ci{constructor(t,e,n,r=1){"number"==typeof n&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=r}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const Zl=new Br,Jl=new Br,Ql=[],tu=new cs;class eu extends cs{constructor(t,e,n){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Yl(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const n=this.matrixWorld,r=this.count;if(tu.geometry=this.geometry,tu.material=this.material,void 0!==tu.material)for(let i=0;i<r;i++){this.getMatrixAt(i,Zl),Jl.multiplyMatrices(n,Zl),tu.matrixWorld=Jl,tu.raycast(t,Ql);for(let t=0,n=Ql.length;t<n;t++){const n=Ql[t];n.instanceId=i,n.object=this,e.push(n)}Ql.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new Yl(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class nu extends Ii{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Xn(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const ru=new ur,iu=new ur,su=new Br,au=new zr,ou=new Nr;class lu extends hi{constructor(t=new ji,e=new nu){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,r=e.count;t<r;t++)ru.fromBufferAttribute(e,t-1),iu.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=ru.distanceTo(iu);t.setAttribute("lineDistance",new Pi(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,i=t.params.Line.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),ou.copy(n.boundingSphere),ou.applyMatrix4(r),ou.radius+=i,!1===t.ray.intersectsSphere(ou))return;su.copy(r).invert(),au.copy(t.ray).applyMatrix4(su);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=new ur,u=new ur,c=new ur,h=new ur,d=this.isLineSegments?2:1,p=n.index,f=n.attributes.position;if(null!==p)for(let n=Math.max(0,s.start),r=Math.min(p.count,s.start+s.count)-1;n<r;n+=d){const r=p.getX(n),i=p.getX(n+1);if(l.fromBufferAttribute(f,r),u.fromBufferAttribute(f,i),au.distanceSqToSegment(l,u,h,c)>o)continue;h.applyMatrix4(this.matrixWorld);const s=t.ray.origin.distanceTo(h);s<t.near||s>t.far||e.push({distance:s,point:c.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}else for(let n=Math.max(0,s.start),r=Math.min(f.count,s.start+s.count)-1;n<r;n+=d){if(l.fromBufferAttribute(f,n),u.fromBufferAttribute(f,n+1),au.distanceSqToSegment(l,u,h,c)>o)continue;h.applyMatrix4(this.matrixWorld);const r=t.ray.origin.distanceTo(h);r<t.near||r>t.far||e.push({distance:r,point:c.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}const uu=new ur,cu=new ur;class hu extends lu{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,r=e.count;t<r;t+=2)uu.fromBufferAttribute(e,t),cu.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+uu.distanceTo(cu);t.setAttribute("lineDistance",new Pi(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class du extends lu{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class pu extends Ii{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Xn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const fu=new Br,mu=new zr,gu=new Nr,xu=new ur;class yu extends hi{constructor(t=new ji,e=new pu){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,i=t.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),gu.copy(n.boundingSphere),gu.applyMatrix4(r),gu.radius+=i,!1===t.ray.intersectsSphere(gu))return;fu.copy(r).invert(),mu.copy(t.ray).applyMatrix4(fu);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=n.index,u=n.attributes.position;if(null!==l)for(let n=Math.max(0,s.start),i=Math.min(l.count,s.start+s.count);n<i;n++){const i=l.getX(n);xu.fromBufferAttribute(u,i),vu(xu,i,o,r,t,e,this)}else for(let n=Math.max(0,s.start),i=Math.min(u.count,s.start+s.count);n<i;n++)xu.fromBufferAttribute(u,n),vu(xu,n,o,r,t,e,this)}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function vu(t,e,n,r,i,s,a){const o=mu.distanceSqToPoint(t);if(o<n){const n=new ur;mu.closestPointToPoint(t,n),n.applyMatrix4(r);const l=i.ray.origin.distanceTo(n);if(l<i.near||l>i.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:e,face:null,object:a})}}class bu extends tr{constructor(t,e,n,r,i,s,a,o,l){super(t,e,n,r,i,s,a,o,l),this.isVideoTexture=!0,this.minFilter=void 0!==s?s:wt,this.magFilter=void 0!==i?i:wt,this.generateMipmaps=!1;const u=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){u.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class wu extends tr{constructor(t,e,n){super({width:t,height:e}),this.isFramebufferTexture=!0,this.format=n,this.magFilter=gt,this.minFilter=gt,this.generateMipmaps=!1,this.needsUpdate=!0}}class Su extends tr{constructor(t,e,n,r,i,s,a,o,l,u,c,h){super(null,s,a,o,l,u,r,i,c,h),this.isCompressedTexture=!0,this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class _u extends tr{constructor(t,e,n,r,i,s,a,o,l){super(t,e,n,r,i,s,a,o,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Iu{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,r=this.getPoint(0),i=0;e.push(0);for(let s=1;s<=t;s++)n=this.getPoint(s/t),i+=n.distanceTo(r),e.push(i),r=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let r=0;const i=n.length;let s;s=e||t*n[i-1];let a,o=0,l=i-1;for(;o<=l;)if(r=Math.floor(o+(l-o)/2),a=n[r]-s,a<0)o=r+1;else{if(!(a>0)){l=r;break}l=r-1}if(r=l,n[r]===s)return r/(i-1);const u=n[r];return(r+(s-u)/(n[r+1]-u))/(i-1)}getTangent(t,e){const n=1e-4;let r=t-n,i=t+n;r<0&&(r=0),i>1&&(i=1);const s=this.getPoint(r),a=this.getPoint(i),o=e||(s.isVector2?new Rn:new ur);return o.copy(a).sub(s).normalize(),o}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new ur,r=[],i=[],s=[],a=new ur,o=new Br;for(let e=0;e<=t;e++){const n=e/t;r[e]=this.getTangentAt(n,new ur)}i[0]=new ur,s[0]=new ur;let l=Number.MAX_VALUE;const u=Math.abs(r[0].x),c=Math.abs(r[0].y),h=Math.abs(r[0].z);u<=l&&(l=u,n.set(1,0,0)),c<=l&&(l=c,n.set(0,1,0)),h<=l&&n.set(0,0,1),a.crossVectors(r[0],n).normalize(),i[0].crossVectors(r[0],a),s[0].crossVectors(r[0],i[0]);for(let e=1;e<=t;e++){if(i[e]=i[e-1].clone(),s[e]=s[e-1].clone(),a.crossVectors(r[e-1],r[e]),a.length()>Number.EPSILON){a.normalize();const t=Math.acos(kn(r[e-1].dot(r[e]),-1,1));i[e].applyMatrix4(o.makeRotationAxis(a,t))}s[e].crossVectors(r[e],i[e])}if(!0===e){let e=Math.acos(kn(i[0].dot(i[t]),-1,1));e/=t,r[0].dot(a.crossVectors(i[0],i[t]))>0&&(e=-e);for(let n=1;n<=t;n++)i[n].applyMatrix4(o.makeRotationAxis(r[n],e*n)),s[n].crossVectors(r[n],i[n])}return{tangents:r,normals:i,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class ku extends Iu{constructor(t=0,e=0,n=1,r=1,i=0,s=2*Math.PI,a=!1,o=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=r,this.aStartAngle=i,this.aEndAngle=s,this.aClockwise=a,this.aRotation=o}getPoint(t,e){const n=e||new Rn,r=2*Math.PI;let i=this.aEndAngle-this.aStartAngle;const s=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=r;for(;i>r;)i-=r;i<Number.EPSILON&&(i=s?0:r),!0!==this.aClockwise||s||(i===r?i=-r:i-=r);const a=this.aStartAngle+t*i;let o=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=o-this.aX,r=l-this.aY;o=n*t-r*e+this.aX,l=n*e+r*t+this.aY}return n.set(o,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class Mu extends ku{constructor(t,e,n,r,i,s){super(t,e,n,n,r,i,s),this.isArcCurve=!0,this.type="ArcCurve"}}function Tu(){let t=0,e=0,n=0,r=0;function i(i,s,a,o){t=i,e=a,n=-3*i+3*s-2*a-o,r=2*i-2*s+a+o}return{initCatmullRom:function(t,e,n,r,s){i(e,n,s*(n-t),s*(r-e))},initNonuniformCatmullRom:function(t,e,n,r,s,a,o){let l=(e-t)/s-(n-t)/(s+a)+(n-e)/a,u=(n-e)/a-(r-e)/(a+o)+(r-n)/o;l*=a,u*=a,i(e,n,l,u)},calc:function(i){const s=i*i;return t+e*i+n*s+r*(s*i)}}}const Cu=new ur,Eu=new Tu,Au=new Tu,Nu=new Tu;class Ru extends Iu{constructor(t=[],e=!1,n="centripetal",r=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=r}getPoint(t,e=new ur){const n=e,r=this.points,i=r.length,s=(i-(this.closed?0:1))*t;let a,o,l=Math.floor(s),u=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/i)+1)*i:0===u&&l===i-1&&(l=i-2,u=1),this.closed||l>0?a=r[(l-1)%i]:(Cu.subVectors(r[0],r[1]).add(r[0]),a=Cu);const c=r[l%i],h=r[(l+1)%i];if(this.closed||l+2<i?o=r[(l+2)%i]:(Cu.subVectors(r[i-1],r[i-2]).add(r[i-1]),o=Cu),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(a.distanceToSquared(c),t),n=Math.pow(c.distanceToSquared(h),t),r=Math.pow(h.distanceToSquared(o),t);n<1e-4&&(n=1),e<1e-4&&(e=n),r<1e-4&&(r=n),Eu.initNonuniformCatmullRom(a.x,c.x,h.x,o.x,e,n,r),Au.initNonuniformCatmullRom(a.y,c.y,h.y,o.y,e,n,r),Nu.initNonuniformCatmullRom(a.z,c.z,h.z,o.z,e,n,r)}else"catmullrom"===this.curveType&&(Eu.initCatmullRom(a.x,c.x,h.x,o.x,this.tension),Au.initCatmullRom(a.y,c.y,h.y,o.y,this.tension),Nu.initCatmullRom(a.z,c.z,h.z,o.z,this.tension));return n.set(Eu.calc(u),Au.calc(u),Nu.calc(u)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new ur).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function Du(t,e,n,r,i){const s=.5*(r-e),a=.5*(i-n),o=t*t;return(2*n-2*r+s+a)*(t*o)+(-3*n+3*r-2*s-a)*o+s*t+n}function Lu(t,e,n,r){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,r)}function Fu(t,e,n,r,i){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,r)+function(t,e){return t*t*t*e}(t,i)}class $u extends Iu{constructor(t=new Rn,e=new Rn,n=new Rn,r=new Rn){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new Rn){const n=e,r=this.v0,i=this.v1,s=this.v2,a=this.v3;return n.set(Fu(t,r.x,i.x,s.x,a.x),Fu(t,r.y,i.y,s.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class Pu extends Iu{constructor(t=new ur,e=new ur,n=new ur,r=new ur){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new ur){const n=e,r=this.v0,i=this.v1,s=this.v2,a=this.v3;return n.set(Fu(t,r.x,i.x,s.x,a.x),Fu(t,r.y,i.y,s.y,a.y),Fu(t,r.z,i.z,s.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class Ou extends Iu{constructor(t=new Rn,e=new Rn){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new Rn){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new Rn;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class zu extends Iu{constructor(t=new ur,e=new ur){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new ur){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Bu extends Iu{constructor(t=new Rn,e=new Rn,n=new Rn){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new Rn){const n=e,r=this.v0,i=this.v1,s=this.v2;return n.set(Lu(t,r.x,i.x,s.x),Lu(t,r.y,i.y,s.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Uu extends Iu{constructor(t=new ur,e=new ur,n=new ur){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new ur){const n=e,r=this.v0,i=this.v1,s=this.v2;return n.set(Lu(t,r.x,i.x,s.x),Lu(t,r.y,i.y,s.y),Lu(t,r.z,i.z,s.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Wu extends Iu{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new Rn){const n=e,r=this.points,i=(r.length-1)*t,s=Math.floor(i),a=i-s,o=r[0===s?s:s-1],l=r[s],u=r[s>r.length-2?r.length-1:s+1],c=r[s>r.length-3?r.length-1:s+2];return n.set(Du(a,o.x,l.x,u.x,c.x),Du(a,o.y,l.y,u.y,c.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new Rn).fromArray(n))}return this}}var Vu=Object.freeze({__proto__:null,ArcCurve:Mu,CatmullRomCurve3:Ru,CubicBezierCurve:$u,CubicBezierCurve3:Pu,EllipseCurve:ku,LineCurve:Ou,LineCurve3:zu,QuadraticBezierCurve:Bu,QuadraticBezierCurve3:Uu,SplineCurve:Wu});class Gu extends Iu{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new Ou(e,t))}getPoint(t,e){const n=t*this.getLength(),r=this.getCurveLengths();let i=0;for(;i<r.length;){if(r[i]>=n){const t=r[i]-n,s=this.curves[i],a=s.getLength(),o=0===a?0:1-t/a;return s.getPointAt(o,e)}i++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,r=this.curves.length;n<r;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let r=0,i=this.curves;r<i.length;r++){const s=i[r],a=s.isEllipseCurve?2*t:s.isLineCurve||s.isLineCurve3?1:s.isSplineCurve?t*s.points.length:t,o=s.getPoints(a);for(let t=0;t<o.length;t++){const r=o[t];n&&n.equals(r)||(e.push(r),n=r)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const n=this.curves[e];t.curves.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new Vu[n.type]).fromJSON(n))}return this}}class Hu extends Gu{constructor(t){super(),this.type="Path",this.currentPoint=new Rn,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new Ou(this.currentPoint.clone(),new Rn(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,r){const i=new Bu(this.currentPoint.clone(),new Rn(t,e),new Rn(n,r));return this.curves.push(i),this.currentPoint.set(n,r),this}bezierCurveTo(t,e,n,r,i,s){const a=new $u(this.currentPoint.clone(),new Rn(t,e),new Rn(n,r),new Rn(i,s));return this.curves.push(a),this.currentPoint.set(i,s),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Wu(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,r,i,s){const a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(t+a,e+o,n,r,i,s),this}absarc(t,e,n,r,i,s){return this.absellipse(t,e,n,n,r,i,s),this}ellipse(t,e,n,r,i,s,a,o){const l=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(t+l,e+u,n,r,i,s,a,o),this}absellipse(t,e,n,r,i,s,a,o){const l=new ku(t,e,n,r,i,s,a,o);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const u=l.getPoint(1);return this.currentPoint.copy(u),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class ju extends ji{constructor(t=[new Rn(0,-.5),new Rn(.5,0),new Rn(0,.5)],e=12,n=0,r=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:r},e=Math.floor(e),r=kn(r,0,2*Math.PI);const i=[],s=[],a=[],o=[],l=[],u=1/e,c=new ur,h=new Rn,d=new ur,p=new ur,f=new ur;let m=0,g=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,f.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case t.length-1:o.push(f.x,f.y,f.z);break;default:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,p.copy(d),d.x+=f.x,d.y+=f.y,d.z+=f.z,d.normalize(),o.push(d.x,d.y,d.z),f.copy(p)}for(let i=0;i<=e;i++){const d=n+i*u*r,p=Math.sin(d),f=Math.cos(d);for(let n=0;n<=t.length-1;n++){c.x=t[n].x*p,c.y=t[n].y,c.z=t[n].x*f,s.push(c.x,c.y,c.z),h.x=i/e,h.y=n/(t.length-1),a.push(h.x,h.y);const r=o[3*n+0]*p,u=o[3*n+1],d=o[3*n+0]*f;l.push(r,u,d)}}for(let n=0;n<e;n++)for(let e=0;e<t.length-1;e++){const r=e+n*t.length,s=r,a=r+t.length,o=r+t.length+1,l=r+1;i.push(s,a,l),i.push(o,l,a)}this.setIndex(i),this.setAttribute("position",new Pi(s,3)),this.setAttribute("uv",new Pi(a,2)),this.setAttribute("normal",new Pi(l,3))}static fromJSON(t){return new ju(t.points,t.segments,t.phiStart,t.phiLength)}}class qu extends ju{constructor(t=1,e=1,n=4,r=8){const i=new Hu;i.absarc(0,-e/2,t,1.5*Math.PI,0),i.absarc(0,e/2,t,0,.5*Math.PI),super(i.getPoints(n),r),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:n,radialSegments:r}}static fromJSON(t){return new qu(t.radius,t.length,t.capSegments,t.radialSegments)}}class Xu extends ji{constructor(t=1,e=8,n=0,r=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:r},e=Math.max(3,e);const i=[],s=[],a=[],o=[],l=new ur,u=new Rn;s.push(0,0,0),a.push(0,0,1),o.push(.5,.5);for(let i=0,c=3;i<=e;i++,c+=3){const h=n+i/e*r;l.x=t*Math.cos(h),l.y=t*Math.sin(h),s.push(l.x,l.y,l.z),a.push(0,0,1),u.x=(s[c]/t+1)/2,u.y=(s[c+1]/t+1)/2,o.push(u.x,u.y)}for(let t=1;t<=e;t++)i.push(t,t+1,0);this.setIndex(i),this.setAttribute("position",new Pi(s,3)),this.setAttribute("normal",new Pi(a,3)),this.setAttribute("uv",new Pi(o,2))}static fromJSON(t){return new Xu(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class Ku extends ji{constructor(t=1,e=1,n=1,r=8,i=1,s=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:r,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:o};const l=this;r=Math.floor(r),i=Math.floor(i);const u=[],c=[],h=[],d=[];let p=0;const f=[],m=n/2;let g=0;function x(n){const i=p,s=new Rn,f=new ur;let x=0;const y=!0===n?t:e,v=!0===n?1:-1;for(let t=1;t<=r;t++)c.push(0,m*v,0),h.push(0,v,0),d.push(.5,.5),p++;const b=p;for(let t=0;t<=r;t++){const e=t/r*o+a,n=Math.cos(e),i=Math.sin(e);f.x=y*i,f.y=m*v,f.z=y*n,c.push(f.x,f.y,f.z),h.push(0,v,0),s.x=.5*n+.5,s.y=.5*i*v+.5,d.push(s.x,s.y),p++}for(let t=0;t<r;t++){const e=i+t,r=b+t;!0===n?u.push(r,r+1,e):u.push(r+1,r,e),x+=3}l.addGroup(g,x,!0===n?1:2),g+=x}!function(){const s=new ur,x=new ur;let y=0;const v=(e-t)/n;for(let l=0;l<=i;l++){const u=[],g=l/i,y=g*(e-t)+t;for(let t=0;t<=r;t++){const e=t/r,i=e*o+a,l=Math.sin(i),f=Math.cos(i);x.x=y*l,x.y=-g*n+m,x.z=y*f,c.push(x.x,x.y,x.z),s.set(l,v,f).normalize(),h.push(s.x,s.y,s.z),d.push(e,1-g),u.push(p++)}f.push(u)}for(let t=0;t<r;t++)for(let e=0;e<i;e++){const n=f[e][t],r=f[e+1][t],i=f[e+1][t+1],s=f[e][t+1];u.push(n,r,s),u.push(r,i,s),y+=6}l.addGroup(g,y,0),g+=y}(),!1===s&&(t>0&&x(!0),e>0&&x(!1)),this.setIndex(u),this.setAttribute("position",new Pi(c,3)),this.setAttribute("normal",new Pi(h,3)),this.setAttribute("uv",new Pi(d,2))}static fromJSON(t){return new Ku(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Yu extends Ku{constructor(t=1,e=1,n=8,r=1,i=!1,s=0,a=2*Math.PI){super(0,t,e,n,r,i,s,a),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:r,openEnded:i,thetaStart:s,thetaLength:a}}static fromJSON(t){return new Yu(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Zu extends ji{constructor(t=[],e=[],n=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:r};const i=[],s=[];function a(t,e,n,r){const i=r+1,s=[];for(let r=0;r<=i;r++){s[r]=[];const a=t.clone().lerp(n,r/i),o=e.clone().lerp(n,r/i),l=i-r;for(let t=0;t<=l;t++)s[r][t]=0===t&&r===i?a:a.clone().lerp(o,t/l)}for(let t=0;t<i;t++)for(let e=0;e<2*(i-t)-1;e++){const n=Math.floor(e/2);e%2==0?(o(s[t][n+1]),o(s[t+1][n]),o(s[t][n])):(o(s[t][n+1]),o(s[t+1][n+1]),o(s[t+1][n]))}}function o(t){i.push(t.x,t.y,t.z)}function l(e,n){const r=3*e;n.x=t[r+0],n.y=t[r+1],n.z=t[r+2]}function u(t,e,n,r){r<0&&1===t.x&&(s[e]=t.x-1),0===n.x&&0===n.z&&(s[e]=r/2/Math.PI+.5)}function c(t){return Math.atan2(t.z,-t.x)}!function(t){const n=new ur,r=new ur,i=new ur;for(let s=0;s<e.length;s+=3)l(e[s+0],n),l(e[s+1],r),l(e[s+2],i),a(n,r,i,t)}(r),function(t){const e=new ur;for(let n=0;n<i.length;n+=3)e.x=i[n+0],e.y=i[n+1],e.z=i[n+2],e.normalize().multiplyScalar(t),i[n+0]=e.x,i[n+1]=e.y,i[n+2]=e.z}(n),function(){const t=new ur;for(let n=0;n<i.length;n+=3){t.x=i[n+0],t.y=i[n+1],t.z=i[n+2];const r=c(t)/2/Math.PI+.5,a=(e=t,Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))/Math.PI+.5);s.push(r,1-a)}var e;(function(){const t=new ur,e=new ur,n=new ur,r=new ur,a=new Rn,o=new Rn,l=new Rn;for(let h=0,d=0;h<i.length;h+=9,d+=6){t.set(i[h+0],i[h+1],i[h+2]),e.set(i[h+3],i[h+4],i[h+5]),n.set(i[h+6],i[h+7],i[h+8]),a.set(s[d+0],s[d+1]),o.set(s[d+2],s[d+3]),l.set(s[d+4],s[d+5]),r.copy(t).add(e).add(n).divideScalar(3);const p=c(r);u(a,d+0,t,p),u(o,d+2,e,p),u(l,d+4,n,p)}})(),function(){for(let t=0;t<s.length;t+=6){const e=s[t+0],n=s[t+2],r=s[t+4],i=Math.max(e,n,r),a=Math.min(e,n,r);i>.9&&a<.1&&(e<.2&&(s[t+0]+=1),n<.2&&(s[t+2]+=1),r<.2&&(s[t+4]+=1))}}()}(),this.setAttribute("position",new Pi(i,3)),this.setAttribute("normal",new Pi(i.slice(),3)),this.setAttribute("uv",new Pi(s,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(t){return new Zu(t.vertices,t.indices,t.radius,t.details)}}class Ju extends Zu{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,r=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-n,0,-r,n,0,r,-n,0,r,n,-r,-n,0,-r,n,0,r,-n,0,r,n,0,-n,0,-r,n,0,-r,-n,0,r,n,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Ju(t.radius,t.detail)}}const Qu=new ur,tc=new ur,ec=new ur,nc=new Si;class rc extends ji{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const n=4,r=Math.pow(10,n),i=Math.cos(Sn*e),s=t.getIndex(),a=t.getAttribute("position"),o=s?s.count:a.count,l=[0,0,0],u=["a","b","c"],c=new Array(3),h={},d=[];for(let t=0;t<o;t+=3){s?(l[0]=s.getX(t),l[1]=s.getX(t+1),l[2]=s.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:n,c:o}=nc;if(e.fromBufferAttribute(a,l[0]),n.fromBufferAttribute(a,l[1]),o.fromBufferAttribute(a,l[2]),nc.getNormal(ec),c[0]=`${Math.round(e.x*r)},${Math.round(e.y*r)},${Math.round(e.z*r)}`,c[1]=`${Math.round(n.x*r)},${Math.round(n.y*r)},${Math.round(n.z*r)}`,c[2]=`${Math.round(o.x*r)},${Math.round(o.y*r)},${Math.round(o.z*r)}`,c[0]!==c[1]&&c[1]!==c[2]&&c[2]!==c[0])for(let t=0;t<3;t++){const e=(t+1)%3,n=c[t],r=c[e],s=nc[u[t]],a=nc[u[e]],o=`${n}_${r}`,p=`${r}_${n}`;p in h&&h[p]?(ec.dot(h[p].normal)<=i&&(d.push(s.x,s.y,s.z),d.push(a.x,a.y,a.z)),h[p]=null):o in h||(h[o]={index0:l[t],index1:l[e],normal:ec.clone()})}}for(const t in h)if(h[t]){const{index0:e,index1:n}=h[t];Qu.fromBufferAttribute(a,e),tc.fromBufferAttribute(a,n),d.push(Qu.x,Qu.y,Qu.z),d.push(tc.x,tc.y,tc.z)}this.setAttribute("position",new Pi(d,3))}}}class ic extends Hu{constructor(t){super(t),this.uuid=In(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,r=this.holes.length;n<r;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const n=this.holes[e];t.holes.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new Hu).fromJSON(n))}return this}}function sc(t,e,n,r,i){let s,a;if(i===function(t,e,n,r){let i=0;for(let s=e,a=n-r;s<n;s+=r)i+=(t[a]-t[s])*(t[s+1]+t[a+1]),a=s;return i}(t,e,n,r)>0)for(s=e;s<n;s+=r)a=Mc(s,t[s],t[s+1],a);else for(s=n-r;s>=e;s-=r)a=Mc(s,t[s],t[s+1],a);return a&&bc(a,a.next)&&(Tc(a),a=a.next),a}function ac(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!bc(r,r.next)&&0!==vc(r.prev,r,r.next))r=r.next;else{if(Tc(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function oc(t,e,n,r,i,s,a){if(!t)return;!a&&s&&function(t,e,n,r){let i=t;do{null===i.z&&(i.z=mc(i.x,i.y,e,n,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,function(t){let e,n,r,i,s,a,o,l,u=1;do{for(n=t,t=null,s=null,a=0;n;){for(a++,r=n,o=0,e=0;e<u&&(o++,r=r.nextZ,r);e++);for(l=u;o>0||l>0&&r;)0!==o&&(0===l||!r||n.z<=r.z)?(i=n,n=n.nextZ,o--):(i=r,r=r.nextZ,l--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;n=r}s.nextZ=null,u*=2}while(a>1)}(i)}(t,r,i,s);let o,l,u=t;for(;t.prev!==t.next;)if(o=t.prev,l=t.next,s?uc(t,r,i,s):lc(t))e.push(o.i/n),e.push(t.i/n),e.push(l.i/n),Tc(t),t=l.next,u=l.next;else if((t=l)===u){a?1===a?oc(t=cc(ac(t),e,n),e,n,r,i,s,2):2===a&&hc(t,e,n,r,i,s):oc(ac(t),e,n,r,i,s,1);break}}function lc(t){const e=t.prev,n=t,r=t.next;if(vc(e,n,r)>=0)return!1;let i=t.next.next;for(;i!==t.prev;){if(xc(e.x,e.y,n.x,n.y,r.x,r.y,i.x,i.y)&&vc(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function uc(t,e,n,r){const i=t.prev,s=t,a=t.next;if(vc(i,s,a)>=0)return!1;const o=i.x<s.x?i.x<a.x?i.x:a.x:s.x<a.x?s.x:a.x,l=i.y<s.y?i.y<a.y?i.y:a.y:s.y<a.y?s.y:a.y,u=i.x>s.x?i.x>a.x?i.x:a.x:s.x>a.x?s.x:a.x,c=i.y>s.y?i.y>a.y?i.y:a.y:s.y>a.y?s.y:a.y,h=mc(o,l,e,n,r),d=mc(u,c,e,n,r);let p=t.prevZ,f=t.nextZ;for(;p&&p.z>=h&&f&&f.z<=d;){if(p!==t.prev&&p!==t.next&&xc(i.x,i.y,s.x,s.y,a.x,a.y,p.x,p.y)&&vc(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,f!==t.prev&&f!==t.next&&xc(i.x,i.y,s.x,s.y,a.x,a.y,f.x,f.y)&&vc(f.prev,f,f.next)>=0)return!1;f=f.nextZ}for(;p&&p.z>=h;){if(p!==t.prev&&p!==t.next&&xc(i.x,i.y,s.x,s.y,a.x,a.y,p.x,p.y)&&vc(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==t.prev&&f!==t.next&&xc(i.x,i.y,s.x,s.y,a.x,a.y,f.x,f.y)&&vc(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function cc(t,e,n){let r=t;do{const i=r.prev,s=r.next.next;!bc(i,s)&&wc(i,r,r.next,s)&&Ic(i,s)&&Ic(s,i)&&(e.push(i.i/n),e.push(r.i/n),e.push(s.i/n),Tc(r),Tc(r.next),r=t=s),r=r.next}while(r!==t);return ac(r)}function hc(t,e,n,r,i,s){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.i!==t.i&&yc(a,t)){let o=kc(a,t);return a=ac(a,a.next),o=ac(o,o.next),oc(a,e,n,r,i,s),void oc(o,e,n,r,i,s)}t=t.next}a=a.next}while(a!==t)}function dc(t,e){return t.x-e.x}function pc(t,e){if(e=function(t,e){let n=e;const r=t.x,i=t.y;let s,a=-1/0;do{if(i<=n.y&&i>=n.next.y&&n.next.y!==n.y){const t=n.x+(i-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>a){if(a=t,t===r){if(i===n.y)return n;if(i===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!s)return null;if(r===a)return s;const o=s,l=s.x,u=s.y;let c,h=1/0;n=s;do{r>=n.x&&n.x>=l&&r!==n.x&&xc(i<u?r:a,i,l,u,i<u?a:r,i,n.x,n.y)&&(c=Math.abs(i-n.y)/(r-n.x),Ic(n,t)&&(c<h||c===h&&(n.x>s.x||n.x===s.x&&fc(s,n)))&&(s=n,h=c)),n=n.next}while(n!==o);return s}(t,e),e){const n=kc(e,t);ac(e,e.next),ac(n,n.next)}}function fc(t,e){return vc(t.prev,t,e.prev)<0&&vc(e.next,t,t.next)<0}function mc(t,e,n,r,i){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*i)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*i)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function gc(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function xc(t,e,n,r,i,s,a,o){return(i-a)*(e-o)-(t-a)*(s-o)>=0&&(t-a)*(r-o)-(n-a)*(e-o)>=0&&(n-a)*(s-o)-(i-a)*(r-o)>=0}function yc(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&wc(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(Ic(t,e)&&Ic(e,t)&&function(t,e){let n=t,r=!1;const i=(t.x+e.x)/2,s=(t.y+e.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&i<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(vc(t.prev,t,e.prev)||vc(t,e.prev,e))||bc(t,e)&&vc(t.prev,t,t.next)>0&&vc(e.prev,e,e.next)>0)}function vc(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function bc(t,e){return t.x===e.x&&t.y===e.y}function wc(t,e,n,r){const i=_c(vc(t,e,n)),s=_c(vc(t,e,r)),a=_c(vc(n,r,t)),o=_c(vc(n,r,e));return i!==s&&a!==o||!(0!==i||!Sc(t,n,e))||!(0!==s||!Sc(t,r,e))||!(0!==a||!Sc(n,t,r))||!(0!==o||!Sc(n,e,r))}function Sc(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function _c(t){return t>0?1:t<0?-1:0}function Ic(t,e){return vc(t.prev,t,t.next)<0?vc(t,e,t.next)>=0&&vc(t,t.prev,e)>=0:vc(t,e,t.prev)<0||vc(t,t.next,e)<0}function kc(t,e){const n=new Cc(t.i,t.x,t.y),r=new Cc(e.i,e.x,e.y),i=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=i,i.prev=n,r.next=n,n.prev=r,s.next=r,r.prev=s,r}function Mc(t,e,n,r){const i=new Cc(t,e,n);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function Tc(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Cc(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class Ec{static area(t){const e=t.length;let n=0;for(let r=e-1,i=0;i<e;r=i++)n+=t[r].x*t[i].y-t[i].x*t[r].y;return.5*n}static isClockWise(t){return Ec.area(t)<0}static triangulateShape(t,e){const n=[],r=[],i=[];Ac(t),Nc(n,t);let s=t.length;e.forEach(Ac);for(let t=0;t<e.length;t++)r.push(s),s+=e[t].length,Nc(n,e[t]);const a=function(t,e,n=2){const r=e&&e.length,i=r?e[0]*n:t.length;let s=sc(t,0,i,n,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,u,c,h,d,p;if(r&&(s=function(t,e,n,r){const i=[];let s,a,o,l,u;for(s=0,a=e.length;s<a;s++)o=e[s]*r,l=s<a-1?e[s+1]*r:t.length,u=sc(t,o,l,r,!1),u===u.next&&(u.steiner=!0),i.push(gc(u));for(i.sort(dc),s=0;s<i.length;s++)pc(i[s],n),n=ac(n,n.next);return n}(t,e,s,n)),t.length>80*n){o=u=t[0],l=c=t[1];for(let e=n;e<i;e+=n)h=t[e],d=t[e+1],h<o&&(o=h),d<l&&(l=d),h>u&&(u=h),d>c&&(c=d);p=Math.max(u-o,c-l),p=0!==p?1/p:0}return oc(s,a,n,o,l,p),a}(n,r);for(let t=0;t<a.length;t+=3)i.push(a.slice(t,t+3));return i}}function Ac(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function Nc(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class Rc extends ji{constructor(t=new ic([new Rn(.5,.5),new Rn(-.5,.5),new Rn(-.5,-.5),new Rn(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,r=[],i=[];for(let e=0,n=t.length;e<n;e++)s(t[e]);function s(t){const s=[],a=void 0!==e.curveSegments?e.curveSegments:12,o=void 0!==e.steps?e.steps:1,l=void 0!==e.depth?e.depth:1;let u=void 0===e.bevelEnabled||e.bevelEnabled,c=void 0!==e.bevelThickness?e.bevelThickness:.2,h=void 0!==e.bevelSize?e.bevelSize:c-.1,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const f=e.extrudePath,m=void 0!==e.UVGenerator?e.UVGenerator:Dc;let g,x,y,v,b,w=!1;f&&(g=f.getSpacedPoints(o),w=!0,u=!1,x=f.computeFrenetFrames(o,!1),y=new ur,v=new ur,b=new ur),u||(p=0,c=0,h=0,d=0);const S=t.extractPoints(a);let _=S.shape;const I=S.holes;if(!Ec.isClockWise(_)){_=_.reverse();for(let t=0,e=I.length;t<e;t++){const e=I[t];Ec.isClockWise(e)&&(I[t]=e.reverse())}}const k=Ec.triangulateShape(_,I),M=_;for(let t=0,e=I.length;t<e;t++){const e=I[t];_=_.concat(e)}function T(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(n).add(t)}const C=_.length,E=k.length;function A(t,e,n){let r,i,s;const a=t.x-e.x,o=t.y-e.y,l=n.x-t.x,u=n.y-t.y,c=a*a+o*o,h=a*u-o*l;if(Math.abs(h)>Number.EPSILON){const h=Math.sqrt(c),d=Math.sqrt(l*l+u*u),p=e.x-o/h,f=e.y+a/h,m=((n.x-u/d-p)*u-(n.y+l/d-f)*l)/(a*u-o*l);r=p+a*m-t.x,i=f+o*m-t.y;const g=r*r+i*i;if(g<=2)return new Rn(r,i);s=Math.sqrt(g/2)}else{let t=!1;a>Number.EPSILON?l>Number.EPSILON&&(t=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(o)===Math.sign(u)&&(t=!0),t?(r=-o,i=a,s=Math.sqrt(c)):(r=a,i=o,s=Math.sqrt(c/2))}return new Rn(r/s,i/s)}const N=[];for(let t=0,e=M.length,n=e-1,r=t+1;t<e;t++,n++,r++)n===e&&(n=0),r===e&&(r=0),N[t]=A(M[t],M[n],M[r]);const R=[];let D,L=N.concat();for(let t=0,e=I.length;t<e;t++){const e=I[t];D=[];for(let t=0,n=e.length,r=n-1,i=t+1;t<n;t++,r++,i++)r===n&&(r=0),i===n&&(i=0),D[t]=A(e[t],e[r],e[i]);R.push(D),L=L.concat(D)}for(let t=0;t<p;t++){const e=t/p,n=c*Math.cos(e*Math.PI/2),r=h*Math.sin(e*Math.PI/2)+d;for(let t=0,e=M.length;t<e;t++){const e=T(M[t],N[t],r);P(e.x,e.y,-n)}for(let t=0,e=I.length;t<e;t++){const e=I[t];D=R[t];for(let t=0,i=e.length;t<i;t++){const i=T(e[t],D[t],r);P(i.x,i.y,-n)}}}const F=h+d;for(let t=0;t<C;t++){const e=u?T(_[t],L[t],F):_[t];w?(v.copy(x.normals[0]).multiplyScalar(e.x),y.copy(x.binormals[0]).multiplyScalar(e.y),b.copy(g[0]).add(v).add(y),P(b.x,b.y,b.z)):P(e.x,e.y,0)}for(let t=1;t<=o;t++)for(let e=0;e<C;e++){const n=u?T(_[e],L[e],F):_[e];w?(v.copy(x.normals[t]).multiplyScalar(n.x),y.copy(x.binormals[t]).multiplyScalar(n.y),b.copy(g[t]).add(v).add(y),P(b.x,b.y,b.z)):P(n.x,n.y,l/o*t)}for(let t=p-1;t>=0;t--){const e=t/p,n=c*Math.cos(e*Math.PI/2),r=h*Math.sin(e*Math.PI/2)+d;for(let t=0,e=M.length;t<e;t++){const e=T(M[t],N[t],r);P(e.x,e.y,l+n)}for(let t=0,e=I.length;t<e;t++){const e=I[t];D=R[t];for(let t=0,i=e.length;t<i;t++){const i=T(e[t],D[t],r);w?P(i.x,i.y+g[o-1].y,g[o-1].x+n):P(i.x,i.y,l+n)}}}function $(t,e){let n=t.length;for(;--n>=0;){const r=n;let i=n-1;i<0&&(i=t.length-1);for(let t=0,n=o+2*p;t<n;t++){const n=C*t,s=C*(t+1);z(e+r+n,e+i+n,e+i+s,e+r+s)}}}function P(t,e,n){s.push(t),s.push(e),s.push(n)}function O(t,e,i){B(t),B(e),B(i);const s=r.length/3,a=m.generateTopUV(n,r,s-3,s-2,s-1);U(a[0]),U(a[1]),U(a[2])}function z(t,e,i,s){B(t),B(e),B(s),B(e),B(i),B(s);const a=r.length/3,o=m.generateSideWallUV(n,r,a-6,a-3,a-2,a-1);U(o[0]),U(o[1]),U(o[3]),U(o[1]),U(o[2]),U(o[3])}function B(t){r.push(s[3*t+0]),r.push(s[3*t+1]),r.push(s[3*t+2])}function U(t){i.push(t.x),i.push(t.y)}!function(){const t=r.length/3;if(u){let t=0,e=C*t;for(let t=0;t<E;t++){const n=k[t];O(n[2]+e,n[1]+e,n[0]+e)}t=o+2*p,e=C*t;for(let t=0;t<E;t++){const n=k[t];O(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<E;t++){const e=k[t];O(e[2],e[1],e[0])}for(let t=0;t<E;t++){const e=k[t];O(e[0]+C*o,e[1]+C*o,e[2]+C*o)}}n.addGroup(t,r.length/3-t,0)}(),function(){const t=r.length/3;let e=0;$(M,e),e+=M.length;for(let t=0,n=I.length;t<n;t++){const n=I[t];$(n,e),e+=n.length}n.addGroup(t,r.length/3-t,1)}()}this.setAttribute("position",new Pi(r,3)),this.setAttribute("uv",new Pi(i,2)),this.computeVertexNormals()}toJSON(){const t=super.toJSON();return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let e=0,r=t.length;e<r;e++){const r=t[e];n.shapes.push(r.uuid)}else n.shapes.push(t.uuid);return n.options=Object.assign({},e),void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const n=[];for(let r=0,i=t.shapes.length;r<i;r++){const i=e[t.shapes[r]];n.push(i)}const r=t.options.extrudePath;return void 0!==r&&(t.options.extrudePath=(new Vu[r.type]).fromJSON(r)),new Rc(n,t.options)}}const Dc={generateTopUV:function(t,e,n,r,i){const s=e[3*n],a=e[3*n+1],o=e[3*r],l=e[3*r+1],u=e[3*i],c=e[3*i+1];return[new Rn(s,a),new Rn(o,l),new Rn(u,c)]},generateSideWallUV:function(t,e,n,r,i,s){const a=e[3*n],o=e[3*n+1],l=e[3*n+2],u=e[3*r],c=e[3*r+1],h=e[3*r+2],d=e[3*i],p=e[3*i+1],f=e[3*i+2],m=e[3*s],g=e[3*s+1],x=e[3*s+2];return Math.abs(o-c)<Math.abs(a-u)?[new Rn(a,1-l),new Rn(u,1-h),new Rn(d,1-f),new Rn(m,1-x)]:[new Rn(o,1-l),new Rn(c,1-h),new Rn(p,1-f),new Rn(g,1-x)]}};class Lc extends Zu{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Lc(t.radius,t.detail)}}class Fc extends Zu{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Fc(t.radius,t.detail)}}class $c extends ji{constructor(t=.5,e=1,n=8,r=1,i=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:r,thetaStart:i,thetaLength:s},n=Math.max(3,n);const a=[],o=[],l=[],u=[];let c=t;const h=(e-t)/(r=Math.max(1,r)),d=new ur,p=new Rn;for(let t=0;t<=r;t++){for(let t=0;t<=n;t++){const r=i+t/n*s;d.x=c*Math.cos(r),d.y=c*Math.sin(r),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,u.push(p.x,p.y)}c+=h}for(let t=0;t<r;t++){const e=t*(n+1);for(let t=0;t<n;t++){const r=t+e,i=r,s=r+n+1,o=r+n+2,l=r+1;a.push(i,s,l),a.push(s,o,l)}}this.setIndex(a),this.setAttribute("position",new Pi(o,3)),this.setAttribute("normal",new Pi(l,3)),this.setAttribute("uv",new Pi(u,2))}static fromJSON(t){return new $c(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class Pc extends ji{constructor(t=new ic([new Rn(0,.5),new Rn(-.5,-.5),new Rn(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],r=[],i=[],s=[];let a=0,o=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(a,o,e),a+=o,o=0;function l(t){const a=r.length/3,l=t.extractPoints(e);let u=l.shape;const c=l.holes;!1===Ec.isClockWise(u)&&(u=u.reverse());for(let t=0,e=c.length;t<e;t++){const e=c[t];!0===Ec.isClockWise(e)&&(c[t]=e.reverse())}const h=Ec.triangulateShape(u,c);for(let t=0,e=c.length;t<e;t++){const e=c[t];u=u.concat(e)}for(let t=0,e=u.length;t<e;t++){const e=u[t];r.push(e.x,e.y,0),i.push(0,0,1),s.push(e.x,e.y)}for(let t=0,e=h.length;t<e;t++){const e=h[t],r=e[0]+a,i=e[1]+a,s=e[2]+a;n.push(r,i,s),o+=3}}this.setIndex(n),this.setAttribute("position",new Pi(r,3)),this.setAttribute("normal",new Pi(i,3)),this.setAttribute("uv",new Pi(s,2))}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,r=t.length;n<r;n++){const r=t[n];e.shapes.push(r.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const n=[];for(let r=0,i=t.shapes.length;r<i;r++){const i=e[t.shapes[r]];n.push(i)}return new Pc(n,t.curveSegments)}}class Oc extends ji{constructor(t=1,e=32,n=16,r=0,i=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:r,phiLength:i,thetaStart:s,thetaLength:a},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const o=Math.min(s+a,Math.PI);let l=0;const u=[],c=new ur,h=new ur,d=[],p=[],f=[],m=[];for(let d=0;d<=n;d++){const g=[],x=d/n;let y=0;0==d&&0==s?y=.5/e:d==n&&o==Math.PI&&(y=-.5/e);for(let n=0;n<=e;n++){const o=n/e;c.x=-t*Math.cos(r+o*i)*Math.sin(s+x*a),c.y=t*Math.cos(s+x*a),c.z=t*Math.sin(r+o*i)*Math.sin(s+x*a),p.push(c.x,c.y,c.z),h.copy(c).normalize(),f.push(h.x,h.y,h.z),m.push(o+y,1-x),g.push(l++)}u.push(g)}for(let t=0;t<n;t++)for(let r=0;r<e;r++){const e=u[t][r+1],i=u[t][r],a=u[t+1][r],l=u[t+1][r+1];(0!==t||s>0)&&d.push(e,i,l),(t!==n-1||o<Math.PI)&&d.push(i,a,l)}this.setIndex(d),this.setAttribute("position",new Pi(p,3)),this.setAttribute("normal",new Pi(f,3)),this.setAttribute("uv",new Pi(m,2))}static fromJSON(t){return new Oc(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class zc extends Zu{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new zc(t.radius,t.detail)}}class Bc extends ji{constructor(t=1,e=.4,n=8,r=6,i=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:r,arc:i},n=Math.floor(n),r=Math.floor(r);const s=[],a=[],o=[],l=[],u=new ur,c=new ur,h=new ur;for(let s=0;s<=n;s++)for(let d=0;d<=r;d++){const p=d/r*i,f=s/n*Math.PI*2;c.x=(t+e*Math.cos(f))*Math.cos(p),c.y=(t+e*Math.cos(f))*Math.sin(p),c.z=e*Math.sin(f),a.push(c.x,c.y,c.z),u.x=t*Math.cos(p),u.y=t*Math.sin(p),h.subVectors(c,u).normalize(),o.push(h.x,h.y,h.z),l.push(d/r),l.push(s/n)}for(let t=1;t<=n;t++)for(let e=1;e<=r;e++){const n=(r+1)*t+e-1,i=(r+1)*(t-1)+e-1,a=(r+1)*(t-1)+e,o=(r+1)*t+e;s.push(n,i,o),s.push(i,a,o)}this.setIndex(s),this.setAttribute("position",new Pi(a,3)),this.setAttribute("normal",new Pi(o,3)),this.setAttribute("uv",new Pi(l,2))}static fromJSON(t){return new Bc(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class Uc extends ji{constructor(t=1,e=.4,n=64,r=8,i=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:r,p:i,q:s},n=Math.floor(n),r=Math.floor(r);const a=[],o=[],l=[],u=[],c=new ur,h=new ur,d=new ur,p=new ur,f=new ur,m=new ur,g=new ur;for(let a=0;a<=n;++a){const y=a/n*i*Math.PI*2;x(y,i,s,t,d),x(y+.01,i,s,t,p),m.subVectors(p,d),g.addVectors(p,d),f.crossVectors(m,g),g.crossVectors(f,m),f.normalize(),g.normalize();for(let t=0;t<=r;++t){const i=t/r*Math.PI*2,s=-e*Math.cos(i),p=e*Math.sin(i);c.x=d.x+(s*g.x+p*f.x),c.y=d.y+(s*g.y+p*f.y),c.z=d.z+(s*g.z+p*f.z),o.push(c.x,c.y,c.z),h.subVectors(c,d).normalize(),l.push(h.x,h.y,h.z),u.push(a/n),u.push(t/r)}}for(let t=1;t<=n;t++)for(let e=1;e<=r;e++){const n=(r+1)*(t-1)+(e-1),i=(r+1)*t+(e-1),s=(r+1)*t+e,o=(r+1)*(t-1)+e;a.push(n,i,o),a.push(i,s,o)}function x(t,e,n,r,i){const s=Math.cos(t),a=Math.sin(t),o=n/e*t,l=Math.cos(o);i.x=r*(2+l)*.5*s,i.y=r*(2+l)*a*.5,i.z=r*Math.sin(o)*.5}this.setIndex(a),this.setAttribute("position",new Pi(o,3)),this.setAttribute("normal",new Pi(l,3)),this.setAttribute("uv",new Pi(u,2))}static fromJSON(t){return new Uc(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class Wc extends ji{constructor(t=new Uu(new ur(-1,-1,0),new ur(-1,1,0),new ur(1,1,0)),e=64,n=1,r=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:r,closed:i};const s=t.computeFrenetFrames(e,i);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const a=new ur,o=new ur,l=new Rn;let u=new ur;const c=[],h=[],d=[],p=[];function f(i){u=t.getPointAt(i/e,u);const l=s.normals[i],d=s.binormals[i];for(let t=0;t<=r;t++){const e=t/r*Math.PI*2,i=Math.sin(e),s=-Math.cos(e);o.x=s*l.x+i*d.x,o.y=s*l.y+i*d.y,o.z=s*l.z+i*d.z,o.normalize(),h.push(o.x,o.y,o.z),a.x=u.x+n*o.x,a.y=u.y+n*o.y,a.z=u.z+n*o.z,c.push(a.x,a.y,a.z)}}!function(){for(let t=0;t<e;t++)f(t);f(!1===i?e:0),function(){for(let t=0;t<=e;t++)for(let n=0;n<=r;n++)l.x=t/e,l.y=n/r,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=r;e++){const n=(r+1)*(t-1)+(e-1),i=(r+1)*t+(e-1),s=(r+1)*t+e,a=(r+1)*(t-1)+e;p.push(n,i,a),p.push(i,s,a)}}()}(),this.setIndex(p),this.setAttribute("position",new Pi(c,3)),this.setAttribute("normal",new Pi(h,3)),this.setAttribute("uv",new Pi(d,2))}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new Wc((new Vu[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class Vc extends ji{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const e=[],n=new Set,r=new ur,i=new ur;if(null!==t.index){const s=t.attributes.position,a=t.index;let o=t.groups;0===o.length&&(o=[{start:0,count:a.count,materialIndex:0}]);for(let t=0,l=o.length;t<l;++t){const l=o[t],u=l.start;for(let t=u,o=u+l.count;t<o;t+=3)for(let o=0;o<3;o++){const l=a.getX(t+o),u=a.getX(t+(o+1)%3);r.fromBufferAttribute(s,l),i.fromBufferAttribute(s,u),!0===Gc(r,i,n)&&(e.push(r.x,r.y,r.z),e.push(i.x,i.y,i.z))}}}else{const s=t.attributes.position;for(let t=0,a=s.count/3;t<a;t++)for(let a=0;a<3;a++){const o=3*t+a,l=3*t+(a+1)%3;r.fromBufferAttribute(s,o),i.fromBufferAttribute(s,l),!0===Gc(r,i,n)&&(e.push(r.x,r.y,r.z),e.push(i.x,i.y,i.z))}}this.setAttribute("position",new Pi(e,3))}}}function Gc(t,e,n){const r=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return!0!==n.has(r)&&!0!==n.has(i)&&(n.add(r),n.add(i),!0)}var Hc=Object.freeze({__proto__:null,BoxGeometry:ds,BoxBufferGeometry:ds,CapsuleGeometry:qu,CapsuleBufferGeometry:qu,CircleGeometry:Xu,CircleBufferGeometry:Xu,ConeGeometry:Yu,ConeBufferGeometry:Yu,CylinderGeometry:Ku,CylinderBufferGeometry:Ku,DodecahedronGeometry:Ju,DodecahedronBufferGeometry:Ju,EdgesGeometry:rc,ExtrudeGeometry:Rc,ExtrudeBufferGeometry:Rc,IcosahedronGeometry:Lc,IcosahedronBufferGeometry:Lc,LatheGeometry:ju,LatheBufferGeometry:ju,OctahedronGeometry:Fc,OctahedronBufferGeometry:Fc,PlaneGeometry:Rs,PlaneBufferGeometry:Rs,PolyhedronGeometry:Zu,PolyhedronBufferGeometry:Zu,RingGeometry:$c,RingBufferGeometry:$c,ShapeGeometry:Pc,ShapeBufferGeometry:Pc,SphereGeometry:Oc,SphereBufferGeometry:Oc,TetrahedronGeometry:zc,TetrahedronBufferGeometry:zc,TorusGeometry:Bc,TorusBufferGeometry:Bc,TorusKnotGeometry:Uc,TorusKnotBufferGeometry:Uc,TubeGeometry:Wc,TubeBufferGeometry:Wc,WireframeGeometry:Vc});class jc extends Ii{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Xn(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class qc extends gs{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class Xc extends Ii{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Xn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Xn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Rn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Kc extends Xc{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Rn(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return kn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Xn(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Xn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Xn(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class Yc extends Ii{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Xn(16777215),this.specular=new Xn(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Xn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Rn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=J,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Zc extends Ii{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Xn(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Xn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Rn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class Jc extends Ii{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Rn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class Qc extends Ii{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Xn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Xn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=J,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class th extends Ii{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Xn(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Rn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}class eh extends nu{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function nh(t,e,n){return ih(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)}function rh(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)}function ih(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function sh(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort((function(e,n){return t[e]-t[n]})),n}function ah(t,e,n){const r=t.length,i=new t.constructor(r);for(let s=0,a=0;a!==r;++s){const r=n[s]*e;for(let n=0;n!==e;++n)i[a++]=t[r+n]}return i}function oh(t,e,n,r){let i=1,s=t[0];for(;void 0!==s&&void 0===s[r];)s=t[i++];if(void 0===s)return;let a=s[r];if(void 0!==a)if(Array.isArray(a))do{a=s[r],void 0!==a&&(e.push(s.time),n.push.apply(n,a)),s=t[i++]}while(void 0!==s);else if(void 0!==a.toArray)do{a=s[r],void 0!==a&&(e.push(s.time),a.toArray(n,n.length)),s=t[i++]}while(void 0!==s);else do{a=s[r],void 0!==a&&(e.push(s.time),n.push(a)),s=t[i++]}while(void 0!==s)}var lh=Object.freeze({__proto__:null,arraySlice:nh,convertArray:rh,isTypedArray:ih,getKeyframeOrder:sh,sortedArray:ah,flattenJSON:oh,subclip:function(t,e,n,r,i=30){const s=t.clone();s.name=e;const a=[];for(let t=0;t<s.tracks.length;++t){const e=s.tracks[t],o=e.getValueSize(),l=[],u=[];for(let t=0;t<e.times.length;++t){const s=e.times[t]*i;if(!(s<n||s>=r)){l.push(e.times[t]);for(let n=0;n<o;++n)u.push(e.values[t*o+n])}}0!==l.length&&(e.times=rh(l,e.times.constructor),e.values=rh(u,e.values.constructor),a.push(e))}s.tracks=a;let o=1/0;for(let t=0;t<s.tracks.length;++t)o>s.tracks[t].times[0]&&(o=s.tracks[t].times[0]);for(let t=0;t<s.tracks.length;++t)s.tracks[t].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(t,e=0,n=t,r=30){r<=0&&(r=30);const i=n.tracks.length,s=e/r;for(let e=0;e<i;++e){const r=n.tracks[e],i=r.ValueTypeName;if("bool"===i||"string"===i)continue;const a=t.tracks.find((function(t){return t.name===r.name&&t.ValueTypeName===i}));if(void 0===a)continue;let o=0;const l=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let u=0;const c=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=c/3);const h=r.times.length-1;let d;if(s<=r.times[0]){const t=o,e=l-o;d=nh(r.values,t,e)}else if(s>=r.times[h]){const t=h*l+o,e=t+l-o;d=nh(r.values,t,e)}else{const t=r.createInterpolant(),e=o,n=l-o;t.evaluate(s),d=nh(t.resultBuffer,e,n)}"quaternion"===i&&(new lr).fromArray(d).normalize().conjugate().toArray(d);const p=a.times.length;for(let t=0;t<p;++t){const e=t*c+u;if("quaternion"===i)lr.multiplyQuaternionsFlat(a.values,e,d,0,a.values,e);else{const t=c-2*u;for(let n=0;n<t;++n)a.values[e+n]-=d[n]}}}return t.blendMode=Ne,t}});class uh{constructor(t,e,n,r){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,r=e[n],i=e[n-1];t:{e:{let s;n:{r:if(!(t<r)){for(let s=n+2;;){if(void 0===r){if(t<i)break r;return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===s)break;if(i=r,r=e[++n],t<r)break e}s=e.length;break n}if(t>=i)break t;{const a=e[1];t<a&&(n=2,i=a);for(let s=n-2;;){if(void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(n===s)break;if(r=i,i=e[--n-1],t>=i)break e}s=n,n=0}}for(;n<s;){const r=n+s>>>1;t<e[r]?s=r:n=r+1}if(r=e[n],i=e[n-1],void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===r)return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,i,r)}return this.interpolate_(n,i,t,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=t*r;for(let t=0;t!==r;++t)e[t]=n[i+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class ch extends uh{constructor(t,e,n,r){super(t,e,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Te,endingEnd:Te}}intervalChanged_(t,e,n){const r=this.parameterPositions;let i=t-2,s=t+1,a=r[i],o=r[s];if(void 0===a)switch(this.getSettings_().endingStart){case Ce:i=t,a=2*e-n;break;case Ee:i=r.length-2,a=e+r[i]-r[i+1];break;default:i=t,a=n}if(void 0===o)switch(this.getSettings_().endingEnd){case Ce:s=t,o=2*n-e;break;case Ee:s=1,o=n+r[1]-r[0];break;default:s=t-1,o=e}const l=.5*(n-e),u=this.valueSize;this._weightPrev=l/(e-a),this._weightNext=l/(o-n),this._offsetPrev=i*u,this._offsetNext=s*u}interpolate_(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,u=this._offsetPrev,c=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-e)/(r-e),f=p*p,m=f*p,g=-h*m+2*h*f-h*p,x=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1,y=(-1-d)*m+(1.5+d)*f+.5*p,v=d*m-d*f;for(let t=0;t!==a;++t)i[t]=g*s[u+t]+x*s[l+t]+y*s[o+t]+v*s[c+t];return i}}class hh extends uh{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,u=(n-e)/(r-e),c=1-u;for(let t=0;t!==a;++t)i[t]=s[l+t]*c+s[o+t]*u;return i}}class dh extends uh{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t){return this.copySampleValue_(t-1)}}class ph{constructor(t,e,n,r){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=rh(e,this.TimeBufferType),this.values=rh(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:rh(t.times,Array),values:rh(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new dh(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new hh(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new ch(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Ie:e=this.InterpolantFactoryMethodDiscrete;break;case ke:e=this.InterpolantFactoryMethodLinear;break;case Me:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Ie;case this.InterpolantFactoryMethodLinear:return ke;case this.InterpolantFactoryMethodSmooth:return Me}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]*=t}return this}trim(t,e){const n=this.times,r=n.length;let i=0,s=r-1;for(;i!==r&&n[i]<t;)++i;for(;-1!==s&&n[s]>e;)--s;if(++s,0!==i||s!==r){i>=s&&(s=Math.max(s,1),i=s-1);const t=this.getValueSize();this.times=nh(n,i,s),this.values=nh(this.values,i*t,s*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,r=this.values,i=n.length;0===i&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let s=null;for(let e=0;e!==i;e++){const r=n[e];if("number"==typeof r&&isNaN(r)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,r),t=!1;break}if(null!==s&&s>r){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,r,s),t=!1;break}s=r}if(void 0!==r&&ih(r))for(let e=0,n=r.length;e!==n;++e){const n=r[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t}optimize(){const t=nh(this.times),e=nh(this.values),n=this.getValueSize(),r=this.getInterpolation()===Me,i=t.length-1;let s=1;for(let a=1;a<i;++a){let i=!1;const o=t[a];if(o!==t[a+1]&&(1!==a||o!==t[0]))if(r)i=!0;else{const t=a*n,r=t-n,s=t+n;for(let a=0;a!==n;++a){const n=e[t+a];if(n!==e[r+a]||n!==e[s+a]){i=!0;break}}}if(i){if(a!==s){t[s]=t[a];const r=a*n,i=s*n;for(let t=0;t!==n;++t)e[i+t]=e[r+t]}++s}}if(i>0){t[s]=t[i];for(let t=i*n,r=s*n,a=0;a!==n;++a)e[r+a]=e[t+a];++s}return s!==t.length?(this.times=nh(t,0,s),this.values=nh(e,0,s*n)):(this.times=t,this.values=e),this}clone(){const t=nh(this.times,0),e=nh(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}ph.prototype.TimeBufferType=Float32Array,ph.prototype.ValueBufferType=Float32Array,ph.prototype.DefaultInterpolation=ke;class fh extends ph{}fh.prototype.ValueTypeName="bool",fh.prototype.ValueBufferType=Array,fh.prototype.DefaultInterpolation=Ie,fh.prototype.InterpolantFactoryMethodLinear=void 0,fh.prototype.InterpolantFactoryMethodSmooth=void 0;class mh extends ph{}mh.prototype.ValueTypeName="color";class gh extends ph{}gh.prototype.ValueTypeName="number";class xh extends uh{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(n-e)/(r-e);let l=t*a;for(let t=l+a;l!==t;l+=4)lr.slerpFlat(i,0,s,l-a,s,l,o);return i}}class yh extends ph{InterpolantFactoryMethodLinear(t){return new xh(this.times,this.values,this.getValueSize(),t)}}yh.prototype.ValueTypeName="quaternion",yh.prototype.DefaultInterpolation=ke,yh.prototype.InterpolantFactoryMethodSmooth=void 0;class vh extends ph{}vh.prototype.ValueTypeName="string",vh.prototype.ValueBufferType=Array,vh.prototype.DefaultInterpolation=Ie,vh.prototype.InterpolantFactoryMethodLinear=void 0,vh.prototype.InterpolantFactoryMethodSmooth=void 0;class bh extends ph{}bh.prototype.ValueTypeName="vector";class wh{constructor(t,e=-1,n,r=Ae){this.name=t,this.tracks=n,this.duration=e,this.blendMode=r,this.uuid=In(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,r=1/(t.fps||1);for(let t=0,i=n.length;t!==i;++t)e.push(Sh(n[t]).scale(r));const i=new this(t.name,t.duration,e,t.blendMode);return i.uuid=t.uuid,i}static toJSON(t){const e=[],n=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,r=n.length;t!==r;++t)e.push(ph.toJSON(n[t]));return r}static CreateFromMorphTargetSequence(t,e,n,r){const i=e.length,s=[];for(let t=0;t<i;t++){let a=[],o=[];a.push((t+i-1)%i,t,(t+1)%i),o.push(0,1,0);const l=sh(a);a=ah(a,1,l),o=ah(o,1,l),r||0!==a[0]||(a.push(i),o.push(o[0])),s.push(new gh(".morphTargetInfluences["+e[t].name+"]",a,o).scale(1/n))}return new this(t,-1,s)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const r={},i=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],s=n.name.match(i);if(s&&s.length>1){const t=s[1];let e=r[t];e||(r[t]=e=[]),e.push(n)}}const s=[];for(const t in r)s.push(this.CreateFromMorphTargetSequence(t,r[t],e,n));return s}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,r,i){if(0!==n.length){const s=[],a=[];oh(n,s,a,r),0!==s.length&&i.push(new t(e,s,a))}},r=[],i=t.name||"default",s=t.fps||30,a=t.blendMode;let o=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const i=l[t].keys;if(i&&0!==i.length)if(i[0].morphTargets){const t={};let e;for(e=0;e<i.length;e++)if(i[e].morphTargets)for(let n=0;n<i[e].morphTargets.length;n++)t[i[e].morphTargets[n]]=-1;for(const n in t){const t=[],s=[];for(let r=0;r!==i[e].morphTargets.length;++r){const r=i[e];t.push(r.time),s.push(r.morphTarget===n?1:0)}r.push(new gh(".morphTargetInfluence["+n+"]",t,s))}o=t.length*s}else{const s=".bones["+e[t].name+"]";n(bh,s+".position",i,"pos",r),n(yh,s+".quaternion",i,"rot",r),n(bh,s+".scale",i,"scl",r)}}return 0===r.length?null:new this(i,o,r,a)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Sh(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return gh;case"vector":case"vector2":case"vector3":case"vector4":return bh;case"color":return mh;case"quaternion":return yh;case"bool":case"boolean":return fh;case"string":return vh}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];oh(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const _h={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class Ih{constructor(t,e,n){const r=this;let i,s=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){o++,!1===s&&void 0!==r.onStart&&r.onStart(t,a,o),s=!0},this.itemEnd=function(t){a++,void 0!==r.onProgress&&r.onProgress(t,a,o),a===o&&(s=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(t){void 0!==r.onError&&r.onError(t)},this.resolveURL=function(t){return i?i(t):t},this.setURLModifier=function(t){return i=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],r=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return r}return null}}}const kh=new Ih;class Mh{constructor(t){this.manager=void 0!==t?t:kh,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise((function(r,i){n.load(t,r,e,i)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const Th={};class Ch extends Error{constructor(t,e){super(t),this.response=e}}class Eh extends Mh{constructor(t){super(t)}load(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=_h.get(t);if(void 0!==i)return this.manager.itemStart(t),setTimeout((()=>{e&&e(i),this.manager.itemEnd(t)}),0),i;if(void 0!==Th[t])return void Th[t].push({onLoad:e,onProgress:n,onError:r});Th[t]=[],Th[t].push({onLoad:e,onProgress:n,onError:r});const s=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,o=this.responseType;fetch(s).then((e=>{if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;const n=Th[t],r=e.body.getReader(),i=e.headers.get("Content-Length"),s=i?parseInt(i):0,a=0!==s;let o=0;const l=new ReadableStream({start(t){!function e(){r.read().then((({done:r,value:i})=>{if(r)t.close();else{o+=i.byteLength;const r=new ProgressEvent("progress",{lengthComputable:a,loaded:o,total:s});for(let t=0,e=n.length;t<e;t++){const e=n[t];e.onProgress&&e.onProgress(r)}t.enqueue(i),e()}}))}()}});return new Response(l)}throw new Ch(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)})).then((t=>{switch(o){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then((t=>(new DOMParser).parseFromString(t,a)));case"json":return t.json();default:if(void 0===a)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(a),n=e&&e[1]?e[1].toLowerCase():void 0,r=new TextDecoder(n);return t.arrayBuffer().then((t=>r.decode(t)))}}})).then((e=>{_h.add(t,e);const n=Th[t];delete Th[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onLoad&&r.onLoad(e)}})).catch((e=>{const n=Th[t];if(void 0===n)throw this.manager.itemError(t),e;delete Th[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onError&&r.onError(e)}this.manager.itemError(t)})).finally((()=>{this.manager.itemEnd(t)})),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Ah extends Mh{constructor(t){super(t)}load(t,e,n,r){const i=this,s=new Eh(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,(function(n){try{e(i.parse(JSON.parse(n)))}catch(e){r?r(e):console.error(e),i.manager.itemError(t)}}),n,r)}parse(t){const e=[];for(let n=0;n<t.length;n++){const r=wh.parse(t[n]);e.push(r)}return e}}class Nh extends Mh{constructor(t){super(t)}load(t,e,n,r){const i=this,s=[],a=new Su,o=new Eh(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(i.withCredentials);let l=0;function u(u){o.load(t[u],(function(t){const n=i.parse(t,!0);s[u]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(a.minFilter=wt),a.image=s,a.format=n.format,a.needsUpdate=!0,e&&e(a))}),n,r)}if(Array.isArray(t))for(let e=0,n=t.length;e<n;++e)u(e);else o.load(t,(function(t){const n=i.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){s[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)s[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),s[e].format=n.format,s[e].width=n.width,s[e].height=n.height}a.image=s}else a.image.width=n.width,a.image.height=n.height,a.mipmaps=n.mipmaps;1===n.mipmapCount&&(a.minFilter=wt),a.format=n.format,a.needsUpdate=!0,e&&e(a)}),n,r);return a}}class Rh extends Mh{constructor(t){super(t)}load(t,e,n,r){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,s=_h.get(t);if(void 0!==s)return i.manager.itemStart(t),setTimeout((function(){e&&e(s),i.manager.itemEnd(t)}),0),s;const a=Pn("img");function o(){u(),_h.add(t,this),e&&e(this),i.manager.itemEnd(t)}function l(e){u(),r&&r(e),i.manager.itemError(t),i.manager.itemEnd(t)}function u(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),i.manager.itemStart(t),a.src=t,a}}class Dh extends Mh{constructor(t){super(t)}load(t,e,n,r){const i=new ws,s=new Rh(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let a=0;function o(n){s.load(t[n],(function(t){i.images[n]=t,a++,6===a&&(i.needsUpdate=!0,e&&e(i))}),void 0,r)}for(let e=0;e<t.length;++e)o(e);return i}}class Lh extends Mh{constructor(t){super(t)}load(t,e,n,r){const i=this,s=new jl,a=new Eh(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(i.withCredentials),a.load(t,(function(t){const n=i.parse(t);n&&(void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:ft,s.wrapT=void 0!==n.wrapT?n.wrapT:ft,s.magFilter=void 0!==n.magFilter?n.magFilter:wt,s.minFilter=void 0!==n.minFilter?n.minFilter:wt,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(s.encoding=n.encoding),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=It),1===n.mipmapCount&&(s.minFilter=wt),void 0!==n.generateMipmaps&&(s.generateMipmaps=n.generateMipmaps),s.needsUpdate=!0,e&&e(s,n))}),n,r),s}}class Fh extends Mh{constructor(t){super(t)}load(t,e,n,r){const i=new tr,s=new Rh(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(t,(function(t){i.image=t,i.needsUpdate=!0,void 0!==e&&e(i)}),n,r),i}}class $h extends hi{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new Xn(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}class Ph extends $h{constructor(t,e,n){super(t,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(hi.DefaultUp),this.updateMatrix(),this.groundColor=new Xn(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const Oh=new Br,zh=new ur,Bh=new ur;class Uh{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Rn(512,512),this.map=null,this.mapPass=null,this.matrix=new Br,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Es,this._frameExtents=new Rn(1,1),this._viewportCount=1,this._viewports=[new er(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;zh.setFromMatrixPosition(t.matrixWorld),e.position.copy(zh),Bh.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Bh),e.updateMatrixWorld(),Oh.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Oh),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Wh extends Uh{constructor(){super(new ys(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,n=2*_n*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=t.distance||e.far;n===e.fov&&r===e.aspect&&i===e.far||(e.fov=n,e.aspect=r,e.far=i,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Vh extends $h{constructor(t,e,n=0,r=Math.PI/3,i=0,s=1){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(hi.DefaultUp),this.updateMatrix(),this.target=new hi,this.distance=n,this.angle=r,this.penumbra=i,this.decay=s,this.shadow=new Wh}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const Gh=new Br,Hh=new ur,jh=new ur;class qh extends Uh{constructor(){super(new ys(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Rn(4,2),this._viewportCount=6,this._viewports=[new er(2,1,1,1),new er(0,1,1,1),new er(3,1,1,1),new er(1,1,1,1),new er(3,0,1,1),new er(1,0,1,1)],this._cubeDirections=[new ur(1,0,0),new ur(-1,0,0),new ur(0,0,1),new ur(0,0,-1),new ur(0,1,0),new ur(0,-1,0)],this._cubeUps=[new ur(0,1,0),new ur(0,1,0),new ur(0,1,0),new ur(0,1,0),new ur(0,0,1),new ur(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,r=this.matrix,i=t.distance||n.far;i!==n.far&&(n.far=i,n.updateProjectionMatrix()),Hh.setFromMatrixPosition(t.matrixWorld),n.position.copy(Hh),jh.copy(n.position),jh.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(jh),n.updateMatrixWorld(),r.makeTranslation(-Hh.x,-Hh.y,-Hh.z),Gh.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Gh)}}class Xh extends $h{constructor(t,e,n=0,r=1){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new qh}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class Kh extends Uh{constructor(){super(new Ws(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class Yh extends $h{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(hi.DefaultUp),this.updateMatrix(),this.target=new hi,this.shadow=new Kh}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class Zh extends $h{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class Jh extends $h{constructor(t,e,n=10,r=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class Qh{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new ur)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,r=t.y,i=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*r),e.addScaledVector(s[2],.488603*i),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*r*1.092548),e.addScaledVector(s[5],r*i*1.092548),e.addScaledVector(s[6],.315392*(3*i*i-1)),e.addScaledVector(s[7],n*i*1.092548),e.addScaledVector(s[8],.546274*(n*n-r*r)),e}getIrradianceAt(t,e){const n=t.x,r=t.y,i=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*r),e.addScaledVector(s[2],1.023328*i),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*r),e.addScaledVector(s[5],.858086*r*i),e.addScaledVector(s[6],.743125*i*i-.247708),e.addScaledVector(s[7],.858086*n*i),e.addScaledVector(s[8],.429043*(n*n-r*r)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(t,e+3*r);return this}toArray(t=[],e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(t,e+3*r);return t}static getBasisAt(t,e){const n=t.x,r=t.y,i=t.z;e[0]=.282095,e[1]=.488603*r,e[2]=.488603*i,e[3]=.488603*n,e[4]=1.092548*n*r,e[5]=1.092548*r*i,e[6]=.315392*(3*i*i-1),e[7]=1.092548*n*i,e[8]=.546274*(n*n-r*r)}}class td extends $h{constructor(t=new Qh,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class ed extends Mh{constructor(t){super(t),this.textures={}}load(t,e,n,r){const i=this,s=new Eh(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,(function(n){try{e(i.parse(JSON.parse(n)))}catch(e){r?r(e):console.error(e),i.manager.itemError(t)}}),n,r)}parse(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const r=ed.createMaterialFromType(t.type);if(void 0!==t.uuid&&(r.uuid=t.uuid),void 0!==t.name&&(r.name=t.name),void 0!==t.color&&void 0!==r.color&&r.color.setHex(t.color),void 0!==t.roughness&&(r.roughness=t.roughness),void 0!==t.metalness&&(r.metalness=t.metalness),void 0!==t.sheen&&(r.sheen=t.sheen),void 0!==t.sheenColor&&(r.sheenColor=(new Xn).setHex(t.sheenColor)),void 0!==t.sheenRoughness&&(r.sheenRoughness=t.sheenRoughness),void 0!==t.emissive&&void 0!==r.emissive&&r.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==r.specular&&r.specular.setHex(t.specular),void 0!==t.specularIntensity&&(r.specularIntensity=t.specularIntensity),void 0!==t.specularColor&&void 0!==r.specularColor&&r.specularColor.setHex(t.specularColor),void 0!==t.shininess&&(r.shininess=t.shininess),void 0!==t.clearcoat&&(r.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(r.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.iridescence&&(r.iridescence=t.iridescence),void 0!==t.iridescenceIOR&&(r.iridescenceIOR=t.iridescenceIOR),void 0!==t.iridescenceThicknessRange&&(r.iridescenceThicknessRange=t.iridescenceThicknessRange),void 0!==t.transmission&&(r.transmission=t.transmission),void 0!==t.thickness&&(r.thickness=t.thickness),void 0!==t.attenuationDistance&&(r.attenuationDistance=t.attenuationDistance),void 0!==t.attenuationColor&&void 0!==r.attenuationColor&&r.attenuationColor.setHex(t.attenuationColor),void 0!==t.fog&&(r.fog=t.fog),void 0!==t.flatShading&&(r.flatShading=t.flatShading),void 0!==t.blending&&(r.blending=t.blending),void 0!==t.combine&&(r.combine=t.combine),void 0!==t.side&&(r.side=t.side),void 0!==t.shadowSide&&(r.shadowSide=t.shadowSide),void 0!==t.opacity&&(r.opacity=t.opacity),void 0!==t.transparent&&(r.transparent=t.transparent),void 0!==t.alphaTest&&(r.alphaTest=t.alphaTest),void 0!==t.depthTest&&(r.depthTest=t.depthTest),void 0!==t.depthWrite&&(r.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(r.colorWrite=t.colorWrite),void 0!==t.stencilWrite&&(r.stencilWrite=t.stencilWrite),void 0!==t.stencilWriteMask&&(r.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(r.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(r.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(r.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(r.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(r.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(r.stencilZPass=t.stencilZPass),void 0!==t.wireframe&&(r.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(r.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(r.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(r.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(r.rotation=t.rotation),1!==t.linewidth&&(r.linewidth=t.linewidth),void 0!==t.dashSize&&(r.dashSize=t.dashSize),void 0!==t.gapSize&&(r.gapSize=t.gapSize),void 0!==t.scale&&(r.scale=t.scale),void 0!==t.polygonOffset&&(r.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(r.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(r.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.dithering&&(r.dithering=t.dithering),void 0!==t.alphaToCoverage&&(r.alphaToCoverage=t.alphaToCoverage),void 0!==t.premultipliedAlpha&&(r.premultipliedAlpha=t.premultipliedAlpha),void 0!==t.visible&&(r.visible=t.visible),void 0!==t.toneMapped&&(r.toneMapped=t.toneMapped),void 0!==t.userData&&(r.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?r.vertexColors=t.vertexColors>0:r.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const e in t.uniforms){const i=t.uniforms[e];switch(r.uniforms[e]={},i.type){case"t":r.uniforms[e].value=n(i.value);break;case"c":r.uniforms[e].value=(new Xn).setHex(i.value);break;case"v2":r.uniforms[e].value=(new Rn).fromArray(i.value);break;case"v3":r.uniforms[e].value=(new ur).fromArray(i.value);break;case"v4":r.uniforms[e].value=(new er).fromArray(i.value);break;case"m3":r.uniforms[e].value=(new Dn).fromArray(i.value);break;case"m4":r.uniforms[e].value=(new Br).fromArray(i.value);break;default:r.uniforms[e].value=i.value}}if(void 0!==t.defines&&(r.defines=t.defines),void 0!==t.vertexShader&&(r.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(r.fragmentShader=t.fragmentShader),void 0!==t.extensions)for(const e in t.extensions)r.extensions[e]=t.extensions[e];if(void 0!==t.shading&&(r.flatShading=1===t.shading),void 0!==t.size&&(r.size=t.size),void 0!==t.sizeAttenuation&&(r.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(r.map=n(t.map)),void 0!==t.matcap&&(r.matcap=n(t.matcap)),void 0!==t.alphaMap&&(r.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(r.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(r.bumpScale=t.bumpScale),void 0!==t.normalMap&&(r.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(r.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),r.normalScale=(new Rn).fromArray(e)}return void 0!==t.displacementMap&&(r.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(r.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(r.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(r.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(r.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(r.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(r.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(r.specularMap=n(t.specularMap)),void 0!==t.specularIntensityMap&&(r.specularIntensityMap=n(t.specularIntensityMap)),void 0!==t.specularColorMap&&(r.specularColorMap=n(t.specularColorMap)),void 0!==t.envMap&&(r.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(r.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(r.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(r.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(r.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(r.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(r.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(r.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(r.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(r.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(r.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(r.clearcoatNormalScale=(new Rn).fromArray(t.clearcoatNormalScale)),void 0!==t.iridescenceMap&&(r.iridescenceMap=n(t.iridescenceMap)),void 0!==t.iridescenceThicknessMap&&(r.iridescenceThicknessMap=n(t.iridescenceThicknessMap)),void 0!==t.transmissionMap&&(r.transmissionMap=n(t.transmissionMap)),void 0!==t.thicknessMap&&(r.thicknessMap=n(t.thicknessMap)),void 0!==t.sheenColorMap&&(r.sheenColorMap=n(t.sheenColorMap)),void 0!==t.sheenRoughnessMap&&(r.sheenRoughnessMap=n(t.sheenRoughnessMap)),r}setTextures(t){return this.textures=t,this}static createMaterialFromType(t){return new{ShadowMaterial:jc,SpriteMaterial:bl,RawShaderMaterial:qc,ShaderMaterial:gs,PointsMaterial:pu,MeshPhysicalMaterial:Kc,MeshStandardMaterial:Xc,MeshPhongMaterial:Yc,MeshToonMaterial:Zc,MeshNormalMaterial:Jc,MeshLambertMaterial:Qc,MeshDepthMaterial:Yo,MeshDistanceMaterial:Zo,MeshBasicMaterial:ki,MeshMatcapMaterial:th,LineDashedMaterial:eh,LineBasicMaterial:nu,Material:Ii}[t]}}class nd{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,r=t.length;n<r;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.slice(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class rd extends ji{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class id extends Mh{constructor(t){super(t)}load(t,e,n,r){const i=this,s=new Eh(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(t,(function(n){try{e(i.parse(JSON.parse(n)))}catch(e){r?r(e):console.error(e),i.manager.itemError(t)}}),n,r)}parse(t){const e={},n={};function r(t,r){if(void 0!==e[r])return e[r];const i=t.interleavedBuffers[r],s=function(t,e){if(void 0!==n[e])return n[e];const r=t.arrayBuffers[e],i=new Uint32Array(r).buffer;return n[e]=i,i}(t,i.buffer),a=$n(i.type,s),o=new xl(a,i.stride);return o.uuid=i.uuid,e[r]=o,o}const i=t.isInstancedBufferGeometry?new rd:new ji,s=t.data.index;if(void 0!==s){const t=$n(s.type,s.array);i.setIndex(new Ci(t,1))}const a=t.data.attributes;for(const e in a){const n=a[e];let s;if(n.isInterleavedBufferAttribute){const e=r(t.data,n.data);s=new vl(e,n.itemSize,n.offset,n.normalized)}else{const t=$n(n.type,n.array);s=new(n.isInstancedBufferAttribute?Yl:Ci)(t,n.itemSize,n.normalized)}void 0!==n.name&&(s.name=n.name),void 0!==n.usage&&s.setUsage(n.usage),void 0!==n.updateRange&&(s.updateRange.offset=n.updateRange.offset,s.updateRange.count=n.updateRange.count),i.setAttribute(e,s)}const o=t.data.morphAttributes;if(o)for(const e in o){const n=o[e],s=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];let a;if(i.isInterleavedBufferAttribute){const e=r(t.data,i.data);a=new vl(e,i.itemSize,i.offset,i.normalized)}else{const t=$n(i.type,i.array);a=new Ci(t,i.itemSize,i.normalized)}void 0!==i.name&&(a.name=i.name),s.push(a)}i.morphAttributes[e]=s}t.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let t=0,e=l.length;t!==e;++t){const e=l[t];i.addGroup(e.start,e.count,e.materialIndex)}const u=t.data.boundingSphere;if(void 0!==u){const t=new ur;void 0!==u.center&&t.fromArray(u.center),i.boundingSphere=new Nr(t,u.radius)}return t.name&&(i.name=t.name),t.userData&&(i.userData=t.userData),i}}class sd extends Mh{constructor(t){super(t)}load(t,e,n,r){const i=this,s=""===this.path?nd.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||s;const a=new Eh(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,(function(n){let s=null;try{s=JSON.parse(n)}catch(e){return void 0!==r&&r(e),void console.error("THREE:ObjectLoader: Can't parse "+t+".",e.message)}const a=s.metadata;void 0!==a&&void 0!==a.type&&"geometry"!==a.type.toLowerCase()?i.parse(s,e):console.error("THREE.ObjectLoader: Can't load "+t)}),n,r)}async loadAsync(t,e){const n=""===this.path?nd.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||n;const r=new Eh(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const i=await r.loadAsync(t,e),s=JSON.parse(i),a=s.metadata;if(void 0===a||void 0===a.type||"geometry"===a.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+t);return await this.parseAsync(s)}parse(t,e){const n=this.parseAnimations(t.animations),r=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,r),s=this.parseImages(t.images,(function(){void 0!==e&&e(l)})),a=this.parseTextures(t.textures,s),o=this.parseMaterials(t.materials,a),l=this.parseObject(t.object,i,o,a,n),u=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,u),void 0!==e){let t=!1;for(const e in s)if(s[e].data instanceof HTMLImageElement){t=!0;break}!1===t&&e(l)}return l}async parseAsync(t){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,n),i=await this.parseImagesAsync(t.images),s=this.parseTextures(t.textures,i),a=this.parseMaterials(t.materials,s),o=this.parseObject(t.object,r,a,s,e),l=this.parseSkeletons(t.skeletons,o);return this.bindSkeletons(o,l),o}parseShapes(t){const e={};if(void 0!==t)for(let n=0,r=t.length;n<r;n++){const r=(new ic).fromJSON(t[n]);e[r.uuid]=r}return e}parseSkeletons(t,e){const n={},r={};if(e.traverse((function(t){t.isBone&&(r[t.uuid]=t)})),void 0!==t)for(let e=0,i=t.length;e<i;e++){const i=(new Kl).fromJSON(t[e],r);n[i.uuid]=i}return n}parseGeometries(t,e){const n={};if(void 0!==t){const r=new id;for(let i=0,s=t.length;i<s;i++){let s;const a=t[i];switch(a.type){case"BufferGeometry":case"InstancedBufferGeometry":s=r.parse(a);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:a.type in Hc?s=Hc[a.type].fromJSON(a,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)}s.uuid=a.uuid,void 0!==a.name&&(s.name=a.name),!0===s.isBufferGeometry&&void 0!==a.userData&&(s.userData=a.userData),n[a.uuid]=s}}return n}parseMaterials(t,e){const n={},r={};if(void 0!==t){const i=new ed;i.setTextures(e);for(let e=0,s=t.length;e<s;e++){const s=t[e];if("MultiMaterial"===s.type){const t=[];for(let e=0;e<s.materials.length;e++){const r=s.materials[e];void 0===n[r.uuid]&&(n[r.uuid]=i.parse(r)),t.push(n[r.uuid])}r[s.uuid]=t}else void 0===n[s.uuid]&&(n[s.uuid]=i.parse(s)),r[s.uuid]=n[s.uuid]}}return r}parseAnimations(t){const e={};if(void 0!==t)for(let n=0;n<t.length;n++){const r=t[n],i=wh.parse(r);e[i.uuid]=i}return e}parseImages(t,e){const n=this,r={};let i;function s(t){if("string"==typeof t){const e=t;return function(t){return n.manager.itemStart(t),i.load(t,(function(){n.manager.itemEnd(t)}),void 0,(function(){n.manager.itemError(t),n.manager.itemEnd(t)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:n.resourcePath+e)}return t.data?{data:$n(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const n=new Ih(e);i=new Rh(n),i.setCrossOrigin(this.crossOrigin);for(let e=0,n=t.length;e<n;e++){const n=t[e],i=n.url;if(Array.isArray(i)){const t=[];for(let e=0,n=i.length;e<n;e++){const n=s(i[e]);null!==n&&(n instanceof HTMLImageElement?t.push(n):t.push(new jl(n.data,n.width,n.height)))}r[n.uuid]=new Zn(t)}else{const t=s(n.url);r[n.uuid]=new Zn(t)}}}return r}async parseImagesAsync(t){const e=this,n={};let r;async function i(t){if("string"==typeof t){const n=t,i=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)?n:e.resourcePath+n;return await r.loadAsync(i)}return t.data?{data:$n(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){r=new Rh(this.manager),r.setCrossOrigin(this.crossOrigin);for(let e=0,r=t.length;e<r;e++){const r=t[e],s=r.url;if(Array.isArray(s)){const t=[];for(let e=0,n=s.length;e<n;e++){const n=s[e],r=await i(n);null!==r&&(r instanceof HTMLImageElement?t.push(r):t.push(new jl(r.data,r.width,r.height)))}n[r.uuid]=new Zn(t)}else{const t=await i(r.url);n[r.uuid]=new Zn(t)}}}return n}parseTextures(t,e){function n(t,e){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}const r={};if(void 0!==t)for(let i=0,s=t.length;i<s;i++){const s=t[i];void 0===s.image&&console.warn('THREE.ObjectLoader: No "image" specified for',s.uuid),void 0===e[s.image]&&console.warn("THREE.ObjectLoader: Undefined image",s.image);const a=e[s.image],o=a.data;let l;Array.isArray(o)?(l=new ws,6===o.length&&(l.needsUpdate=!0)):(l=o&&o.data?new jl:new tr,o&&(l.needsUpdate=!0)),l.source=a,l.uuid=s.uuid,void 0!==s.name&&(l.name=s.name),void 0!==s.mapping&&(l.mapping=n(s.mapping,ad)),void 0!==s.offset&&l.offset.fromArray(s.offset),void 0!==s.repeat&&l.repeat.fromArray(s.repeat),void 0!==s.center&&l.center.fromArray(s.center),void 0!==s.rotation&&(l.rotation=s.rotation),void 0!==s.wrap&&(l.wrapS=n(s.wrap[0],od),l.wrapT=n(s.wrap[1],od)),void 0!==s.format&&(l.format=s.format),void 0!==s.type&&(l.type=s.type),void 0!==s.encoding&&(l.encoding=s.encoding),void 0!==s.minFilter&&(l.minFilter=n(s.minFilter,ld)),void 0!==s.magFilter&&(l.magFilter=n(s.magFilter,ld)),void 0!==s.anisotropy&&(l.anisotropy=s.anisotropy),void 0!==s.flipY&&(l.flipY=s.flipY),void 0!==s.premultiplyAlpha&&(l.premultiplyAlpha=s.premultiplyAlpha),void 0!==s.unpackAlignment&&(l.unpackAlignment=s.unpackAlignment),void 0!==s.userData&&(l.userData=s.userData),r[s.uuid]=l}return r}parseObject(t,e,n,r,i){let s,a,o;function l(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function u(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let r=0,i=t.length;r<i;r++){const i=t[r];void 0===n[i]&&console.warn("THREE.ObjectLoader: Undefined material",i),e.push(n[i])}return e}return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),n[t]}}function c(t){return void 0===r[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),r[t]}switch(t.type){case"Scene":s=new gl,void 0!==t.background&&(Number.isInteger(t.background)?s.background=new Xn(t.background):s.background=c(t.background)),void 0!==t.environment&&(s.environment=c(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?s.fog=new ml(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(s.fog=new fl(t.fog.color,t.fog.density)));break;case"PerspectiveCamera":s=new ys(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(s.focus=t.focus),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.filmGauge&&(s.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(s.filmOffset=t.filmOffset),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"OrthographicCamera":s=new Ws(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(s.zoom=t.zoom),void 0!==t.view&&(s.view=Object.assign({},t.view));break;case"AmbientLight":s=new Zh(t.color,t.intensity);break;case"DirectionalLight":s=new Yh(t.color,t.intensity);break;case"PointLight":s=new Xh(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":s=new Jh(t.color,t.intensity,t.width,t.height);break;case"SpotLight":s=new Vh(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":s=new Ph(t.color,t.groundColor,t.intensity);break;case"LightProbe":s=(new td).fromJSON(t);break;case"SkinnedMesh":a=l(t.geometry),o=u(t.material),s=new Gl(a,o),void 0!==t.bindMode&&(s.bindMode=t.bindMode),void 0!==t.bindMatrix&&s.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(s.skeleton=t.skeleton);break;case"Mesh":a=l(t.geometry),o=u(t.material),s=new cs(a,o);break;case"InstancedMesh":a=l(t.geometry),o=u(t.material);const e=t.count,n=t.instanceMatrix,r=t.instanceColor;s=new eu(a,o,e),s.instanceMatrix=new Yl(new Float32Array(n.array),16),void 0!==r&&(s.instanceColor=new Yl(new Float32Array(r.array),r.itemSize));break;case"LOD":s=new Ol;break;case"Line":s=new lu(l(t.geometry),u(t.material));break;case"LineLoop":s=new du(l(t.geometry),u(t.material));break;case"LineSegments":s=new hu(l(t.geometry),u(t.material));break;case"PointCloud":case"Points":s=new yu(l(t.geometry),u(t.material));break;case"Sprite":s=new Ll(u(t.material));break;case"Group":s=new sl;break;case"Bone":s=new Hl;break;default:s=new hi}if(s.uuid=t.uuid,void 0!==t.name&&(s.name=t.name),void 0!==t.matrix?(s.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(s.matrixAutoUpdate=t.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(void 0!==t.position&&s.position.fromArray(t.position),void 0!==t.rotation&&s.rotation.fromArray(t.rotation),void 0!==t.quaternion&&s.quaternion.fromArray(t.quaternion),void 0!==t.scale&&s.scale.fromArray(t.scale)),void 0!==t.castShadow&&(s.castShadow=t.castShadow),void 0!==t.receiveShadow&&(s.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(s.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(s.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(s.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&s.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(s.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(s.visible=t.visible),void 0!==t.frustumCulled&&(s.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(s.renderOrder=t.renderOrder),void 0!==t.userData&&(s.userData=t.userData),void 0!==t.layers&&(s.layers.mask=t.layers),void 0!==t.children){const a=t.children;for(let t=0;t<a.length;t++)s.add(this.parseObject(a[t],e,n,r,i))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const n=e[t];s.animations.push(i[n])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(s.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const n=e[t],r=s.getObjectByProperty("uuid",n.object);void 0!==r&&s.addLevel(r,n.distance)}}return s}bindSkeletons(t,e){0!==Object.keys(e).length&&t.traverse((function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const n=e[t.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}}))}}const ad={UVMapping:ot,CubeReflectionMapping:lt,CubeRefractionMapping:ut,EquirectangularReflectionMapping:ct,EquirectangularRefractionMapping:ht,CubeUVReflectionMapping:dt},od={RepeatWrapping:pt,ClampToEdgeWrapping:ft,MirroredRepeatWrapping:mt},ld={NearestFilter:gt,NearestMipmapNearestFilter:xt,NearestMipmapLinearFilter:vt,LinearFilter:wt,LinearMipmapNearestFilter:St,LinearMipmapLinearFilter:It};class ud extends Mh{constructor(t){super(t),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const i=this,s=_h.get(t);if(void 0!==s)return i.manager.itemStart(t),setTimeout((function(){e&&e(s),i.manager.itemEnd(t)}),0),s;const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader,fetch(t,a).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,Object.assign(i.options,{colorSpaceConversion:"none"}))})).then((function(n){_h.add(t,n),e&&e(n),i.manager.itemEnd(t)})).catch((function(e){r&&r(e),i.manager.itemError(t),i.manager.itemEnd(t)})),i.manager.itemStart(t)}}let cd;const hd={getContext:function(){return void 0===cd&&(cd=new(window.AudioContext||window.webkitAudioContext)),cd},setContext:function(t){cd=t}};class dd extends Mh{constructor(t){super(t)}load(t,e,n,r){const i=this,s=new Eh(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,(function(n){try{const t=n.slice(0);hd.getContext().decodeAudioData(t,(function(t){e(t)}))}catch(e){r?r(e):console.error(e),i.manager.itemError(t)}}),n,r)}}class pd extends td{constructor(t,e,n=1){super(void 0,n),this.isHemisphereLightProbe=!0;const r=(new Xn).set(t),i=(new Xn).set(e),s=new ur(r.r,r.g,r.b),a=new ur(i.r,i.g,i.b),o=Math.sqrt(Math.PI),l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)}}class fd extends td{constructor(t,e=1){super(void 0,e),this.isAmbientLightProbe=!0;const n=(new Xn).set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}const md=new Br,gd=new Br,xd=new Br;class yd{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ys,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ys,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep,xd.copy(t.projectionMatrix);const n=e.eyeSep/2,r=n*e.near/e.focus,i=e.near*Math.tan(Sn*e.fov*.5)/e.zoom;let s,a;gd.elements[12]=-n,md.elements[12]=n,s=-i*e.aspect+r,a=i*e.aspect+r,xd.elements[0]=2*e.near/(a-s),xd.elements[8]=(a+s)/(a-s),this.cameraL.projectionMatrix.copy(xd),s=-i*e.aspect-r,a=i*e.aspect-r,xd.elements[0]=2*e.near/(a-s),xd.elements[8]=(a+s)/(a-s),this.cameraR.projectionMatrix.copy(xd)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(gd),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(md)}}class vd{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=bd(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=bd();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function bd(){return("undefined"==typeof performance?Date:performance).now()}const wd=new ur,Sd=new lr,_d=new ur,Id=new ur;class kd extends hi{constructor(){super(),this.type="AudioListener",this.context=hd.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new vd}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(wd,Sd,_d),Id.set(0,0,-1).applyQuaternion(Sd),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(wd.x,t),e.positionY.linearRampToValueAtTime(wd.y,t),e.positionZ.linearRampToValueAtTime(wd.z,t),e.forwardX.linearRampToValueAtTime(Id.x,t),e.forwardY.linearRampToValueAtTime(Id.y,t),e.forwardZ.linearRampToValueAtTime(Id.z,t),e.upX.linearRampToValueAtTime(n.x,t),e.upY.linearRampToValueAtTime(n.y,t),e.upZ.linearRampToValueAtTime(n.z,t)}else e.setPosition(wd.x,wd.y,wd.z),e.setOrientation(Id.x,Id.y,Id.z,n.x,n.y,n.z)}}class Md extends hi{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const Td=new ur,Cd=new lr,Ed=new ur,Ad=new ur;class Nd extends Md{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(Td,Cd,Ed),Ad.set(0,0,1).applyQuaternion(Cd);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(Td.x,t),e.positionY.linearRampToValueAtTime(Td.y,t),e.positionZ.linearRampToValueAtTime(Td.z,t),e.orientationX.linearRampToValueAtTime(Ad.x,t),e.orientationY.linearRampToValueAtTime(Ad.y,t),e.orientationZ.linearRampToValueAtTime(Ad.z,t)}else e.setPosition(Td.x,Td.y,Td.z),e.setOrientation(Ad.x,Ad.y,Ad.z)}}class Rd{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}}class Dd{constructor(t,e,n){let r,i,s;switch(this.binding=t,this.valueSize=n,e){case"quaternion":r=this._slerp,i=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":r=this._select,i=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:r=this._lerp,i=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=i,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,r=this.valueSize,i=t*r+r;let s=this.cumulativeWeight;if(0===s){for(let t=0;t!==r;++t)n[i+t]=n[t];s=e}else{s+=e;const t=e/s;this._mixBufferRegion(n,i,0,t,r)}this.cumulativeWeight=s}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,r=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,r=t*e+e,i=this.cumulativeWeight,s=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const t=e*this._origIndex;this._mixBufferRegion(n,r,t,1-i,e)}s>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*e,1,e);for(let t=e,i=e+e;t!==i;++t)if(n[t]!==n[t+e]){a.setValue(n,r);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,r=n*this._origIndex;t.getValue(e,r);for(let t=n,i=r;t!==i;++t)e[t]=e[r+t%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,r,i){if(r>=.5)for(let r=0;r!==i;++r)t[e+r]=t[n+r]}_slerp(t,e,n,r){lr.slerpFlat(t,e,t,e,t,n,r)}_slerpAdditive(t,e,n,r,i){const s=this._workIndex*i;lr.multiplyQuaternionsFlat(t,s,t,e,t,n),lr.slerpFlat(t,e,t,e,t,s,r)}_lerp(t,e,n,r,i){const s=1-r;for(let a=0;a!==i;++a){const i=e+a;t[i]=t[i]*s+t[n+a]*r}}_lerpAdditive(t,e,n,r,i){for(let s=0;s!==i;++s){const i=e+s;t[i]=t[i]+t[n+s]*r}}}const Ld="\\[\\]\\.:\\/",Fd=new RegExp("["+Ld+"]","g"),$d="[^"+Ld+"]",Pd="[^"+Ld.replace("\\.","")+"]",Od=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",$d)+/(WCOD+)?/.source.replace("WCOD",Pd)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",$d)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",$d)+"$"),zd=["material","materials","bones"];class Bd{constructor(t,e,n){this.path=e,this.parsedPath=n||Bd.parseTrackName(e),this.node=Bd.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new Bd.Composite(t,e,n):new Bd(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Fd,"")}static parseTrackName(t){const e=Od.exec(t);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const t=n.nodeName.substring(r+1);-1!==zd.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let r=0;r<t.length;r++){const i=t[r];if(i.name===e||i.uuid===e)return i;const s=n(i.children);if(s)return s}return null},r=n(t.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)t[e++]=n[r]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,r=e.propertyName;let i=e.propertyIndex;if(t||(t=Bd.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let r=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===r){r=e;break}break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==r){if(void 0===t[r])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[r]}}const s=t[r];if(void 0===s){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+r+" but it wasn't found.",t)}let a=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===r){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[i]&&(i=t.morphTargetDictionary[i])}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=i}else void 0!==s.fromArray&&void 0!==s.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=r;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Bd.Composite=class{constructor(t,e,n){const r=n||Bd.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,r)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];void 0!==r&&r.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},Bd.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Bd.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Bd.prototype.GetterByBindingType=[Bd.prototype._getValue_direct,Bd.prototype._getValue_array,Bd.prototype._getValue_arrayElement,Bd.prototype._getValue_toArray],Bd.prototype.SetterByBindingTypeAndVersioning=[[Bd.prototype._setValue_direct,Bd.prototype._setValue_direct_setNeedsUpdate,Bd.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Bd.prototype._setValue_array,Bd.prototype._setValue_array_setNeedsUpdate,Bd.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Bd.prototype._setValue_arrayElement,Bd.prototype._setValue_arrayElement_setNeedsUpdate,Bd.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Bd.prototype._setValue_fromArray,Bd.prototype._setValue_fromArray_setNeedsUpdate,Bd.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Ud{constructor(){this.isAnimationObjectGroup=!0,this.uuid=In(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let e=0,n=arguments.length;e!==n;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,n=this._paths,r=this._parsedPaths,i=this._bindings,s=i.length;let a,o=t.length,l=this.nCachedObjects_;for(let u=0,c=arguments.length;u!==c;++u){const c=arguments[u],h=c.uuid;let d=e[h];if(void 0===d){d=o++,e[h]=d,t.push(c);for(let t=0,e=s;t!==e;++t)i[t].push(new Bd(c,n[t],r[t]))}else if(d<l){a=t[d];const o=--l,u=t[o];e[u.uuid]=d,t[d]=u,e[h]=o,t[o]=c;for(let t=0,e=s;t!==e;++t){const e=i[t],s=e[o];let a=e[d];e[d]=s,void 0===a&&(a=new Bd(c,n[t],r[t])),e[o]=a}}else t[d]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_;for(let s=0,a=arguments.length;s!==a;++s){const a=arguments[s],o=a.uuid,l=e[o];if(void 0!==l&&l>=i){const s=i++,u=t[s];e[u.uuid]=l,t[l]=u,e[o]=s,t[s]=a;for(let t=0,e=r;t!==e;++t){const e=n[t],r=e[s],i=e[l];e[l]=r,e[s]=i}}}this.nCachedObjects_=i}uncache(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_,s=t.length;for(let a=0,o=arguments.length;a!==o;++a){const o=arguments[a].uuid,l=e[o];if(void 0!==l)if(delete e[o],l<i){const a=--i,o=t[a],u=--s,c=t[u];e[o.uuid]=l,t[l]=o,e[c.uuid]=a,t[a]=c,t.pop();for(let t=0,e=r;t!==e;++t){const e=n[t],r=e[a],i=e[u];e[l]=r,e[a]=i,e.pop()}}else{const i=--s,a=t[i];i>0&&(e[a.uuid]=l),t[l]=a,t.pop();for(let t=0,e=r;t!==e;++t){const e=n[t];e[l]=e[i],e.pop()}}}this.nCachedObjects_=i}subscribe_(t,e){const n=this._bindingsIndicesByPath;let r=n[t];const i=this._bindings;if(void 0!==r)return i[r];const s=this._paths,a=this._parsedPaths,o=this._objects,l=o.length,u=this.nCachedObjects_,c=new Array(l);r=i.length,n[t]=r,s.push(t),a.push(e),i.push(c);for(let n=u,r=o.length;n!==r;++n){const r=o[n];c[n]=new Bd(r,t,e)}return c}unsubscribe_(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const r=this._paths,i=this._parsedPaths,s=this._bindings,a=s.length-1,o=s[a];e[t[a]]=n,s[n]=o,s.pop(),i[n]=i[a],i.pop(),r[n]=r[a],r.pop()}}}class Wd{constructor(t,e,n=null,r=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=r;const i=e.tracks,s=i.length,a=new Array(s),o={endingStart:Te,endingEnd:Te};for(let t=0;t!==s;++t){const e=i[t].createInterpolant(null);a[t]=e,e.settings=o}this._interpolantSettings=o,this._interpolants=a,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Se,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,r=t._clip.duration,i=r/n,s=n/r;t.warp(1,i,e),this.warp(s,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const r=this._mixer,i=r.time,s=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=i,o[1]=i+n,l[0]=t/s,l[1]=e/s,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,r){if(!this.enabled)return void this._updateWeight(t);const i=this._startTime;if(null!==i){const r=(t-i)*n;if(r<0||0===n)return;this._startTime=null,e=n*r}e*=this._updateTimeScale(t);const s=this._updateTime(e),a=this._updateWeight(t);if(a>0){const t=this._interpolants,e=this._propertyBindings;if(this.blendMode===Ne)for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(s),e[n].accumulateAdditive(a);else for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(s),e[n].accumulate(r,a)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const r=n.evaluate(t)[0];e*=r,t>n.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let r=this.time+t,i=this._loopCount;const s=n===_e;if(0===t)return-1===i?r:s&&1==(1&i)?e-r:r;if(n===we){-1===i&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(r>=e)r=e;else{if(!(r<0)){this.time=r;break t}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===i&&(t>=0?(i=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),r>=e||r<0){const n=Math.floor(r/e);r-=e*n,i+=Math.abs(n);const a=this.repetitions-i;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===a){const e=t<0;this._setEndings(e,!e,s)}else this._setEndings(!1,!1,s);this._loopCount=i,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=r;if(s&&1==(1&i))return e-r}return r}_setEndings(t,e,n){const r=this._interpolantSettings;n?(r.endingStart=Ce,r.endingEnd=Ce):(r.endingStart=t?this.zeroSlopeAtStart?Ce:Te:Ee,r.endingEnd=e?this.zeroSlopeAtEnd?Ce:Te:Ee)}_scheduleFading(t,e,n){const r=this._mixer,i=r.time;let s=this._weightInterpolant;null===s&&(s=r._lendControlInterpolant(),this._weightInterpolant=s);const a=s.parameterPositions,o=s.sampleValues;return a[0]=i,o[0]=e,a[1]=i+t,o[1]=n,this}}const Vd=new Float32Array(1);class Gd extends vn{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,r=t._clip.tracks,i=r.length,s=t._propertyBindings,a=t._interpolants,o=n.uuid,l=this._bindingsByRootAndName;let u=l[o];void 0===u&&(u={},l[o]=u);for(let t=0;t!==i;++t){const i=r[t],l=i.name;let c=u[l];if(void 0!==c)++c.referenceCount,s[t]=c;else{if(c=s[t],void 0!==c){null===c._cacheIndex&&(++c.referenceCount,this._addInactiveBinding(c,o,l));continue}const r=e&&e._propertyBindings[t].binding.parsedPath;c=new Dd(Bd.create(n,l,r),i.ValueTypeName,i.getValueSize()),++c.referenceCount,this._addInactiveBinding(c,o,l),s[t]=c}a[t].resultBuffer=c.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,r=this._actionsByClip[n];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,n){const r=this._actions,i=this._actionsByClip;let s=i[e];if(void 0===s)s={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,i[e]=s;else{const e=s.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=r.length,r.push(t),s.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],r=t._cacheIndex;n._cacheIndex=r,e[r]=n,e.pop(),t._cacheIndex=null;const i=t._clip.uuid,s=this._actionsByClip,a=s[i],o=a.knownActions,l=o[o.length-1],u=t._byClipCacheIndex;l._byClipCacheIndex=u,o[u]=l,o.pop(),t._byClipCacheIndex=null,delete a.actionByRoot[(t._localRoot||this._root).uuid],0===o.length&&delete s[i],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,r=this._nActiveActions++,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,r=--this._nActiveActions,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i}_addInactiveBinding(t,e,n){const r=this._bindingsByRootAndName,i=this._bindings;let s=r[e];void 0===s&&(s={},r[e]=s),s[n]=t,t._cacheIndex=i.length,i.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,r=n.rootNode.uuid,i=n.path,s=this._bindingsByRootAndName,a=s[r],o=e[e.length-1],l=t._cacheIndex;o._cacheIndex=l,e[l]=o,e.pop(),delete a[i],0===Object.keys(a).length&&delete s[r]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,r=this._nActiveBindings++,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,r=--this._nActiveBindings,i=e[r];t._cacheIndex=r,e[r]=t,i._cacheIndex=n,e[n]=i}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new hh(new Float32Array(2),new Float32Array(2),1,Vd),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,r=--this._nActiveControlInterpolants,i=e[r];t.__cacheIndex=r,e[r]=t,i.__cacheIndex=n,e[n]=i}clipAction(t,e,n){const r=e||this._root,i=r.uuid;let s="string"==typeof t?wh.findByName(r,t):t;const a=null!==s?s.uuid:t,o=this._actionsByClip[a];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:Ae),void 0!==o){const t=o.actionByRoot[i];if(void 0!==t&&t.blendMode===n)return t;l=o.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const u=new Wd(this,s,e,n);return this._bindAction(u,l),this._addInactiveAction(u,a,i),u}existingAction(t,e){const n=e||this._root,r=n.uuid,i="string"==typeof t?wh.findByName(n,t):t,s=i?i.uuid:t,a=this._actionsByClip[s];return void 0!==a&&a.actionByRoot[r]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,r=this.time+=t,i=Math.sign(t),s=this._accuIndex^=1;for(let a=0;a!==n;++a)e[a]._update(r,t,i,s);const a=this._bindings,o=this._nActiveBindings;for(let t=0;t!==o;++t)a[t].apply(s);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,r=this._actionsByClip,i=r[n];if(void 0!==i){const t=i.knownActions;for(let n=0,r=t.length;n!==r;++n){const r=t[n];this._deactivateAction(r);const i=r._cacheIndex,s=e[e.length-1];r._cacheIndex=null,r._byClipCacheIndex=null,s._cacheIndex=i,e[i]=s,e.pop(),this._removeInactiveBindingsForAction(r)}delete r[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const t in n){const r=n[t].actionByRoot[e];void 0!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}const r=this._bindingsByRootAndName[e];if(void 0!==r)for(const t in r){const e=r[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}class Hd{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new Hd(void 0===this.value.clone?this.value:this.value.clone())}}let jd=0;class qd extends vn{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:jd++}),this.name="",this.usage=on,this.uniforms=[]}add(t){return this.uniforms.push(t),this}remove(t){const e=this.uniforms.indexOf(t);return-1!==e&&this.uniforms.splice(e,1),this}setName(t){return this.name=t,this}setUsage(t){return this.usage=t,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(t){this.name=t.name,this.usage=t.usage;const e=t.uniforms;this.uniforms.length=0;for(let t=0,n=e.length;t<n;t++)this.uniforms.push(e[t].clone());return this}clone(){return(new this.constructor).copy(this)}}class Xd extends xl{constructor(t,e,n=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}class Kd{constructor(t,e,n,r,i){this.isGLBufferAttribute=!0,this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=r,this.count=i,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}class Yd{constructor(t,e,n=0,r=1/0){this.ray=new zr(t,e),this.near=n,this.far=r,this.camera=null,this.layers=new Zr,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!0,n=[]){return Jd(t,this,n,e),n.sort(Zd),n}intersectObjects(t,e=!0,n=[]){for(let r=0,i=t.length;r<i;r++)Jd(t[r],this,n,e);return n.sort(Zd),n}}function Zd(t,e){return t.distance-e.distance}function Jd(t,e,n,r){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===r){const r=t.children;for(let t=0,i=r.length;t<i;t++)Jd(r[t],e,n,!0)}}class Qd{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(kn(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class tp{constructor(t=1,e=0,n=0){return this.radius=t,this.theta=e,this.y=n,this}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return(new this.constructor).copy(this)}}const ep=new Rn;class np{constructor(t=new Rn(1/0,1/0),e=new Rn(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=ep.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return ep.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const rp=new ur,ip=new ur;class sp{constructor(t=new ur,e=new ur){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){rp.subVectors(t,this.start),ip.subVectors(this.end,this.start);const n=ip.dot(ip);let r=ip.dot(rp)/n;return e&&(r=kn(r,0,1)),r}closestPointToPoint(t,e,n){const r=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(r).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const ap=new ur;class op extends hi{constructor(t,e){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;const n=new ji,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,n=32;t<n;t++,e++){const i=t/n*Math.PI*2,s=e/n*Math.PI*2;r.push(Math.cos(i),Math.sin(i),1,Math.cos(s),Math.sin(s),1)}n.setAttribute("position",new Pi(r,3));const i=new nu({fog:!1,toneMapped:!1});this.cone=new hu(n,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),ap.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(ap),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const lp=new ur,up=new Br,cp=new Br;class hp extends hu{constructor(t){const e=dp(t),n=new ji,r=[],i=[],s=new Xn(0,0,1),a=new Xn(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),i.push(s.r,s.g,s.b),i.push(a.r,a.g,a.b))}n.setAttribute("position",new Pi(r,3)),n.setAttribute("color",new Pi(i,3)),super(n,new nu({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,r=n.getAttribute("position");cp.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const i=e[t];i.parent&&i.parent.isBone&&(up.multiplyMatrices(cp,i.matrixWorld),lp.setFromMatrixPosition(up),r.setXYZ(n,lp.x,lp.y,lp.z),up.multiplyMatrices(cp,i.parent.matrixWorld),lp.setFromMatrixPosition(up),r.setXYZ(n+1,lp.x,lp.y,lp.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function dp(t){const e=[];!0===t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,dp(t.children[n]));return e}class pp extends cs{constructor(t,e,n){super(new Oc(e,4,2),new ki({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const fp=new ur,mp=new Xn,gp=new Xn;class xp extends hi{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const r=new Fc(e);r.rotateY(.5*Math.PI),this.material=new ki({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const i=r.getAttribute("position"),s=new Float32Array(3*i.count);r.setAttribute("color",new Ci(s,3)),this.add(new cs(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");mp.copy(this.light.color),gp.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){const r=t<n/2?mp:gp;e.setXYZ(t,r.r,r.g,r.b)}e.needsUpdate=!0}t.lookAt(fp.setFromMatrixPosition(this.light.matrixWorld).negate())}}class yp extends hu{constructor(t=10,e=10,n=4473924,r=8947848){n=new Xn(n),r=new Xn(r);const i=e/2,s=t/e,a=t/2,o=[],l=[];for(let t=0,u=0,c=-a;t<=e;t++,c+=s){o.push(-a,0,c,a,0,c),o.push(c,0,-a,c,0,a);const e=t===i?n:r;e.toArray(l,u),u+=3,e.toArray(l,u),u+=3,e.toArray(l,u),u+=3,e.toArray(l,u),u+=3}const u=new ji;u.setAttribute("position",new Pi(o,3)),u.setAttribute("color",new Pi(l,3)),super(u,new nu({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}class vp extends hu{constructor(t=10,e=16,n=8,r=64,i=4473924,s=8947848){i=new Xn(i),s=new Xn(s);const a=[],o=[];for(let n=0;n<=e;n++){const r=n/e*(2*Math.PI),l=Math.sin(r)*t,u=Math.cos(r)*t;a.push(0,0,0),a.push(l,0,u);const c=1&n?i:s;o.push(c.r,c.g,c.b),o.push(c.r,c.g,c.b)}for(let e=0;e<=n;e++){const l=1&e?i:s,u=t-t/n*e;for(let t=0;t<r;t++){let e=t/r*(2*Math.PI),n=Math.sin(e)*u,i=Math.cos(e)*u;a.push(n,0,i),o.push(l.r,l.g,l.b),e=(t+1)/r*(2*Math.PI),n=Math.sin(e)*u,i=Math.cos(e)*u,a.push(n,0,i),o.push(l.r,l.g,l.b)}}const l=new ji;l.setAttribute("position",new Pi(a,3)),l.setAttribute("color",new Pi(o,3)),super(l,new nu({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}}const bp=new ur,wp=new ur,Sp=new ur;class _p extends hi{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===e&&(e=1);let r=new ji;r.setAttribute("position",new Pi([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const i=new nu({fog:!1,toneMapped:!1});this.lightPlane=new lu(r,i),this.add(this.lightPlane),r=new ji,r.setAttribute("position",new Pi([0,0,0,0,0,1],3)),this.targetLine=new lu(r,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){bp.setFromMatrixPosition(this.light.matrixWorld),wp.setFromMatrixPosition(this.light.target.matrixWorld),Sp.subVectors(wp,bp),this.lightPlane.lookAt(wp),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(wp),this.targetLine.scale.z=Sp.length()}}const Ip=new ur,kp=new xs;class Mp extends hu{constructor(t){const e=new ji,n=new nu({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],i=[],s={};function a(t,e){o(t),o(e)}function o(t){r.push(0,0,0),i.push(0,0,0),void 0===s[t]&&(s[t]=[]),s[t].push(r.length/3-1)}a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4"),e.setAttribute("position",new Pi(r,3)),e.setAttribute("color",new Pi(i,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update();const l=new Xn(16755200),u=new Xn(16711680),c=new Xn(43775),h=new Xn(16777215),d=new Xn(3355443);this.setColors(l,u,c,h,d)}setColors(t,e,n,r,i){const s=this.geometry.getAttribute("color");s.setXYZ(0,t.r,t.g,t.b),s.setXYZ(1,t.r,t.g,t.b),s.setXYZ(2,t.r,t.g,t.b),s.setXYZ(3,t.r,t.g,t.b),s.setXYZ(4,t.r,t.g,t.b),s.setXYZ(5,t.r,t.g,t.b),s.setXYZ(6,t.r,t.g,t.b),s.setXYZ(7,t.r,t.g,t.b),s.setXYZ(8,t.r,t.g,t.b),s.setXYZ(9,t.r,t.g,t.b),s.setXYZ(10,t.r,t.g,t.b),s.setXYZ(11,t.r,t.g,t.b),s.setXYZ(12,t.r,t.g,t.b),s.setXYZ(13,t.r,t.g,t.b),s.setXYZ(14,t.r,t.g,t.b),s.setXYZ(15,t.r,t.g,t.b),s.setXYZ(16,t.r,t.g,t.b),s.setXYZ(17,t.r,t.g,t.b),s.setXYZ(18,t.r,t.g,t.b),s.setXYZ(19,t.r,t.g,t.b),s.setXYZ(20,t.r,t.g,t.b),s.setXYZ(21,t.r,t.g,t.b),s.setXYZ(22,t.r,t.g,t.b),s.setXYZ(23,t.r,t.g,t.b),s.setXYZ(24,e.r,e.g,e.b),s.setXYZ(25,e.r,e.g,e.b),s.setXYZ(26,e.r,e.g,e.b),s.setXYZ(27,e.r,e.g,e.b),s.setXYZ(28,e.r,e.g,e.b),s.setXYZ(29,e.r,e.g,e.b),s.setXYZ(30,e.r,e.g,e.b),s.setXYZ(31,e.r,e.g,e.b),s.setXYZ(32,n.r,n.g,n.b),s.setXYZ(33,n.r,n.g,n.b),s.setXYZ(34,n.r,n.g,n.b),s.setXYZ(35,n.r,n.g,n.b),s.setXYZ(36,n.r,n.g,n.b),s.setXYZ(37,n.r,n.g,n.b),s.setXYZ(38,r.r,r.g,r.b),s.setXYZ(39,r.r,r.g,r.b),s.setXYZ(40,i.r,i.g,i.b),s.setXYZ(41,i.r,i.g,i.b),s.setXYZ(42,i.r,i.g,i.b),s.setXYZ(43,i.r,i.g,i.b),s.setXYZ(44,i.r,i.g,i.b),s.setXYZ(45,i.r,i.g,i.b),s.setXYZ(46,i.r,i.g,i.b),s.setXYZ(47,i.r,i.g,i.b),s.setXYZ(48,i.r,i.g,i.b),s.setXYZ(49,i.r,i.g,i.b),s.needsUpdate=!0}update(){const t=this.geometry,e=this.pointMap;kp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Tp("c",e,t,kp,0,0,-1),Tp("t",e,t,kp,0,0,1),Tp("n1",e,t,kp,-1,-1,-1),Tp("n2",e,t,kp,1,-1,-1),Tp("n3",e,t,kp,-1,1,-1),Tp("n4",e,t,kp,1,1,-1),Tp("f1",e,t,kp,-1,-1,1),Tp("f2",e,t,kp,1,-1,1),Tp("f3",e,t,kp,-1,1,1),Tp("f4",e,t,kp,1,1,1),Tp("u1",e,t,kp,.7,1.1,-1),Tp("u2",e,t,kp,-.7,1.1,-1),Tp("u3",e,t,kp,0,2,-1),Tp("cf1",e,t,kp,-1,0,1),Tp("cf2",e,t,kp,1,0,1),Tp("cf3",e,t,kp,0,-1,1),Tp("cf4",e,t,kp,0,1,1),Tp("cn1",e,t,kp,-1,0,-1),Tp("cn2",e,t,kp,1,0,-1),Tp("cn3",e,t,kp,0,-1,-1),Tp("cn4",e,t,kp,0,1,-1),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Tp(t,e,n,r,i,s,a){Ip.set(i,s,a).unproject(r);const o=e[t];if(void 0!==o){const t=n.getAttribute("position");for(let e=0,n=o.length;e<n;e++)t.setXYZ(o[e],Ip.x,Ip.y,Ip.z)}}const Cp=new dr;class Ep extends hu{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(24),i=new ji;i.setIndex(new Ci(n,1)),i.setAttribute("position",new Ci(r,3)),super(i,new nu({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(void 0!==t&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&Cp.setFromObject(this.object),Cp.isEmpty())return;const e=Cp.min,n=Cp.max,r=this.geometry.attributes.position,i=r.array;i[0]=n.x,i[1]=n.y,i[2]=n.z,i[3]=e.x,i[4]=n.y,i[5]=n.z,i[6]=e.x,i[7]=e.y,i[8]=n.z,i[9]=n.x,i[10]=e.y,i[11]=n.z,i[12]=n.x,i[13]=n.y,i[14]=e.z,i[15]=e.x,i[16]=n.y,i[17]=e.z,i[18]=e.x,i[19]=e.y,i[20]=e.z,i[21]=n.x,i[22]=e.y,i[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,e){return super.copy(t,e),this.object=t.object,this}}class Ap extends hu{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new ji;r.setIndex(new Ci(n,1)),r.setAttribute("position",new Pi([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(r,new nu({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}}class Np extends lu{constructor(t,e=1,n=16776960){const r=n,i=new ji;i.setAttribute("position",new Pi([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),i.computeBoundingSphere(),super(i,new nu({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const s=new ji;s.setAttribute("position",new Pi([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),s.computeBoundingSphere(),this.add(new cs(s,new ki({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}}const Rp=new ur;let Dp,Lp;class Fp extends hi{constructor(t=new ur(0,0,1),e=new ur(0,0,0),n=1,r=16776960,i=.2*n,s=.2*i){super(),this.type="ArrowHelper",void 0===Dp&&(Dp=new ji,Dp.setAttribute("position",new Pi([0,0,0,0,1,0],3)),Lp=new Ku(0,.5,1,5,1),Lp.translate(0,-.5,0)),this.position.copy(e),this.line=new lu(Dp,new nu({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new cs(Lp,new ki({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,i,s)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Rp.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Rp,e)}}setLength(t,e=.2*t,n=.2*e){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}}class $p extends hu{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=new ji;n.setAttribute("position",new Pi(e,3)),n.setAttribute("color",new Pi([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new nu({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,n){const r=new Xn,i=this.geometry.attributes.color.array;return r.set(t),r.toArray(i,0),r.toArray(i,3),r.set(e),r.toArray(i,6),r.toArray(i,9),r.set(n),r.toArray(i,12),r.toArray(i,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Pp{constructor(){this.type="ShapePath",this.color=new Xn,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new Hu,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,r){return this.currentPath.quadraticCurveTo(t,e,n,r),this}bezierCurveTo(t,e,n,r,i,s){return this.currentPath.bezierCurveTo(t,e,n,r,i,s),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t,e){function n(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n],i=new ic;i.curves=r.curves,e.push(i)}return e}function r(t,e){const n=e.length;let r=!1;for(let i=n-1,s=0;s<n;i=s++){let n=e[i],a=e[s],o=a.x-n.x,l=a.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[s],o=-o,a=e[i],l=-l),t.y<n.y||t.y>a.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-o*(t.y-n.y);if(0===e)return!0;if(e<0)continue;r=!r}}else{if(t.y!==n.y)continue;if(a.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=a.x)return!0}}return r}const i=Ec.isClockWise,s=this.subPaths;if(0===s.length)return[];if(!0===e)return n(s);let a,o,l;const u=[];if(1===s.length)return o=s[0],l=new ic,l.curves=o.curves,u.push(l),u;let c=!i(s[0].getPoints());c=t?!c:c;const h=[],d=[];let p,f,m=[],g=0;d[g]=void 0,m[g]=[];for(let e=0,n=s.length;e<n;e++)o=s[e],p=o.getPoints(),a=i(p),a=t?!a:a,a?(!c&&d[g]&&g++,d[g]={s:new ic,p},d[g].s.curves=o.curves,c&&g++,m[g]=[]):m[g].push({h:o,p:p[0]});if(!d[0])return n(s);if(d.length>1){let t=!1,e=0;for(let t=0,e=d.length;t<e;t++)h[t]=[];for(let n=0,i=d.length;n<i;n++){const i=m[n];for(let s=0;s<i.length;s++){const a=i[s];let o=!0;for(let i=0;i<d.length;i++)r(a.p,d[i].p)&&(n!==i&&e++,o?(o=!1,h[i].push(a)):t=!0);o&&h[n].push(a)}}e>0&&!1===t&&(m=h)}for(let t=0,e=d.length;t<e;t++){l=d[t].s,u.push(l),f=m[t];for(let t=0,e=f.length;t<e;t++)l.holes.push(f[t].h)}return u}}const Op=zp();function zp(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),r=new Uint32Array(512),i=new Uint32Array(512);for(let t=0;t<256;++t){const e=t-127;e<-27?(r[t]=0,r[256|t]=32768,i[t]=24,i[256|t]=24):e<-14?(r[t]=1024>>-e-14,r[256|t]=1024>>-e-14|32768,i[t]=-e-1,i[256|t]=-e-1):e<=15?(r[t]=e+15<<10,r[256|t]=e+15<<10|32768,i[t]=13,i[256|t]=13):e<128?(r[t]=31744,r[256|t]=64512,i[t]=24,i[256|t]=24):(r[t]=31744,r[256|t]=64512,i[t]=13,i[256|t]=13)}const s=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let t=1;t<1024;++t){let e=t<<13,n=0;for(;0==(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,s[t]=e|n}for(let t=1024;t<2048;++t)s[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)a[t]=t<<23;a[31]=1199570944,a[32]=2147483648;for(let t=33;t<63;++t)a[t]=2147483648+(t-32<<23);a[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(o[t]=1024);return{floatView:e,uint32View:n,baseTable:r,shiftTable:i,mantissaTable:s,exponentTable:a,offsetTable:o}}var Bp=Object.freeze({__proto__:null,toHalfFloat:function(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=kn(t,-65504,65504),Op.floatView[0]=t;const e=Op.uint32View[0],n=e>>23&511;return Op.baseTable[n]+((8388607&e)>>Op.shiftTable[n])},fromHalfFloat:function(t){const e=t>>10;return Op.uint32View[0]=Op.mantissaTable[Op.offsetTable[e]+(1023&t)]+Op.exponentTable[e],Op.floatView[0]}});class Up extends ji{constructor(){console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),super()}}class Wp extends ji{constructor(){console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),super()}}function Vp(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")}function Gp(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")}function Hp(){console.error("THREE.ImmediateRenderObject has been removed.")}class jp extends nr{constructor(t,e,n){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(t,e,n),this.samples=4}}class qp extends rr{constructor(t,e,n,r){console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),super(t,e,n,r)}}class Xp extends sr{constructor(t,e,n,r){console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),super(t,e,n,r)}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:a}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=a);const Kp=new ur,Yp=new lr,Zp=new ur,Jp=new Br,Qp=new Br;class tf{constructor(t={}){const e=this;let n,r,i,s;const a={camera:{fov:0,style:""},objects:new WeakMap},o=void 0!==t.element?t.element:document.createElement("div");o.style.overflow="hidden",this.domElement=o;const l=document.createElement("div");function u(t){return Math.abs(t)<1e-10?0:t}function c(t){const e=t.elements;return"matrix3d("+u(e[0])+","+u(-e[1])+","+u(e[2])+","+u(e[3])+","+u(e[4])+","+u(-e[5])+","+u(e[6])+","+u(e[7])+","+u(e[8])+","+u(-e[9])+","+u(e[10])+","+u(e[11])+","+u(e[12])+","+u(-e[13])+","+u(e[14])+","+u(e[15])+")"}function h(t){const e=t.elements;return"translate(-50%,-50%)matrix3d("+u(e[0])+","+u(e[1])+","+u(e[2])+","+u(e[3])+","+u(-e[4])+","+u(-e[5])+","+u(-e[6])+","+u(-e[7])+","+u(e[8])+","+u(e[9])+","+u(e[10])+","+u(e[11])+","+u(e[12])+","+u(e[13])+","+u(e[14])+","+u(e[15])+")"}function d(t,n,r,i){if(t.isCSS3DObject){const i=!0===t.visible&&!0===t.layers.test(r.layers);if(t.element.style.display=!0===i?"":"none",!0===i){let i;t.onBeforeRender(e,n,r),t.isCSS3DSprite?(Jp.copy(r.matrixWorldInverse),Jp.transpose(),0!==t.rotation2D&&Jp.multiply(Qp.makeRotationZ(t.rotation2D)),t.matrixWorld.decompose(Kp,Yp,Zp),Jp.setPosition(Kp),Jp.scale(Zp),Jp.elements[3]=0,Jp.elements[7]=0,Jp.elements[11]=0,Jp.elements[15]=1,i=h(Jp)):i=h(t.matrixWorld);const s=t.element,o=a.objects.get(t);if(void 0===o||o.style!==i){s.style.transform=i;const e={style:i};a.objects.set(t,e)}s.parentNode!==l&&l.appendChild(s),t.onAfterRender(e,n,r)}}for(let e=0,s=t.children.length;e<s;e++)d(t.children[e],n,r,i)}l.style.transformStyle="preserve-3d",l.style.pointerEvents="none",o.appendChild(l),this.getSize=function(){return{width:n,height:r}},this.render=function(t,e){const n=e.projectionMatrix.elements[5]*s;let r,h;a.camera.fov!==n&&(o.style.perspective=e.isPerspectiveCamera?n+"px":"",a.camera.fov=n),!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),e.isOrthographicCamera&&(r=-(e.right+e.left)/2,h=(e.top+e.bottom)/2);const p=e.isOrthographicCamera?"scale("+n+")translate("+u(r)+"px,"+u(h)+"px)"+c(e.matrixWorldInverse):"translateZ("+n+"px)"+c(e.matrixWorldInverse),f=p+"translate("+i+"px,"+s+"px)";a.camera.style!==f&&(l.style.transform=f,a.camera.style=f),d(t,t,e,p)},this.setSize=function(t,e){n=t,r=e,i=n/2,s=r/2,o.style.width=t+"px",o.style.height=e+"px",l.style.width=t+"px",l.style.height=e+"px"}}}class ef{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class nf{refCount(t){return rf("refCount")}incRef(t){return rf("incRef")}timerAvailable(){return!0}time(t){return rf("time")}read(t){return rf("read")}readSync(t){return rf("readSync")}readToGPU(t,e){return rf("readToGPU")}numDataIds(){return rf("numDataIds")}disposeData(t,e){return rf("disposeData")}write(t,e,n){return rf("write")}move(t,e,n,r,i){return rf("move")}memory(){return rf("memory")}floatPrecision(){return rf("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return rf("dispose")}}function rf(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function sf(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,lf(t,e,n)}function af(t,e,n){return Math.max(t,Math.min(e,n))}function of(t){return t%2==0?t:t+1}function lf(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function uf(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function cf(t,e,n=""){uf(ff(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}function hf(t){uf(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function df(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||kf(t)&&!n)for(let r=0;r<t.length;++r)df(t[r],e,n);else e.push(t);return e}function pf(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function ff(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function mf(t){return t%1==0}function gf(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function xf(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function yf(t,e=(t=>0),n,r=setTimeout){return new Promise(((i,s)=>{let a=0;const o=()=>{if(t())return void i();a++;const l=e(a);null!=n&&a>=n?s():r(o,l)};o()}))}function vf(t,e){let n=1,r=-1;for(let e=0;e<t.length;++e)if(t[e]>=0)n*=t[e];else if(-1===t[e]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${e}`);r=e}else if(t[e]<0)throw Error(`Shapes can not be < 0. Found ${t[e]} at dim ${e}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const i=t.slice();return i[r]=e/n,i}function bf(t,e){const n=e.length;return uf((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),uf(t.every((t=>mf(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function wf(t,e){const n=[],r=[],i=null!=e&&Array.isArray(e)&&0===e.length,s=null==e||i?null:bf(e,t).sort();let a=0;for(let e=0;e<t.length;++e){if(null!=s){if(s[a]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==s[a]||s[a]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),s[a]<=e&&a++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function Sf(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function _f(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function If(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function kf(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function Mf(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function Tf(t){return"string"==typeof t||t instanceof String}function Cf(t){return"number"==typeof t}function Ef(t){return Array.isArray(t)?Ef(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":Cf(t)?"float32":Tf(t)?"string":"boolean"==typeof t?"bool":"float32"}function Af(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Nf(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function Rf(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function Df(t,e,n,r=!1){const i=new Array;if(1===e.length){const s=e[0]*(r?2:1);for(let e=0;e<s;e++)i[e]=n[t+e]}else{const s=e[0],a=e.slice(1),o=a.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<s;e++)i[e]=Df(t+e*o,a,n,r)}return i}function Lf(t,e,n=!1){if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Df(0,t,e,n)}function Ff(t,e){const n=$f(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function $f(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Pf(t,e){const n=t.reduce(((t,e)=>t*e),1);if(null==e||"float32"===e)return Lf(t,new Float32Array(n));if("int32"===e)return Lf(t,new Int32Array(n));if("bool"===e)return Lf(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function Of(t){t.forEach((e=>{uf(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}function zf(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let e=0;e<t.length-1;++e)r+=n[e]*t[e];return r}function Bf(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let e=0;e<r.length-1;++e)r[e]=Math.floor(t/n[e]),t-=r[e]*n[e];return r[r.length-1]=t,r}function Uf(t){return t&&t.then&&"function"==typeof t.then}const Wf="tfjsflags";class Vf{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Gf,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Hf().getBool("IS_TEST")||Hf().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];Hf().getBool("IS_TEST")||Hf().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Uf(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);Wf in t&&t[Wf].split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}function Gf(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}function Hf(){return qf}let jf,qf=null;function Xf(){if(null==jf){let t;if("undefined"!=typeof window)t=window;else if(void 0!==n.g)t=n.g;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}jf=t}return jf}function Kf(t,e){const n=function(){const t=Xf();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Yf="Abs",Zf="Acos",Jf="Acosh",Qf="Add",tm="AddN",em="All",nm="Any",rm="ArgMax",im="ArgMin",sm="Asin",am="Asinh",om="Atan",lm="Atanh",um="Atan2",cm="AvgPool",hm="AvgPoolGrad",dm="AvgPool3D",pm="AvgPool3DGrad",fm="BatchMatMul",mm="BatchToSpaceND",gm="Bincount",xm="BroadcastArgs",ym="Cast",vm="Ceil",bm="ClipByValue",wm="Complex",Sm="ComplexAbs",_m="Concat",Im="Conv2D",km="Conv2DBackpropFilter",Mm="Conv2DBackpropInput",Tm="Conv3D",Cm="Conv3DBackpropFilterV2",Em="Conv3DBackpropInputV2",Am="Cos",Nm="Cosh",Rm="Cumprod",Dm="Cumsum",Lm="CropAndResize",Fm="DenseBincount",$m="DepthToSpace",Pm="DepthwiseConv2dNative",Om="DepthwiseConv2dNativeBackpropFilter",zm="DepthwiseConv2dNativeBackpropInput",Bm="Diag",Um="Dilation2D",Wm="Dilation2DBackpropInput",Vm="Dilation2DBackpropFilter",Gm="RealDiv",Hm="Einsum",jm="Elu",qm="EluGrad",Xm="Erf",Km="Equal",Ym="Exp",Zm="ExpandDims",Jm="Expm1",Qm="FFT",tg="Fill",eg="FlipLeftRight",ng="Floor",rg="FloorDiv",ig="FusedBatchNorm",sg="GatherV2",ag="GatherNd",og="Greater",lg="GreaterEqual",ug="Identity",cg="IFFT",hg="Imag",dg="IsFinite",pg="IsInf",fg="IsNan",mg="LeakyRelu",gg="Less",xg="LessEqual",yg="LinSpace",vg="Log",bg="Log1p",wg="LogicalAnd",Sg="LogicalNot",_g="LogicalOr",Ig="LRN",kg="LRNGrad",Mg="Max",Tg="Maximum",Cg="MaxPool",Eg="MaxPoolGrad",Ag="MaxPool3D",Ng="MaxPool3DGrad",Rg="MaxPoolWithArgmax",Dg="Mean",Lg="Min",Fg="Minimum",$g="MirrorPad",Pg="Mod",Og="Multinomial",zg="Multiply",Bg="Neg",Ug="NotEqual",Wg="NonMaxSuppressionV3",Vg="NonMaxSuppressionV4",Gg="NonMaxSuppressionV5",Hg="OnesLike",jg="OneHot",qg="Pack",Xg="PadV2",Kg="Pow",Yg="Prelu",Zg="Prod",Jg="RaggedGather",Qg="RaggedTensorToTensor",tx="Range",ex="Real",nx="Reciprocal",rx="Relu",ix="Reshape",sx="ResizeNearestNeighbor",ax="ResizeNearestNeighborGrad",ox="ResizeBilinear",lx="ResizeBilinearGrad",ux="Relu6",cx="Reverse",hx="Round",dx="Rsqrt",px="ScatterNd",fx="SearchSorted",mx="Select",gx="Selu",xx="Slice",yx="Sin",vx="Sinh",bx="Sign",wx="Sigmoid",Sx="Softplus",_x="Sqrt",Ix="Sum",kx="SpaceToBatchND",Mx="SplitV",Tx="Softmax",Cx="SparseFillEmptyRows",Ex="SparseReshape",Ax="SparseSegmentMean",Nx="SparseSegmentSum",Rx="SparseToDense",Dx="SquaredDifference",Lx="Square",Fx="StridedSlice",$x="StringNGrams",Px="StringSplit",Ox="StringToHashBucketFast",zx="Sub",Bx="Tan",Ux="Tanh",Wx="Tile",Vx="TopK",Gx="Transform",Hx="Transpose",jx="Unique",qx="Unpack",Xx="UnsortedSegmentSum",Kx="ZerosLike",Yx="Step",Zx="RotateWithOffset",Jx="_FusedMatMul",Qx="FusedConv2D",ty="FusedDepthwiseConv2D";function ey(...t){Hf().getBool("IS_TEST")||Hf().getBool("PROD")||console.warn(...t)}function ny(...t){Hf().getBool("IS_TEST")||Hf().getBool("PROD")||console.log(...t)}const ry=Kf("kernelRegistry",(()=>new Map)),iy=Kf("gradRegistry",(()=>new Map));function sy(t,e){const n=cy(t,e);return ry.get(n)}function ay(t){return iy.get(t)}function oy(t){const e=ry.entries(),n=[];for(;;){const{done:r,value:i}=e.next();if(r)break;const[s,a]=i,[o]=s.split("_");o===t&&n.push(a)}return n}function ly(t){const{kernelName:e,backendName:n}=t,r=cy(e,n);ry.has(r)&&ey(`The kernel '${e}' for backend '${n}' is already registered`),ry.set(r,t)}function uy(t){const{kernelName:e}=t;iy.has(e)&&Hf().getBool("DEBUG")&&ey(`Overriding the gradient for '${e}'`),iy.set(e,t)}function cy(t,e){return`${e}_${t}`}var hy=n(720);const dy=n.n(hy)()||hy;function py(t){return dy.fromString(t,!0,16)}const fy=py("c3a5c85c97cb3127"),my=py("b492b66fbe98f273"),gy=py("9ae16a3b2f90404f");function xy(t){return t.xor(t.shru(47))}function yy(t,e,n){const r=t.slice(e,e+n);return dy.fromBytes(Array.from(r),!0,!0)}function vy(t,e){return yy(t,e,8)}function by(t,e){return yy(t,e,4)}function wy(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function Sy(t,e,n=py("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let i=e.xor(r).mul(n);return i=i.xor(i.shru(47)),i=i.mul(n),i}function _y(t,e,n,r){return function(t,e,n,r,i,s){i=i.add(t),s=wy(s.add(i).add(r),21);const a=i;return i=(i=i.add(e)).add(n),s=s.add(wy(i,44)),[i.add(r),s.add(a)]}(vy(t,e),vy(t,e+8),vy(t,e+16),vy(t,e+24),n,r)}function Iy(t,e=t.length){const n=dy.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=gy.add(2*e),r=vy(t,0).add(gy),i=vy(t,e-8);return Sy(wy(i,37).mul(n).add(r),wy(r,25).add(i).mul(n),n)}if(e>=4){const n=gy.add(2*e);return Sy(by(t,0).shl(3).add(e),by(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return xy(gy.mul(n).xor(fy.mul(r))).mul(gy)}return gy}(t,e):function(t,e=t.length){const n=gy.add(2*e),r=vy(t,0).mul(my),i=vy(t,8),s=vy(t,e-8).mul(n),a=vy(t,e-16).mul(gy);return Sy(wy(r.add(i),43).add(wy(s,30)).add(a),r.add(wy(i.add(gy),18)).add(s),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=gy.add(2*e),r=vy(t,0).mul(gy),i=vy(t,8),s=vy(t,e-8).mul(n),a=vy(t,e-16).mul(gy),o=wy(r.add(i),43).add(wy(s,30)).add(a),l=Sy(o,r.add(wy(i.add(gy),18)).add(s),n),u=vy(t,16).mul(n),c=vy(t,24),h=o.add(vy(t,e-32)).mul(n),d=l.add(vy(t,e-24)).mul(n);return Sy(wy(u.add(c),43).add(wy(h,30)).add(d),u.add(wy(c.add(r),18)).add(h),n)}(t,e);let r=n,i=n.mul(my).add(113),s=xy(i.mul(gy).add(113)).mul(gy),a=[dy.UZERO,dy.UZERO],o=[dy.UZERO,dy.UZERO];r=r.mul(gy).add(vy(t,0));let l=0;const u=64*(e-1>>6),c=u+(e-1&63)-63;do{r=wy(r.add(i).add(a[0]).add(vy(t,l+8)),37).mul(my),i=wy(i.add(a[1]).add(vy(t,l+48)),42).mul(my),r=r.xor(o[1]),i=i.add(a[0]).add(vy(t,l+40)),s=wy(s.add(o[0]),33).mul(my),a=_y(t,l,a[1].mul(my),r.add(o[0])),o=_y(t,l+32,s.add(o[1]),i.add(vy(t,l+16))),[s,r]=[r,s],l+=64}while(l!==u);const h=my.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),r=wy(r.add(i).add(a[0]).add(vy(t,l+8)),37).mul(h),i=wy(i.add(a[1]).add(vy(t,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),i=i.add(a[0].mul(9).add(vy(t,l+40))),s=wy(s.add(o[0]),33).mul(h),a=_y(t,l,a[1].mul(h),r.add(o[0])),o=_y(t,l+32,s.add(o[1]),i.add(vy(t,l+16))),[s,r]=[r,s],Sy(Sy(a[0],o[0],h).add(xy(i).mul(fy)).add(s),Sy(a[1],o[1],h).add(r),h)}function ky(t,e){return"string"===e?Cy(t):My([t],e)}function My(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=df(t)),Hf().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function Ty(){return Hf().platform.now()}function Cy(t,e="utf-8"){return e=e||"utf-8",Hf().platform.encode(t,e)}function Ey(t,e="utf-8"){return e=e||"utf-8",Hf().platform.decode(t,e)}class Ay{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Ry)}profileKernel(t,e,n){let r;const i=()=>{r=n()};let s;const a=Ty();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(i);else{i();for(const t of r)t.dataSync();s=Promise.resolve({kernelMs:Ty()-a})}if(Hf().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{Ny(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:s.then((t=>t.kernelMs)),extraInfo:s.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:i,extraInfo:s}=t;n.forEach((t=>{Promise.all([t.data(),r,s]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],i,n[2])}))}))}}function Ny(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Ry{logKernelProfile(t,e,n,r,i,s){const a="number"==typeof r?xf(`${r}ms`,9):r.error,o=xf(t,25),l=e.rank,u=e.size,c=xf(e.shape.toString(),14);let h="";for(const t in i){const n=i[t];if(null!=n){const r=n.shape||e.shape,i=r.length;h+=`${t}: ${i}D ${i>0?r:""} `}}console.log(`%c${o}\t%c${a}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const Dy=20,Ly=3,Fy=7;function $y(t,e,n,r){const i=Rf(e),s=function(t,e,n,r){const i=pf(e),s=r[r.length-1],a=new Array(s).fill(0),o=e.length,l="complex64"===n?By(t):t;if(o>1)for(let t=0;t<i/s;t++){const e=t*s;for(let t=0;t<s;t++)a[t]=Math.max(a[t],Py(l[e+t],0,n).length)}return a}(t,e,n,i),a=e.length,o=zy(t,e,n,i,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map((t=>"    "+t)).join("\n")),l.join("\n")}function Py(t,e,n){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(Fy))} + ${parseFloat(t[1].toFixed(Fy))}j`:Tf(t)?`'${t}'`:"bool"===n?Oy(t):parseFloat(t.toFixed(Fy)).toString(),xf(r,e)}function Oy(t){return 0===t?"false":"true"}function zy(t,e,n,r,i,s=!0){const a="complex64"===n?2:1,o=e[0],l=e.length;if(0===l)return"complex64"===n?[Py(By(t)[0],0,n)]:"bool"===n?[Oy(t[0])]:[t[0].toString()];if(1===l){if(o>Dy){const e=Ly*a;let r=Array.from(t.slice(0,e)),s=Array.from(t.slice((o-Ly)*a,o*a));return"complex64"===n&&(r=By(r),s=By(s)),["["+r.map(((t,e)=>Py(t,i[e],n))).join(", ")+", ..., "+s.map(((t,e)=>Py(t,i[o-Ly+e],n))).join(", ")+"]"]}return["["+("complex64"===n?By(t):Array.from(t)).map(((t,e)=>Py(t,i[e],n))).join(", ")+"]"]}const u=e.slice(1),c=r.slice(1),h=r[0]*a,d=[];if(o>Dy){for(let e=0;e<Ly;e++){const r=e*h,s=r+h;d.push(...zy(t.slice(r,s),u,n,c,i,!1))}d.push("...");for(let e=o-Ly;e<o;e++){const r=e*h,s=r+h;d.push(...zy(t.slice(r,s),u,n,c,i,e===o-1))}}else for(let e=0;e<o;e++){const r=e*h,s=r+h;d.push(...zy(t.slice(r,s),u,n,c,i,e===o-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let t=1;t<d.length-1;t++)d[t]=" "+d[t]+p;let f=",\n";for(let t=2;t<l;t++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function By(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Uy{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=pf(t),null!=n){const t=n.length;uf(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||_f(e,this.size),this.strides=Rf(t)}set(t,...e){0===e.length&&(e=[0]),uf(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Wy().makeTensor(this.values,this.shape,this.dtype)}}let Wy=null,Vy=null,Gy=null;class Hy{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=pf(t),this.strides=Rf(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Vy.buffer(this.shape,this.dtype,t)}bufferSync(){return Vy.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Lf(this.shape,t,"complex64"===this.dtype)}arraySync(){return Lf(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=Wy().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>Ey(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Wy().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Wy().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>Ey(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Wy().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Wy().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Vy.print(this,t)}clone(){return this.throwIfDisposed(),Vy.clone(this)}toString(t=!1){return $y(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Vy.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Wy().makeVariable(this,t,e,n)}}function jy(){return Kf("Tensor",(()=>Hy))}Object.defineProperty(Hy,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),jy();class qy extends Hy{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!ff(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Wy().disposeTensor(this),this.dataId=t.dataId,Wy().incRef(this,null)}dispose(){Wy().disposeVariable(this),this.isDisposedInternal=!0}}var Xy,Ky,Yy,Zy,Jy;Object.defineProperty(qy,Symbol.hasInstance,{value:t=>t instanceof Hy&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(Xy||(Xy={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(Ky||(Ky={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Yy||(Yy={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(Zy||(Zy={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Jy||(Jy={}));const Qy={float32:Zy,int32:Ky,bool:Yy,complex64:Jy};function tv(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Qy[t][e]}function ev(t){return tv(t,"int32")}function nv(t,e){if(t.dtype===e.dtype)return[t,e];const n=tv(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function rv(t,e){return e.some((e=>e.id===t.id))}function iv(t){const e=[];return sv(t,e,new Set),e}function sv(t,e,n){if(null==t)return;if(t instanceof Hy)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const i=t;for(const t in i){const r=i[t];n.has(r)||(n.add(r),sv(r,e,n))}}function av(t){return null!=t.kernelName}class ov{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class lv{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ov}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(ey(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Ay(this.backendInstance),!0}setupRegisteredKernels(){oy(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){oy(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof nf||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0)))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,ey(`Initialization of backend ${t} failed`),ey(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return ey(`Initialization of backend ${t} failed`),ey(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:i}=this.initializeBackend(n);if(i||r)return{name:n,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,i=this.readSync(e),s=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,i,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return lv.nextTensorId++}nextVariableId(){return lv.nextVariableId++}clone(t){const e=cv.runKernel(ug,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t};return cv.runKernel(ym,e,{dtype:"float32"})}})),[],{}),e}runKernel(t,e,n){if(null==this.backendName&&this.backend,null==sy(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let i=0;n.forEach((t=>{i+="complex64"===t.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-e-i-s;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),i=this.state.numBytes,s=this.state.numTensors;let a,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=av(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(av(t)){const{kernelName:e,inputs:i,attrs:s}=t;null==this.backendName&&this.backend;const l=sy(e,this.backendName);uf(null!=l,(()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`)),a=()=>{const t=this.backend.numDataIds();o=l.kernelFunc({inputs:i,attrs:s,backend:this.backend});const a=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,a);const u=a.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(e,i,u);n=this.saveTensorsForBackwardMode(t)}return u}}else{const{forwardFunc:e}=t,i=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};a=()=>{const t=this.backend.numDataIds();o=this.tidy((()=>e(this.backend,i)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:u,attrs:c}=t,h=av(t)?null:t.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,(()=>a())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=a()})),r&&this.addTapeNode(l,u,e,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((t=>null!=u[t]?u[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=ay(t);if(null!=r){const t=r.inputsToSave||[],i=r.outputsToSave||[];let s;r.saveAllInputs?(uf(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(e).map((t=>e[t]))):s=t.map((t=>e[t]));const a=n.filter(((t,e)=>i[e]));return s.concat(a)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let i=t;"string"===n&&Tf(t[0])&&(i=t.map((t=>Cy(t))));const s=r.write(i,e,n),a=new Hy(e,n,s,this.nextTensorId());if(this.trackTensor(a,r),"string"===n){const t=this.state.tensorInfo.get(s),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(i);this.state.numBytes+=e-t.bytes,t.bytes=e}return a}makeTensorFromDataId(t,e,n,r){const i={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:i}=t,s=new Hy(r,i,n,this.nextTensorId());return this.trackTensor(s,e),s}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const i=new qy(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*Mf(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof qy||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*Mf(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,i,s){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:i},o=ay(t);null!=o&&(r=o.gradFunc),null!=r&&(a.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=$f(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],i,s))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=iv(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,r=!1){if(uf(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const i=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));uf(i instanceof Hy,(()=>"The result y returned by f() must be a tensor."));const s=function(t,e,n){const r={},i={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const s=t[n],a=s.inputs;for(const t in a){const n=a[t];let o=!1;for(let t=0;t<e.length;t++)if(r[n.id]){s.outputs.forEach((t=>r[t.id]=!0)),o=!0,i[s.id]=!0;break}if(o)break}}const s={};s[n.id]=!0;const a={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(s[n.outputs[t].id]){for(const t in r)s[r[t].id]=!0,a[n.id]=!0;break}}const o=[];for(let e=0;e<t.length;e++){const n=t[e];if(i[n.id]&&a[n.id]){const t={};for(const e in n.inputs){const i=n.inputs[e];r[i.id]&&(t[e]=i)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,o.push(e)}}return o}(this.state.activeTape,e,i);if(!r&&0===s.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[i.id]=null==n?function(t){const e=Ff(pf(t),"float32");return cv.makeTensor(e,t,"float32")}(i.shape):n,function(t,e,n,r){for(let i=e.length-1;i>=0;i--){const s=e[i],a=[];if(s.outputs.forEach((e=>{const n=t[e.id];null!=n?a.push(n):a.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(a);for(const e in s.inputs){if(!(e in o))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(o)}.`);const i=n((()=>o[e]()));if("float32"!==i.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${i.dtype}'`);const a=s.inputs[e];if(!ff(i.shape,a.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${e}' has shape '${i.shape}', which does not match the shape of the input '${a.shape}'`);if(null==t[a.id])t[a.id]=i;else{const e=t[a.id];t[a.id]=r(e,i),e.dispose()}}}}(t,s,(t=>this.tidy(t)),hv);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:i,grads:r}}))}customGrad(t){return uf(Af(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;uf(e.every((t=>t instanceof Hy)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return e.forEach(((t,e)=>{r[e]=t})),this.runKernelFunc({forwardFunc:(r,i)=>(n=t(...e,i),uf(n.value instanceof Hy,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),uf(Af(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(t,r)=>{const i=n.gradFunc(t,r),s=Array.isArray(i)?i:[i];uf(s.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),uf(s.every((t=>t instanceof Hy)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const a={};return s.forEach(((t,e)=>{a[e]=()=>t})),a},inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=Ty(),n=await this.backend.time(t);return n.wallMs=Ty()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ov;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function uv(){const t=Xf();if(null==t._tfengine){const e=new Vf(t);t._tfengine=new lv(e)}var e;return e=t._tfengine.ENV,qf=e,Wy=()=>t._tfengine,t._tfengine}lv.nextTensorId=0,lv.nextVariableId=0;const cv=uv();function hv(t,e){const n={a:t,b:e};return cv.runKernel(Qf,n)}let dv;function pv(t){if(void 0!==dv)return dv;if(t||"undefined"!=typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||("undefined"!=typeof window?window.opera:"");if(!e){const e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function fv(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const mv=Hf();function gv(t,e){let n=t;if(kf(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||kf(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Hf().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&xv(t,r,[]),r}function xv(t,e,n){if(n=n||[],!Array.isArray(t)&&!kf(t))return void uf(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));uf(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),uf(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const r=e.slice(1);for(let e=0;e<t.length;++e)xv(t[e],r,n.concat(e))}function yv(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function vv(t,e,n,r="numeric"){if(t instanceof Hy)return yv(r,t.dtype,e,n),t;let i=Ef(t);if("string"!==i&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),yv(r,i,e,n),null==t||!kf(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const s=gv(t,i);kf(t)||Array.isArray(t)||(t=[t]);const a="string"!==i?My(t,i):df(t,[],!0);return cv.makeTensor(a,s,i)}function bv(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,i)=>vv(t,`${e}[${i}]`,n,r)))}mv.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),mv.registerFlag("IS_BROWSER",(()=>fv())),mv.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),mv.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),mv.registerFlag("PROD",(()=>!1)),mv.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>mv.getBool("DEBUG"))),mv.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),mv.registerFlag("IS_TEST",(()=>!1)),mv.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),mv.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),mv.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),mv.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),mv.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const wv="__op";function Sv(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=wv;const i=(...t)=>{cv.startScope(n);try{const e=r(...t);return Uf(e)&&console.error("Cannot return a Promise inside of tidy."),cv.endScope(e),e}catch(t){throw cv.endScope(null),t}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}const _v=Sv({complex_:function(t,e){const n=vv(t,"real","complex"),r=vv(e,"imag","complex");cf(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const i={real:n,imag:r};return cv.runKernel(wm,i)}});function Iv(t,e,n,r){if(null==r&&(r=Ef(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!kf(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Of(e);const t=pf(e),r=pf(n);uf(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let t=0;t<n.length;++t){const r=n[t],i=t!==n.length-1||r!==pf(e.slice(t));uf(n[t]===e[t]||!i,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return kf(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?My(t,r):df(t,[],!0),cv.makeTensor(t,e,r)}function kv(t,e,n){return Iv(t,e,gv(t,n),n)}const Mv=4;async function Tv(t,e){const n=[],r=[],i=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let s=0;s<i.length;++s){const a=i[s],o=Array.isArray(t)?t[s].tensor:t[a];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${o.dtype}`);const l={name:a,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const t=new Promise((async t=>{const e=await o.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+Mv*e.length,r=new Uint8Array(n);let i=0;for(let t=0;t<e.length;t++){const n=e[t],s=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(s,i),i+=Mv,r.set(n,i),i+=n.length}t(r)}));r.push(t)}else r.push(o.data());null!=e&&(l.group=e),n.push(l)}return{data:Cv(await Promise.all(r)),specs:n}}function Cv(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}));const r=new Uint8Array(e);let i=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),i),i+=t.byteLength})),r.buffer}const Ev="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Av(t){return Ev?Buffer.byteLength(t):new Blob([t]).size}function Nv(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function Rv(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}function Dv(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Av(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Av(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}class Lv{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Lv.instance&&(Lv.instance=new Lv),Lv.instance}static registerSaveRouter(t){Lv.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Lv.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Lv.getHandlers(t,"save")}static getLoadHandlers(t,e){return Lv.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?Lv.getInstance().loadRouters:Lv.getInstance().saveRouters).forEach((e=>{const i=e(t,n);null!==i&&r.push(i)})),r}}const Fv="tensorflowjs",$v="models_store",Pv="model_info_store";function Ov(){if(!Hf().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function zv(t){const e=t.result;e.createObjectStore($v,{keyPath:"modelPath"}),e.createObjectStore(Pv,{keyPath:"modelPath"})}class Bv{constructor(t){if(this.indexedDB=Ov(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(Fv,1);r.onupgradeneeded=()=>zv(r),r.onsuccess=()=>{const i=r.result;if(null==e){const e=i.transaction($v,"readonly"),r=e.objectStore($v).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return i.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(i.close(),n(r.error)),e.oncomplete=()=>i.close()}else{const r=Dv(e),s=i.transaction(Pv,"readwrite");let a=s.objectStore(Pv);const o=a.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;o.onsuccess=()=>{l=i.transaction($v,"readwrite");const o=l.objectStore($v).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});o.onsuccess=()=>t({modelArtifactsInfo:r}),o.onerror=t=>{a=s.objectStore(Pv);const e=a.delete(this.modelPath);e.onsuccess=()=>(i.close(),n(o.error)),e.onerror=t=>(i.close(),n(o.error))}},o.onerror=t=>(i.close(),n(o.error)),s.oncomplete=()=>{null==l?i.close():l.oncomplete=()=>i.close()}}},r.onerror=t=>n(r.error)}))}}Bv.URL_SCHEME="indexeddb://";const Uv=t=>{return Hf().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Bv.URL_SCHEME)?(e=t.slice(Bv.URL_SCHEME.length),new Bv(e)):null;var e};Lv.registerSaveRouter(Uv),Lv.registerLoadRouter(Uv);class Wv{constructor(){this.indexedDB=Ov()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(Fv,1);n.onupgradeneeded=()=>zv(n),n.onsuccess=()=>{const r=n.result,i=r.transaction(Pv,"readonly"),s=i.objectStore(Pv).getAll();s.onsuccess=()=>{const e={};for(const t of s.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},s.onerror=t=>(r.close(),e(s.error)),i.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(Bv.URL_SCHEME)?e.slice(Bv.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(Fv,1);r.onupgradeneeded=()=>zv(r),r.onsuccess=()=>{const i=r.result,s=i.transaction(Pv,"readwrite"),a=s.objectStore(Pv),o=a.get(t);let l;o.onsuccess=()=>{if(null==o.result)return i.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=a.delete(t),s=()=>{l=i.transaction($v,"readwrite");const r=l.objectStore($v).delete(t);r.onsuccess=()=>e(o.result.modelArtifactsInfo),r.onerror=t=>n(o.error)};r.onsuccess=s,r.onerror=t=>(s(),i.close(),n(o.error))}},o.onerror=t=>(i.close(),n(o.error)),s.oncomplete=()=>{null==l?i.close():l.oncomplete=()=>i.close()}},r.onerror=t=>n(r.error)}))}}const Vv="/",Gv="tensorflowjs_models",Hv="info",jv="model_topology",qv="weight_specs",Xv="weight_data",Kv="model_metadata";function Yv(t){return{info:[Gv,t,Hv].join(Vv),topology:[Gv,t,jv].join(Vv),weightSpecs:[Gv,t,qv].join(Vv),weightData:[Gv,t,Xv].join(Vv),modelMetadata:[Gv,t,Kv].join(Vv)}}function Zv(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Jv(t){const e=t.split(Vv);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(Vv)}class Qv{constructor(t){if(!Hf().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Yv(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=Dv(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(Ev)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let t=0,r=e.length;t<r;t++)n+=String.fromCharCode(e[t]);return btoa(n)}(t.weightData));const i={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch(t){throw Zv(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(null!=i){const t=JSON.parse(i);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(Ev){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n.set([e.charCodeAt(t)],t);return n.buffer}(s),e}}Qv.URL_SCHEME="localstorage://";const tb=t=>{return Hf().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Qv.URL_SCHEME)?(e=t.slice(Qv.URL_SCHEME.length),new Qv(e)):null;var e};Lv.registerSaveRouter(tb),Lv.registerLoadRouter(tb);class eb{constructor(){uf(Hf().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),uf("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=Gv+Vv,n=Vv+Hv;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);i.startsWith(e)&&i.endsWith(n)&&(t[Jv(i)]=JSON.parse(this.LS.getItem(i)))}return t}async removeModel(t){var e;const n=Yv(t=(e=t).startsWith(Qv.URL_SCHEME)?e.slice(Qv.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return Zv(n),r}}class nb{constructor(){this.managers={}}static getInstance(){return null==nb.instance&&(nb.instance=new nb),nb.instance}static registerManager(t,e){uf(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),uf(t.length>0,(()=>"scheme must not be an empty string."));const n=nb.getInstance();uf(null==n.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),n.managers[t]=e}static getManager(t){const e=nb.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(nb.getInstance().managers)}}class rb{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){window&&Hf().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{t.source===window&&t.data.name===this.messageName&&(t.stopPropagation(),(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(t,e)}}if(Hf().get("IS_BROWSER")){Hf().setPlatform("browser",new rb);try{nb.registerManager(Qv.URL_SCHEME,new eb)}catch(t){}try{nb.registerManager(Bv.URL_SCHEME,new Wv)}catch(t){}}let ib;function sb(t,e="float32",n){return e=e||"float32",Of(t),new Uy(t,e,n)}Hf().get("IS_NODE")&&!Hf().get("IS_BROWSER")&&Hf().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Hf().global.fetch?Hf().global.fetch(t,e):(null==ib&&(ib=n(410)),ib(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const ab=Sv({cast_:function(t,e){const n=vv(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},i={dtype:e};return cv.runKernel(ym,r,i)}}),ob=Sv({clone_:function(t){const e={x:vv(t,"x","clone","string_or_numeric")};return cv.runKernel(ug,e)}});function lb(t){return new Promise((t=>setTimeout(t))).then(t)}uv(),Vy={buffer:sb,cast:ab,clone:ob,print:function(t,e=!1){console.log(t.toString(e))}};class ub{constructor(t){if(!Hf().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(ub.URL_SCHEME)&&(t=t.slice(ub.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=Rv(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),i=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=r,await lb((()=>i.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await lb((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Dv(t)}}}}function cb(t,e,n,r){!function(t){uf(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){uf(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`)),uf(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`)),uf(e>=t,(()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`))}(n=null==n?0:n,r=null==r?1:r);let i=0;return Promise.all(t.map((s=>(s.then((s=>{const a=n+ ++i/t.length*(r-n);return e(a),s})),s))))}async function hb(t,e){null==e&&(e={});const n=null==e.fetchFunc?Hf().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),i=(null==e.onProgress?await Promise.all(r):await cb(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(i):await cb(i,e.onProgress,.5,1)}ub.URL_SCHEME="downloads://",Lv.registerSaveRouter((t=>Hf().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ub.URL_SCHEME)?function(t="model"){return new ub(t)}(t.slice(ub.URL_SCHEME.length)):null));class db{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(uf("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Hf().platform.fetch,uf(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&uf(2===t.length,(()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=Rv(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:Dv(t),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return async function(t,e){let n,r;return null!=t.weightsManifest&&([n,r]=await e(t.weightsManifest)),function(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(r.trainingConfig=t.trainingConfig),null!=t.weightsManifest){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return null!=t.signature&&(r.signature=t.signature),null!=t.userDefinedMetadata&&(r.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(r.modelInitializer=t.modelInitializer),r}(t,n,r)}(e,(t=>this.loadWeights(t)))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),i=this.weightPathPrefix||n,s=function(t){const e=[];for(const n of t)e.push(...n.weights);return e}(t),a=[],o=[];for(const e of t)for(const t of e.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(t)):a.push(i+t+r);return this.weightUrlConverter&&a.push(...await Promise.all(o)),[s,Nv(await hb(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function pb(t){return null!=t.match(db.URL_SCHEME_REGEX)}db.URL_SCHEME_REGEX=/^https?:\/\//;const fb=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>pb(t))):pb(t),n)return function(t,e){return new db(t,e)}(t,e)}return null};function mb(t,e){const n=t.length,r=[];for(let i=0;i<n;i++){const s=n-1-i,a=t[s]||1;(e[e.length-1-i]||1)>1&&1===a&&r.unshift(s)}return r}function gb(t,e){const n=[];for(let r=0;r<e.length;r++){const i=t[t.length-r-1],s=e.length-r-1,a=e[s];(null==i||1===i&&a>1)&&n.unshift(s)}return n}function xb(t,e){const n=[],r=Math.max(t.length,e.length);for(let i=0;i<r;i++){let r=t[t.length-i-1];null==r&&(r=1);let s=e[e.length-i-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}Lv.registerSaveRouter(fb),Lv.registerLoadRouter(fb);const yb=-2,vb=-1;function bb(t,e,n){const r=t.shape.length;uf(r===e.length,(()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`)),uf(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let i=0;i<r;++i)uf(e[i]+n[i]<=t.shape[i],(()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${e[i]+n[i]}) would overflow input.shape[${i}] (${t.shape[i]})`))}function wb(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function Sb(t,e,n){const r=[];for(let i=0;i<t.length;i++)r[i]=Math.ceil((e[i]-t[i])/n[i]);return r}function _b(t,e,n,r){const i=[...t];for(let t=i.length;t<r.length;t++)i.push(1);for(let t=0;t<n;t++)0===t?i[e]=1:(i.splice(e,0,1),i.pop());return i}function Ib(t,e,n){return n<=t?n:n-(e-1)}function kb(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function Mb(t,e,n,r,i,s,a,o,l){const u=t.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&n>0){const l=e[0],u=n+1;c=Tb(a,l,u,r,t),h=Cb(o,l,u,i,t),d=_b(s,l,u,t)}else for(let e=0;e<u;e++)c[e]=Ab(a,r,s,t,e,l),h[e]=Nb(o,i,s,t,e,l),d[e]=Eb(s,e,l);return{begin:c,end:h,strides:d}}function Tb(t,e,n,r,i){const s=[...i],a=kb(n,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=0;else{const a=Ib(e,n,i);let o=r[a];t&1<<a&&(o=0),s[i]=o}return s}function Cb(t,e,n,r,i){const s=[...i],a=kb(n,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const a=Ib(e,n,i);let o=r[a];t&1<<a&&(o=Number.MAX_SAFE_INTEGER),s[i]=o}for(let t=0;t<s.length;t++){const e=i[t];s[t]<0&&(s[t]+=e),s[t]=af(0,s[t],i[t])}return s}function Eb(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function Ab(t,e,n,r,i,s){let a=e[i];const o=n[i]||1;(t&1<<i||s&1<<i||null==a)&&(a=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[i];return a<0&&(a+=l),a=af(0,a,l-1),a}function Nb(t,e,n,r,i,s){let a=e[i];const o=n[i]||1;(t&1<<i||s&1<<i||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[i];return a<0&&(a+=l),a=o>0?af(0,a,l):af(-1,a,l-1),a}function Rb(t,e,n){let r=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){r=t;break}for(let i=r+1;i<n.length;i++)if(e[i]>0||n[i]!==t[i])return!1;return!0}function Db(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function Lb(t,e,n){let r;const i=t.shape.length;let s;return r="number"==typeof e?[e,...new Array(i-1).fill(0)]:e.length<i?e.concat(new Array(i-e.length).fill(0)):e.slice(),r.forEach((t=>{uf(-1!==t,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(i).fill(-1):"number"==typeof n?[n,...new Array(i-1).fill(-1)]:n.length<i?n.concat(new Array(i-n.length).fill(-1)):n,s=s.map(((e,n)=>e>=0?e:(uf(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-r[n]))),[r,s]}function Fb(t,e,n,r,i,s,a,o,l){let u;if(null==r?(u=new Array(e.length),u.fill(1)):u=r,null!=a&&0!=(a&a-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:u.slice(),beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let t=0;t<h.dims;t++)c&&0!=(1<<t&o)&&h.numAddAxisAfterEllipsis++,1<<t&a&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=null!=t.begin,e.endValid=null!=t.end,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const i=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<i;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(yb),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);null!=t.begin&&(e.begin[n]=t.begin[r]),null!=t.end&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(vb),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],x=[];for(let e=0;e<t.length;++e){if(0===d.strides[e])throw Error(`strides[${e}] must be non-zero`);const n=!!(d.shrinkAxisMask&1<<e),r=t[e];if(-1===r){g.push(n?1:-1);continue}const i=[d.beginMask&1<<e,d.endMask&1<<e],s=[d.strides[e]>0?0:-1,d.strides[e]>0?r:r-1];if(n&&d.strides[e]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[e];const a=!!(d.beginMask&1<<e&&d.endMask&1<<e);if(d.beginValid&&d.endValid){if(n){const t=d.begin[e]<0?r+d.begin[e]:d.begin[e];if(d.begin[e]=t,d.end[e]=d.begin[e]+1,t<0||t>=r)throw Error(`slice index ${d.begin[e]} of dimension ${e} out of bounds.`)}else d.begin[e]=$b(d.begin[e],0,d.strides[e],r,i,s),d.end[e]=$b(d.end[e],1,d.strides[e],r,i,s);const t=1===d.strides[e]&&0===d.begin[e]&&d.end[e]===r;p=p&&t,f=f&&(0===e&&1===d.strides[e]||t)}else p=p&&1===d.strides[e]&&a,f=f&&(0===e&&1===d.strides[e]||a);let o,l=!1;if(d.beginValid&&d.endValid?(o=d.end[e]-d.begin[e],l=!0):n?(o=1,l=!0):a&&r>=0&&(o=d.strides[e]<0?-r:r,l=!0),l){let t;t=0===o||o<0!=d.strides[e]<0?0:Math.trunc(o/d.strides[e])+(o%d.strides[e]!=0?1:0),g.push(t)}else g.push(-1)}for(let t=0;t<d.finalShapeGatherIndices.length;++t){const e=d.finalShapeGatherIndices[t];e>=0?x.push(g[e]):e===yb&&x.push(1)}return{finalShapeSparse:x.filter(((t,e)=>d.finalShapeGatherIndices[e]!==yb)),finalShape:x,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function $b(t,e,n,r,i,s){if(i[e])return n>0?s[e]:s[e+1&1];{const e=t<0?r+t:t;return e<s[0]?s[0]:e>s[1]?s[1]:e}}class Pb{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Ob{constructor(){this.classNameMap={}}static getMap(){return null==Ob.instance&&(Ob.instance=new Ob),Ob.instance}static register(t){Ob.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function zb(t){uf(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),uf("string"==typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),uf(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),Ob.register(t)}function Bb(){return cv}function Ub(){return cv.memory()}function Wb(t,e){return cv.tidy(t,e)}function Vb(t){iv(t).forEach((t=>t.dispose()))}function Gb(t){return cv.keep(t)}function Hb(t,e,n=1){return cv.registerBackend(t,e,n)}function jb(){return cv.backend}function qb(t){return cv.customGrad(t)}function Xb(t,e){if((kf(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&kf(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Iv(t,[],[],e)}Gy=function(t){Hf().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class Kb extends Pb{minimize(t,e=!1,n){const{value:r,grads:i}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:i[t.name]})));this.applyGradients(t)}else this.applyGradients(i);return Vb(i),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){uf(Af(t),(()=>"The f passed in variableGrads(f) must be a function")),uf(null==e||Array.isArray(e)&&e.every((t=>t instanceof qy)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in cv.registeredVariables)e.push(cv.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,i=e.length;uf((e=e.filter((t=>t.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`));const{value:s,grads:a}=cv.gradients(t,e,null,!0);uf(a.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),uf(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));const o={};return e.forEach(((t,e)=>{null!=a[e]&&(o[t.name]=a[e])})),null!=r&&r.forEach((t=>o[t.name]=null)),{value:s,grads:o}}(t,e)}dispose(){null!=this.iterations_&&Vb(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Xb(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Kb,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const Yb=Sv({abs_:function(t){const e=vv(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return cv.runKernel(Sm,t)}{const t={x:e};return cv.runKernel(Yf,t)}}}),Zb=Sv({add_:function(t,e){let n=vv(t,"a","add"),r=vv(e,"b","add");[n,r]=nv(n,r);const i={a:n,b:r};return cv.runKernel(Qf,i)}}),Jb=Sv({all_:function(t,e=null,n=!1){const r={x:vv(t,"x","all","bool")},i={axis:e,keepDims:n};return cv.runKernel(em,r,i)}}),Qb=Sv({any_:function(t,e=null,n=!1){const r={x:vv(t,"x","any","bool")},i={axis:e,keepDims:n};return cv.runKernel(nm,r,i)}}),tw=Sv({argMax_:function(t,e=0){const n={x:vv(t,"x","argMax")},r={axis:e};return cv.runKernel(rm,n,r)}});function ew(t,e,n,r,i="NHWC",s){return iw(t,[...e,t[3]],n,s,r,null,null,pw(i))}function nw(t,e,n,r,i,s,a="channelsLast"){const[o,l]=ow(e);let u;if("channelsLast"===a)u=[o,l,t[3],t[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);u=[o,l,t[1],t[1]]}return iw(t,u,n,r,i,s,!1,a)}function rw(t,e,n,r,i,s,a="NDHWC"){const[o,l,u]=lw(e);let c,h;if("NDHWC"===a)h="channelsLast",c=[o,l,u,t[4],t[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);h="channelsFirst",c=[o,l,u,t[1],t[1]]}return sw(t,c,n,r,i,!1,h,s)}function iw(t,e,n,r,i,s,a=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=t}const[d,p,,f]=e,[m,g]=ow(n),[x,y]=ow(r),v=uw(d,x),b=uw(p,y),{padInfo:w,outHeight:S,outWidth:_}=function(t,e,n,r,i,s,a,o,l){let u,c,h;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const i=function(t,e,n,r,i){null==r&&(r=aw(t,e,n));const s=t[1];return[cw((t[0]-e+2*r)/n+1,i),cw((s-e+2*r)/n+1,i)]}([e,n],s,r,t,o);c=i[0],h=i[1]}else if("same"===t){c=Math.ceil(e/r),h=Math.ceil(n/i);const t=Math.max(0,(c-1)*r+s-e),o=Math.max(0,(h-1)*i+a-n),l=Math.floor(t/2),d=t-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-s+1)/r),h=Math.ceil((n-a+1)/i);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=cw((e-s+d+p)/r+1,o),h=cw((n-a+f+m)/i+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(i,u,c,m,g,v,b,s,o),I=a?f*h:f;let k;return"channelsFirst"===o?k=[l,I,S,_]:"channelsLast"===o&&(k=[l,S,_,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:S,outWidth:_,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:b,dilationHeight:x,dilationWidth:y,inShape:t,outShape:k,filterShape:e}}function sw(t,e,n,r,i,s=!1,a="channelsLast",o){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,h,d]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c,h]=t}const[p,f,m,,g]=e,[x,y,v]=lw(n),[b,w,S]=lw(r),_=uw(p,b),I=uw(f,w),k=uw(m,S),{padInfo:M,outDepth:T,outHeight:C,outWidth:E}=function(t,e,n,r,i,s,a,o,l,u,c){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,i,s){null==i&&(i=aw(t,e,r));const a=t[1],o=t[2];return[cw((t[0]-e+2*i)/r+1,s),cw((a-e+2*i)/r+1,s),cw((o-e+2*i)/r+1,s),1]}([e,n,r,1],o,0,i,t,c);d=s[0],p=s[1],f=s[2]}else if("same"===t){d=Math.ceil(e/i),p=Math.ceil(n/s),f=Math.ceil(r/a);const t=(d-1)*i+o-e,c=(p-1)*s+l-n,m=(f-1)*a+u-r,g=Math.floor(t/2),x=t-g,y=Math.floor(c/2),v=c-y,b=Math.floor(m/2);h={top:y,bottom:v,left:b,right:m-b,front:g,back:x,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-o+1)/i),p=Math.ceil((n-l+1)/s),f=Math.ceil((r-u+1)/a)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(i,u,c,h,x,y,v,_,I,k,o),A=s?g*d:g;let N;return"channelsFirst"===a?N=[l,A,T,C,E]:"channelsLast"===a&&(N=[l,T,C,E,A]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:T,outHeight:C,outWidth:E,outChannels:A,padInfo:M,strideDepth:x,strideHeight:y,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:_,effectiveFilterHeight:I,effectiveFilterWidth:k,dilationDepth:b,dilationHeight:w,dilationWidth:S,inShape:t,outShape:N,filterShape:e}}function aw(t,e,n,r=1){const i=uw(e,r);return Math.floor((t[0]*(n-1)-n+i)/2)}function ow(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function lw(t){return"number"==typeof t?[t,t,t]:t}function uw(t,e){return e<=1?t:t+(t-1)*(e-1)}function cw(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function hw(t){const[e,n,r]=ow(t);return 1===e&&1===n&&1===r}function dw(t,e){return hw(t)||hw(e)}function pw(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function fw(t,e,n){if(null!=n){if("string"==typeof e)throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if("number"==typeof e)uf(mf(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`));else{if("object"!=typeof e)throw Error(`Error in ${t}: Unknown padding parameter: ${e}`);e.forEach((e=>{e.forEach((e=>{uf(mf(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`))}))}))}}}const mw=Sv({reshape_:function(t,e){const n={x:vv(t,"x","reshape","string_or_numeric")},r={shape:e};return cv.runKernel(ix,n,r)}}),gw=Sv({avgPool_:function(t,e,n,r,i){const s=vv(t,"x","avgPool","float32");uf(dw(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let a=s,o=!1;3===s.rank&&(o=!0,a=mw(s,[1,s.shape[0],s.shape[1],s.shape[2]])),uf(4===a.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`)),fw("avgPool",r,i);const l={x:a},u={filterSize:e,strides:n,pad:r,dimRoundingMode:i};let c=cv.runKernel(cm,l,u);return c=ab(c,s.dtype),o?mw(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),xw=Sv({avgPool3d_:function(t,e,n,r,i,s="NDHWC"){const a=vv(t,"x","avgPool3d","float32");let o=a,l=!1;4===a.rank&&(l=!0,o=mw(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),uf(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),uf("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),fw("avgPool3d",r,i);const u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:i,dataFormat:s};let h=cv.runKernel(dm,u,c);return h=ab(h,o.dtype),l?mw(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),yw=Sv({batchNorm_:function(t,e,n,r,i,s){null==s&&(s=.001);const a=vv(t,"x","batchNorm"),o=vv(e,"mean","batchNorm"),l=vv(n,"variance","batchNorm");let u,c;null!=i&&(u=vv(i,"scale","batchNorm")),null!=r&&(c=vv(r,"offset","batchNorm")),uf(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),uf(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),uf(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(t){let e;return e=0===t.rank||1===t.rank?mw(t,[1,1,1,t.size]):2===t.rank?mw(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?mw(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(a),scale:u,offset:c,mean:o,variance:l},d={varianceEpsilon:s},p=cv.runKernel(ig,h,d);return mw(p,a.shape)}}),vw=Sv({batchNorm2d_:function(t,e,n,r,i,s){const a=vv(t,"x","batchNorm"),o=vv(e,"mean","batchNorm"),l=vv(n,"variance","batchNorm");let u,c;return null!=i&&(u=vv(i,"scale","batchNorm")),null!=r&&(c=vv(r,"offset","batchNorm")),uf(2===a.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`)),uf(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),uf(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&uf(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&uf(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),yw(a,o,l,c,u,s)}}),bw=Sv({batchNorm3d_:function(t,e,n,r,i,s){const a=vv(t,"x","batchNorm"),o=vv(e,"mean","batchNorm"),l=vv(n,"variance","batchNorm");let u,c;return null!=i&&(u=vv(i,"scale","batchNorm")),null!=r&&(c=vv(r,"offset","batchNorm")),uf(3===a.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`)),uf(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),uf(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&uf(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&uf(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),yw(a,o,l,c,u,s)}}),ww=Sv({batchNorm4d_:function(t,e,n,r,i,s){const a=vv(t,"x","batchNorm"),o=vv(e,"mean","batchNorm"),l=vv(n,"variance","batchNorm");let u,c;return null!=i&&(u=vv(i,"scale","batchNorm")),null!=r&&(c=vv(r,"offset","batchNorm")),uf(4===a.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`)),uf(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),uf(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&uf(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&uf(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),yw(a,o,l,c,u,s)}}),Sw=Sv({broadcastTo_:function(t,e){let n=vv(t,"broadcastTo","x");const r=n.shape;if(e.some((t=>!(t>0)||t%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=mw(n,t)}const i=n.shape,s=Array.from(e);for(let t=e.length-1;t>=0;t--)if(i[t]===e[t])s[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(0===s.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return ob(n);const a={x:n},o={reps:s};return cv.runKernel(Wx,a,o)}});function _w(t,e,n){const r={shape:t,value:e,dtype:n};return cv.runKernel(tg,{},r)}const Iw=Sv({clipByValue_:function(t,e,n){const r=vv(t,"x","clipByValue");if(uf(e<=n,(()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`)),e===n)return _w(r.shape,e,r.dtype);const i={x:r},s={clipValueMin:e,clipValueMax:n};return cv.runKernel(bm,i,s)}}),kw=Sv({concat_:function(t,e=0){uf(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=bv(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)})),1===n.length)return ob(n[0]);const r=n,i={axis:e};return cv.runKernel(_m,r,i)}}),Mw=Sv({concat1d_:function(t){return kw(t,0)}}),Tw=Sv({concat2d_:function(t,e){return kw(t,e)}}),Cw=Sv({concat3d_:function(t,e){return kw(t,e)}}),Ew=Sv({concat4d_:function(t,e){return kw(t,e)}}),Aw=Sv({conv2d_:function(t,e,n,r,i="NHWC",s=[1,1],a){const o=vv(t,"x","conv2d","float32"),l=vv(e,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=mw(o,[1,o.shape[0],o.shape[1],o.shape[2]])),uf(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),uf(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),fw("conv2d",r,a);const h="NHWC"===i?u.shape[3]:u.shape[1];uf(h===l.shape[2],(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`)),uf(dw(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a},f=cv.runKernel(Im,d,p);return c?mw(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Nw=Sv({conv1d_:function(t,e,n,r,i="NWC",s=1,a){const o=vv(t,"x","conv1d"),l=vv(e,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=mw(o,[1,o.shape[0],o.shape[1]])),uf(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),uf(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),fw("conv1d",r,a),uf(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),uf(dw(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),uf("NWC"===i,(()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`));const h=mw(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=mw(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=Aw(d,h,[1,n],r,"NHWC",[1,s],a);return mw(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),Rw=Sv({conv2DBackpropInput_:function(t,e,n,r,i,s="NHWC",a){uf(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let o=t,l=e,u=!1;3===e.rank&&(u=!0,l=mw(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),uf(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),uf(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),uf(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===s?o[3]:o[1],h="NHWC"===s?l.shape[3]:l.shape[1];uf(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),uf(h===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)),fw("conv2dDerInput",i,a);const d={dy:l,filter:n},p={strides:r,pad:i,dataFormat:s,dimRoundingMode:a,inputShape:o},f=cv.runKernel(Mm,d,p);return u?mw(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Dw=Sv({conv2dTranspose_:function(t,e,n,r,i,s){const a=vv(t,"x","conv2dTranspose"),o=vv(e,"filter","conv2dTranspose");return Rw(n,a,o,r,i,"NHWC",s)}}),Lw=Sv({conv3d_:function(t,e,n,r,i="NDHWC",s=[1,1,1]){const a=vv(t,"x","conv3d"),o=vv(e,"filter","conv3d");let l=a,u=!1;4===a.rank&&(u=!0,l=mw(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),uf(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),uf(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),uf(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),uf(dw(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),uf("NDHWC"===i,(()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`));const c={x:l,filter:o},h={strides:n,pad:r,dataFormat:i,dilations:s},d=cv.runKernel(Tm,c,h);return u?mw(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Fw=Sv({conv3DBackpropInput_:function(t,e,n,r,i){uf(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let s=t,a=e,o=!1;4===e.rank&&(o=!0,a=mw(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],u=a.shape[4];uf(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),uf(5===a.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`)),uf(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),uf(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),uf(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:a,filter:n},h={pad:i,strides:r,inputShape:s},d=cv.runKernel(Em,c,h);return o?mw(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),$w=Sv({conv3dTranspose_:function(t,e,n,r,i){const s=vv(t,"x","conv3dTranspose"),a=vv(e,"filter","conv3dTranspose");return Fw(n,s,a,r,i)}}),Pw=Sv({depthwiseConv2d_:function(t,e,n,r,i="NHWC",s=[1,1],a){const o=vv(t,"x","depthwiseConv2d","float32"),l=vv(e,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=mw(o,[1,o.shape[0],o.shape[1],o.shape[2]])),uf(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),uf(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const h="NHWC"===i?u.shape[3]:u.shape[1];uf(h===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`)),fw("depthwiseConv2d",r,a);const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a},f=cv.runKernel(Pm,d,p);return c?mw(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Ow=Sv({floorDiv_:function(t,e){let n=vv(t,"a","floorDiv"),r=vv(e,"b","floorDiv");[n,r]=nv(n,r);const i={a:n,b:r};return cv.runKernel(rg,i)}}),zw=Sv({div_:function(t,e){let n=vv(t,"a","div"),r=vv(e,"b","div");if([n,r]=nv(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Ow(n,r);const i={a:n,b:r};return cv.runKernel(Gm,i,{})}}),Bw=Sv({elu_:function(t){const e={x:vv(t,"x","elu","float32")};return cv.runKernel(jm,e)}}),Uw=Sv({equal_:function(t,e){let n=vv(t,"a","equal","string_or_numeric"),r=vv(e,"b","equal","string_or_numeric");[n,r]=nv(n,r),xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(Km,i)}}),Ww=Sv({exp_:function(t){const e={x:vv(t,"x","exp")};return cv.runKernel(Ym,e)}}),Vw=Sv({expandDims_:function(t,e=0){const n=vv(t,"x","expandDims","string_or_numeric");uf(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},i={dim:e};return cv.runKernel(Zm,r,i)}}),Gw=Sv({tile_:function(t,e){const n=vv(t,"x","tile","string_or_numeric");uf(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const r={x:n},i={reps:e};return cv.runKernel(Wx,r,i)}}),Hw=Sv({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const i=sb([t,e],r),s=t<=e?t:e;for(let t=0;t<s;++t)i.set(1,t,t);const a=mw(i.toTensor(),[t,e]);if(null==n)return a;if(1===n.length)return Gw(Vw(a,0),[n[0],1,1]);if(2===n.length)return Gw(Vw(Vw(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return Gw(Vw(Vw(Vw(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),jw=Sv({floor_:function(t){const e={x:vv(t,"x","floor","float32")};return cv.runKernel(ng,e)}}),qw=Sv({gather_:function(t,e,n=0,r=0){const i={x:vv(t,"x","gather"),indices:vv(e,"indices","gather","int32")},s={axis:n,batchDims:r};return cv.runKernel(sg,i,s)}}),Xw=Sv({greater_:function(t,e){let n=vv(t,"a","greater","string_or_numeric"),r=vv(e,"b","greater","string_or_numeric");[n,r]=nv(n,r),xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(og,i)}}),Kw=Sv({greaterEqual_:function(t,e){let n=vv(t,"a","greaterEqual","string_or_numeric"),r=vv(e,"b","greaterEqual","string_or_numeric");[n,r]=nv(n,r),xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(lg,i)}}),Yw=Sv({leakyRelu_:function(t,e=.2){const n={x:vv(t,"x","leakyRelu")},r={alpha:e};return cv.runKernel(mg,n,r)}}),Zw=Sv({log_:function(t){const e={x:vv(t,"x","log","float32")};return cv.runKernel(vg,e)}}),Jw=Sv({log1p_:function(t){const e={x:vv(t,"x","log1p")};return cv.runKernel(bg,e)}}),Qw=Sv({max_:function(t,e=null,n=!1){const r={x:vv(t,"x","max")},i={reductionIndices:e,keepDims:n};return cv.runKernel(Mg,r,i)}}),tS=Sv({mul_:function(t,e){let n=vv(t,"a","mul"),r=vv(e,"b","mul");[n,r]=nv(n,r);const i={a:n,b:r};return cv.runKernel(zg,i)}}),eS=Sv({sub_:function(t,e){let n=vv(t,"a","sub"),r=vv(e,"b","sub");[n,r]=nv(n,r);const i={a:n,b:r};return cv.runKernel(zx,i)}}),nS=Sv({sum_:function(t,e=null,n=!1){let r=vv(t,"x","sum");"bool"===r.dtype&&(r=ab(r,"int32"));const i={x:r},s={axis:e,keepDims:n};return cv.runKernel(Ix,i,s)}}),rS=Sv({logSoftmax_:function(t,e=-1){const n=vv(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);const r=qb(((t,n)=>{const r=Qw(t,e,!0),i=eS(t,r),s=eS(ab(i,"float32"),Zw(nS(Ww(i),e,!0)));return n([s]),{value:s,gradFunc:(t,n)=>{const[r]=n,i=Ww(r);return eS(t,tS(nS(t,e,!0),i))}}}));return r(n)}}),iS=Sv({logicalAnd_:function(t,e){const n=vv(t,"a","logicalAnd","bool"),r=vv(e,"b","logicalAnd","bool");xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(wg,i)}}),sS=Sv({matMul_:function(t,e,n=!1,r=!1){let i=vv(t,"a","matMul"),s=vv(e,"b","matMul");[i,s]=nv(i,s);const a={a:i,b:s},o={transposeA:n,transposeB:r};return cv.runKernel(fm,a,o)}}),aS=Sv({maxPool_:function(t,e,n,r,i){const s=vv(t,"x","maxPool");let a=s,o=!1;3===s.rank&&(o=!0,a=mw(s,[1,s.shape[0],s.shape[1],s.shape[2]])),uf(4===a.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`)),uf(dw(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),fw("maxPool",r,i);const l={x:a},u={filterSize:e,strides:n,pad:r,dimRoundingMode:i},c=cv.runKernel(Cg,l,u);return o?mw(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),oS=Sv({maxPool3d_:function(t,e=[1,1,1],n,r,i,s="NDHWC"){const a=vv(t,"x","maxPool3d");let o=a,l=!1;4===a.rank&&(l=!0,o=mw(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),uf(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),uf("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),fw("maxPool3d",r,i);const u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:i,dataFormat:s},h=cv.runKernel(Ag,u,c);return l?mw(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),lS=Sv({maximum_:function(t,e){let n=vv(t,"a","maximum"),r=vv(e,"b","maximum");[n,r]=nv(n,r),"bool"===n.dtype&&(n=ab(n,"int32"),r=ab(r,"int32")),xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(Tg,i)}}),uS=Sv({mean_:function(t,e=null,n=!1){const r={x:vv(t,"x","mean")},i={axis:e,keepDims:n};return cv.runKernel(Dg,r,i)}}),cS=Sv({minimum_:function(t,e){let n=vv(t,"a","minimum"),r=vv(e,"b","minimum");[n,r]=nv(n,r),"bool"===n.dtype&&(n=ab(n,"int32"),r=ab(r,"int32")),xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(Fg,i)}});function hS(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function dS(t,e,n){const r=t.length+e.length,i=[];let s=0,a=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?i.push(t[s++]):i.push(e[a++]);return i}function pS(t,e){const n=[],r=t.length;for(let i=0;i<r;i++)-1===e.indexOf(i)&&n.push(t[i]);return[n,e.map((e=>t[e]))]}function fS(t,e){return dS(t,e.map((t=>1)),e)}function mS(t,e,n){uf(hS(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function gS(t,e){if(hS(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function xS(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function yS(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const vS=Sv({square_:function(t){const e=vv(t,"x","square");return cv.runKernel("Square",{x:e},{})}}),bS=Sv({moments_:function(t,e=null,n=!1){const r=bf(e,(t=vv(t,"x","moments")).shape),i=uS(t,r,n);let s=i.shape;n||(s=fS(i.shape,r));const a=vS(eS(ab(t,"float32"),mw(i,s)));return{mean:i,variance:uS(a,r,n)}}}),wS=Sv({neg_:function(t){const e={x:vv(t,"x","neg")};return cv.runKernel(Bg,e)}}),SS=Sv({notEqual_:function(t,e){let n=vv(t,"a","notEqual","string_or_numeric"),r=vv(e,"b","notEqual","string_or_numeric");[n,r]=nv(n,r),xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(Ug,i)}}),_S=Sv({oneHot_:function(t,e,n=1,r=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const s={indices:vv(t,"indices","oneHot","int32")},a={dtype:i,depth:e,onValue:n,offValue:r};return cv.runKernel(jg,s,a)}});function IS(t,e="float32"){if("complex64"===e){const e=IS(t,"float32"),n=IS(t,"float32");return _v(e,n)}const n=$f(pf(t),e);return cv.makeTensor(n,t,e)}function kS(t,e="float32"){if("complex64"===e){const e=kS(t,"float32"),n=IS(t,"float32");return _v(e,n)}const n=Ff(pf(t),e);return cv.makeTensor(n,t,e)}const MS=Sv({onesLike_:function(t){const e={x:vv(t,"x","onesLike")};return cv.runKernel(Hg,e)}}),TS=Sv({pad_:function(t,e,n=0){const r=vv(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:n},s={x:r};return cv.runKernel(Xg,s,i)}}),CS=Sv({prelu_:function(t,e){const n={x:vv(t,"x","prelu"),alpha:vv(e,"alpha","prelu")};return cv.runKernel(Yg,n)}});var ES=n(377);class AS{constructor(t,e,n,r,i){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=i||Math.random();this.random=ES.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,i,s;do{r=2*this.random()-1,i=2*this.random()-1,s=r*r+i*i}while(s>=1||0===s);const a=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*i*a,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class NS{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=ES.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const RS=Sv({randomNormal_:function(t,e=0,n=1,r,i){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new AS(e,n,r,!1,i),a=sb(t,r);for(let t=0;t<a.values.length;t++)a.values[t]=s.nextValue();return a.toTensor()}}),DS=Sv({randomUniform_:function(t,e=0,n=1,r="float32",i){const s=sb(t,r),a=new NS(e,n,null,i);for(let t=0;t<s.values.length;t++)s.values[t]=a.nextValue();return s.toTensor()}}),LS=Sv({relu_:function(t){const e={x:vv(t,"x","relu")};return cv.runKernel(rx,e)}}),FS=Sv({reverse_:function(t,e){const n={x:vv(t,"x","reverse")},r={dims:e};return cv.runKernel(cx,n,r)}}),$S=Sv({selu_:function(t){const e={x:vv(t,"x","selu")};return cv.runKernel(gx,e)}}),PS=Sv({separableConv2d_:function(t,e,n,r,i,s=[1,1],a="NHWC"){const o=vv(t,"x","separableConv2d"),l=vv(e,"depthwiseFilter","separableConv2d"),u=vv(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=mw(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===a)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");uf(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),uf(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),uf(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),uf(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),uf(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const d=l.shape[2],p=l.shape[3];uf(u.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`));const f=Pw(c,l,r,i,a,s),m=Aw(f,u,1,"valid",a);return h?mw(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),OS=Sv({sigmoid_:function(t){const e={x:vv(t,"x","sigmoid","float32")};return cv.runKernel(wx,e)}}),zS=Sv({slice_:function(t,e,n){const r=vv(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const i={x:r},s={begin:e,size:n};return cv.runKernel(xx,i,s)}}),BS=Sv({slice1d_:function(t,e,n){const r=vv(t,"x","slice1d");return uf(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),zS(r,[e],[n])}}),US=Sv({slice2d_:function(t,e,n){const r=vv(t,"x","slice2d");return uf(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),zS(r,e,n)}}),WS=Sv({slice3d_:function(t,e,n){const r=vv(t,"x","slice3d");return uf(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),zS(r,e,n)}}),VS=Sv({slice4d_:function(t,e,n){const r=vv(t,"x","slice4d");return uf(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),zS(r,e,n)}}),GS=Sv({softmax_:function(t,e=-1){const n=vv(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},i={dim:e};return cv.runKernel(Tx,r,i)}}),HS=Sv({softplus_:function(t){const e={x:vv(t,"x","softplus")};return cv.runKernel(Sx,e)}}),jS=Sv({split_:function(t,e,n=0){const r={x:vv(t,"x","split")},i={numOrSizeSplits:e,axis:n};return cv.runKernel(Mx,r,i)}}),qS=Sv({sqrt_:function(t){const e={x:vv(t,"x","sqrt","float32")};return cv.runKernel(_x,e)}}),XS=Sv({squeeze_:function(t,e){const n=vv(t,"x","squeeze","string_or_numeric");return mw(n,wf(n.shape,e).newShape)}}),KS=Sv({stack_:function(t,e=0){const n=bv(t,"tensors","stack","string_or_numeric");uf(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&uf(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,i={axis:e};return cv.runKernel(qg,r,i)}}),YS=Sv({tanh_:function(t){const e={x:vv(t,"x","tanh","float32")};return cv.runKernel(Ux,e)}});function ZS(t,e){hf(t);const n=gv(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Iv(t,null,n,e)}const JS=Sv({truncatedNormal_:function(t,e=0,n=1,r,i){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new AS(e,n,r,!0,i),a=sb(t,r);for(let t=0;t<a.values.length;t++)a.values[t]=s.nextValue();return a.toTensor()}}),QS=Sv({unstack_:function(t,e=0){const n=vv(t,"x","unstack","string_or_numeric");uf(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},i={axis:e};return cv.runKernel(qx,r,i)}}),t_=Sv({where_:function(t,e,n){const r=vv(e,"a","where"),i=vv(n,"b","where"),s=vv(t,"condition","where","bool"),a=xb(xb(s.shape,r.shape),i.shape),o={condition:Sw(s,a),t:Sw(r,a),e:Sw(i,a)};return cv.runKernel(mx,o)}}),e_=Sv({zerosLike_:function(t){const e={x:vv(t,"x","zerosLike")};return cv.runKernel(Kx,e)}}),n_=Sv({imag_:function(t){const e={input:vv(t,"input","imag")};return cv.runKernel(hg,e)}}),r_=Sv({real_:function(t){const e={input:vv(t,"input","real")};return cv.runKernel(ex,e)}}),i_=Sv({transpose_:function(t,e,n){const r=vv(t,"x","transpose");if(null==e&&(e=r.shape.map(((t,e)=>e)).reverse()),uf(r.rank===e.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`)),e.forEach((t=>{uf(t>=0&&t<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${e}`))})),r.rank<=1)return r.clone();const i={x:r},s={perm:e};return"complex64"===r.dtype?Wb((()=>{let t=r_(r),e=n_(r);return t=cv.runKernel(Hx,{x:t},s),e=cv.runKernel(Hx,{x:e},s),n&&(e=wS(e)),_v(t,e)})):cv.runKernel(Hx,i,s)}}),s_=Sv({dropout_:function(t,e,n,r){const i=vv(t,"x","dropout");if(uf("float32"===i.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`)),uf(e>=0&&e<1,(()=>`rate must be a float in the range [0, 1), but got ${e}.`)),0===e)return t instanceof Hy?i.clone():i;const s=function(t,e){if(null==e)return t.shape.slice();if(ff(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(i,n),a=1-e,o=zw(jw(Zb(DS(s,0,1,"float32",r),a)),a);return tS(i,o)}}),a_=Sv({fft_:function(t){uf("complex64"===t.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`));const e={input:t};return cv.runKernel(Qm,e)}}),o_=Sv({rfft_:function(t,e){uf("float32"===t.dtype,(()=>`The dtype for rfft() must be real value but got ${t.dtype}`));let n=t.shape[t.shape.length-1];const r=t.size/n;let i;if(null!=e&&e<n){const r=t.shape.map((t=>0)),s=t.shape.map((t=>t));s[t.shape.length-1]=e,i=zS(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,i=kw([t,IS(r)],t.shape.length-1),n=e}else i=t;const s=e_(i),a=mw(_v(i,s),[r,n]),o=a_(a),l=Math.floor(n/2)+1,u=r_(o),c=n_(o),h=jS(u,[l,n-l],u.shape.length-1),d=jS(c,[l,n-l],c.shape.length-1),p=i.shape.slice();return p[i.shape.length-1]=l,mw(_v(h[0],d[0]),p)}}),l_=Sv({ifft_:function(t){uf("complex64"===t.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`));const e={input:t};return cv.runKernel(cg,e)}}),u_=Sv({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const i=mw(t,[n,e]);r=l_(i)}else{const i=[n,2*(e-1)],s=mw(r_(t),[n,e]),a=mw(n_(t),[n,e]),o=FS(zS(s,[0,1],[n,e-2]),1),l=tS(FS(zS(a,[0,1],[n,e-2]),1),Xb(-1)),u=kw([s,o],1),c=kw([a,l],1),h=mw(_v(u,c),[i[0],i[1]]);r=l_(h)}if(r=r_(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=mw(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}}),c_=Sv({conv2DBackpropFilter_:function(t,e,n,r,i,s="NHWC",a){let o=t;3===t.rank&&(o=mw(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=mw(e,[1,e.shape[0],e.shape[1],e.shape[2]])),uf(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),uf(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),uf(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===s?o.shape[3]:o.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];uf(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),uf(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),fw("conv2dDerFilter",i,a);const h={x:o,dy:l},d={strides:r,pad:i,dataFormat:s,dimRoundingMode:a,filterShape:n};return cv.runKernel(km,h,d)}}),h_=Sv({relu6_:function(t){const e={x:vv(t,"x","relu6")};return cv.runKernel(ux,e)}}),d_=Sv({step_:function(t,e=0){const n={x:vv(t,"x","step")},r={alpha:e};return cv.runKernel(Yx,n,r)}});function p_(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return tS(t,d_(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function f_(t,e){let n=e;const r=gb(t.shape,e.shape);return r.length>0&&(n=nS(n,r)),mw(n,t.shape)}function m_(t,e,n,r){if("linear"===e)return t;if("relu"===e)return LS(t);if("elu"===e)return Bw(t);if("relu6"===e)return h_(t);if("prelu"===e)return CS(t,n);if("leakyrelu"===e)return Yw(t,r);if("sigmoid"===e)return OS(t);throw new Error(`Unknown fused activation ${e}.`)}const g_=(t,e)=>!(t>0)||"linear"===e,x_=Sv({fusedConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",!1===g_(cv.state.gradientDepth,l)){uf("NHWC"===i,(()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let h=Aw(t,e,n,r,i,s,a);return null!=o&&(h=Zb(h,o)),m_(h,l,u,c)}const h=vv(t,"x","conv2d","float32"),d=vv(e,"filter","conv2d","float32");let p=h,f=!1;3===h.rank&&(f=!0,p=mw(h,[1,h.shape[0],h.shape[1],h.shape[2]])),uf(4===p.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`)),uf(4===d.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`)),fw("fused conv2d",r,a);const m="NHWC"===i?p.shape[3]:p.shape[1];uf(d.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`)),uf(dw(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));const g=iw(p.shape,d.shape,n,s,r,a);let x,y;if(null!=o&&(x=vv(o,"bias","fused conv2d"),[x]=nv(x,h),"NHWC"===i?xb(g.outShape,x.shape):(uf(x.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`)),uf(0===x.shape.length||x.shape[0]===g.outChannels||1===x.shape[0],(()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${g.outChannels})`)))),null!=u){const t=u.shape;if(uf(t.length<=1||3===t.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${t.length}.`)),1===t.length)uf(1===t[0]||t[0]===g.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${t}) is not compatible with the number of output channels (${g.outChannels}).`));else if(3===t.length)try{xb(t,g.outShape)}catch(e){const n=`Error in fused conv2d: PReLU activation weights (${t}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(n)}y=vv(u,"prelu weights","fused conv2d")}const v=(t,e)=>{uf("NHWC"===i,(()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`));const[a,o,u,c]=e,h=p_(t,u,l);uf(hw(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));const d=[Rw(o.shape,h,a,n,r),c_(o,h,a.shape,n,r)];if(null!=c){const t=f_(c,h);d.push(t)}return d},b={x:p,filter:d,bias:x,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a,activation:l,leakyreluAlpha:c};if(null==o){const t=qb(((t,e,n)=>{let r=cv.runKernel(Qx,b,w);return n([e,t,r]),f&&(r=mw(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return t(p,d)}{const t=qb(((t,e,n,r)=>{let i=cv.runKernel(Qx,b,w);return r([e,t,i,n]),f&&(i=mw(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:v}}));return t(p,d,x)}}}),y_=Sv({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,i,s=[1,1],a){let o=t;3===t.rank&&(o=mw(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=mw(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:i,dimRoundingMode:a,dilations:s,filterShape:n};return cv.runKernel(Om,u,c)}}),v_=Sv({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,i,s=[1,1],a){let o=e,l=!1;3===e.rank&&(l=!0,o=mw(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:i,dimRoundingMode:a,dilations:s,inputShape:t},h=cv.runKernel(zm,u,c);return l?mw(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});Sv({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===g_(cv.state.gradientDepth,l)){let h=Pw(t,e,n,r,i,s,a);return null!=o&&(h=Zb(h,o)),m_(h,l,u,c)}const h=vv(t,"x","depthwiseConv2d","float32"),d=vv(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;3===h.rank&&(f=!0,p=mw(h,[1,h.shape[0],h.shape[1],h.shape[2]])),uf(4===p.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`)),uf(4===d.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`)),uf(p.shape[3]===d.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`)),null==s&&(s=[1,1]),uf(dw(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),fw("fused depthwiseConv2d",r,a);const m=iw(p.shape,d.shape,n,s,r,a,!0);let g,x;null!=o&&(g=vv(o,"bias","fused conv2d"),[g]=nv(g,h),xb(m.outShape,g.shape)),null!=u&&(x=vv(u,"prelu weights","fused depthwiseConv2d"));const y=(t,e)=>{uf(hw(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));const[i,o,u,c]=e,h=p_(t,u,l),d=v_(o.shape,h,i,n,r,s,a),p=y_(o,h,i.shape,n,r,s,a);return null!=c?[d,p,f_(g,h)]:[d,p]},v={x:p,filter:d,bias:g,preluActivationWeights:x},b={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a,activation:l,leakyreluAlpha:c};if(null==o){const t=qb(((t,e,n)=>{let r=cv.runKernel(ty,v,b);return n([e,t,r]),f&&(r=mw(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}));return t(p,d)}{const t=qb(((t,e,n,r)=>{let i=cv.runKernel(ty,v,b);return r([e,t,i,n]),f&&(i=mw(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:y}}));return t(p,d,g)}}});const b_=Sv({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:i,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(!1===g_(cv.state.gradientDepth,s)){let l=sS(t,e,n,r);return null!=i&&(l=Zb(l,i)),m_(l,s,a,o)}let l=vv(t,"a","fused matMul"),u=vv(e,"b","fused matMul");[l,u]=nv(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=pf(f),x=pf(m);uf(c===h,(()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));const y=xb(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),v=mw(l,n?[g,c,d]:[g,d,c]),b=mw(u,r?[x,p,h]:[x,h,p]);let w,S;null!=i&&(w=vv(i,"bias","fused matMul"),[w]=nv(w,l),xb(y,w.shape)),null!=a&&(S=vv(a,"prelu weights","fused matMul"));const _=(t,e)=>{const[a,o,l,u]=e,c=p_(mw(t,l.shape),l,s);let h,d;return n||r?!n&&r?(h=sS(c,o,!1,!1),d=sS(c,a,!0,!1)):n&&!r?(h=sS(o,c,!1,!0),d=sS(a,c,!1,!1)):(h=sS(o,c,!0,!0),d=sS(c,a,!0,!0)):(h=sS(c,o,!1,!0),d=sS(a,c,!0,!1)),null!=i?[h,d,f_(u,c)]:[h,d]},I={a:v,b,bias:w,preluActivationWeights:S},k={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};if(null==i){const t=qb(((t,e,n)=>{const r=cv.runKernel(Jx,I,k);return n([t,e,r]),{value:mw(r,y),gradFunc:_}}));return t(v,b)}{const t=qb(((t,e,n,r)=>{const i=cv.runKernel(Jx,I,k);return r([t,e,i,n]),{value:mw(i,y),gradFunc:_}}));return t(v,b,w)}}});function w_(t,e,n){const r=1-t%2,i=new Float32Array(t);for(let s=0;s<t;++s){const a=2*Math.PI*s/(t+r-1);i[s]=e-n*Math.cos(a)}return ZS(i,"float32")}Sv({hammingWindow_:function(t){return w_(t,.54,.46)}});const S_=Sv({hannWindow_:function(t){return w_(t,.5,.5)}});function __(t,e,n){if(hf(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=gv(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Iv(t,e,r,n)}const I_=Sv({frame_:function(t,e,n,r=!1,i=0){let s=0;const a=[];for(;s+e<=t.size;)a.push(zS(t,s,e)),s+=n;if(r)for(;s<t.size;){const r=s+e-t.size,o=kw([zS(t,s,e-r),_w([r],i)]);a.push(o),s+=n}return 0===a.length?__([],[0,e]):mw(kw(a),[a.length,e])}});Sv({stft_:function(t,e,n,r,i=S_){var s;null==r&&(s=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));const a=I_(t,e,n),o=tS(a,i(e));return o_(o,r)}});const k_=Sv({cropAndResize_:function(t,e,n,r,i="bilinear",s=0){const a=vv(t,"image","cropAndResize"),o=vv(e,"boxes","cropAndResize","float32"),l=vv(n,"boxInd","cropAndResize","int32"),u=o.shape[0];uf(4===a.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`)),uf(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),uf(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),uf(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),uf(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),uf("bilinear"===i||"nearest"===i,(()=>`method must be bilinear or nearest, but was ${i}`));const c={image:a,boxes:o,boxInd:l},h={method:i,extrapolationValue:s,cropSize:r};return cv.runKernel(Lm,c,h)}}),M_=Sv({flipLeftRight_:function(t){const e=vv(t,"image","flipLeftRight","float32");uf(4===e.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`));const n={image:e};return cv.runKernel(eg,n,{})}}),T_=Sv({grayscaleToRGB_:function(t){const e=vv(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];uf(e.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`)),uf(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const i=new Array(e.rank);return i.fill(1,0,n),i[n]=3,Gw(e,i)}}),C_=Sv({rotateWithOffset_:function(t,e,n=0,r=.5){const i=vv(t,"image","rotateWithOffset","float32");uf(4===i.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`));const s={image:i},a={radians:e,fillValue:n,center:r};return cv.runKernel(Zx,s,a)}});function E_(t,e,n,r,i,s){null==r&&(r=.5),null==i&&(i=Number.NEGATIVE_INFINITY),null==s&&(s=0);const a=t.shape[0];return n=Math.min(n,a),uf(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),uf(2===t.rank,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`)),uf(4===t.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`)),uf(1===e.rank,(()=>"scores must be a 1D tensor")),uf(e.shape[0]===a,(()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`)),uf(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:s}}const A_=Sv({nonMaxSuppression_:function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY){const s=vv(t,"boxes","nonMaxSuppression","float32"),a=vv(e,"scores","nonMaxSuppression","float32"),o=E_(s,a,n,r,i),l={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:i=o.scoreThreshold};return cv.runKernel(Wg,{boxes:s,scores:a},l)}});function N_(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,i=t.length,s=0,a=!1;for(;r<i;){s=r+(i-r>>>1);const o=n(e,t[s]);o>0?r=s+1:(i=s,a=!o)}return a?r:-r-1}(t,e,n||R_)}(t,e,n),i=r<0?-(r+1):r;t.splice(i,0,e)}function R_(t,e){return t>e?1:t<e?-1:0}function D_(t,e,n,r,i){return $_(t,e,n,r,i,0)}function L_(t,e,n,r,i,s){return $_(t,e,n,r,i,0,!1,s,!0)}function F_(t,e,n,r,i,s){return $_(t,e,n,r,i,s,!0)}function $_(t,e,n,r,i,s,a=!1,o=!1,l=!1){const u=[];for(let t=0;t<e.length;t++)e[t]>i&&u.push({score:e[t],boxIndex:t,suppressBeginIndex:0});u.sort(z_);const c=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&u.length>0;){const e=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:a}=e;if(n<i)break;let o=!1;for(let n=h.length-1;n>=a;--n){const a=P_(t,s,h[n]);if(a>=r){o=!0;break}if(e.score=e.score*O_(r,c,a),e.score<=i)break}e.suppressBeginIndex=h.length,o||(e.score===n?(h.push(s),d.push(e.score)):e.score>i&&N_(u,e,z_))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return a&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function P_(t,e,n){const r=t.subarray(4*e,4*e+4),i=t.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(i[0],i[2]),c=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),d=Math.max(i[1],i[3]),p=(o-s)*(l-a),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(s,u),g=Math.max(a,c),x=Math.min(o,h),y=Math.min(l,d),v=Math.max(x-m,0)*Math.max(y-g,0);return v/(p+f-v)}function O_(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function z_(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const B_=Sv({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=vv(t,"boxes","nonMaxSuppression"),o=vv(e,"scores","nonMaxSuppression"),l=E_(a,o,n,r,i,s),u={boxes:a,scores:o},c={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:i=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma},h=cv.runKernel(Gg,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}}),U_=Sv({nonMaxSuppressionPadded_:function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=vv(t,"boxes","nonMaxSuppression"),o=vv(e,"scores","nonMaxSuppression"),l=E_(a,o,n,r,i,null),u={boxes:a,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},h=cv.runKernel(Vg,u,c);return{selectedIndices:h[0],validOutputs:h[1]}}}),W_=Sv({resizeBilinear_:function(t,e,n=!1,r=!1){const i=vv(t,"images","resizeBilinear");uf(3===i.rank||4===i.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`)),uf(2===e.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`)),uf(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=i,a=!1;3===i.rank&&(a=!0,s=mw(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[]=e,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},u=cv.runKernel(ox,o,l);return a?mw(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),V_=Sv({resizeNearestNeighbor_:function(t,e,n=!1,r=!1){const i=vv(t,"images","resizeNearestNeighbor");uf(3===i.rank||4===i.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`)),uf(2===e.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`)),uf("float32"===i.dtype||"int32"===i.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),uf(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=i,a=!1;3===i.rank&&(a=!0,s=mw(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const[]=e,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},u=cv.runKernel(sx,o,l);return a?mw(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),G_=Sv({bincount_:function(t,e,n){const r=vv(t,"x","bincount"),i=vv(e,"weights","bincount");uf("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),uf(n>=0,(()=>`size must be non-negative, but got ${n}.`)),uf(i.size===r.size||0===i.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`));const s={x:r,weights:i},a={size:n};return cv.runKernel(gm,s,a)}}),H_=Sv({lessEqual_:function(t,e){let n=vv(t,"a","lessEqual","string_or_numeric"),r=vv(e,"b","lessEqual","string_or_numeric");[n,r]=nv(n,r),xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(xg,i)}}),j_=Sv({round_:function(t){const e={x:vv(t,"x","round")};return cv.runKernel(hx,e)}});function q_(t,e,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const i={start:t,stop:e,step:n,dtype:r};return cv.runKernel(tx,{},i)}const X_=Sv({threshold_:function(t,e="binary",n=!1,r=.5){const i=vv(t,"image","threshold"),s=i.shape[0]*i.shape[1];let a,o,l,u,c=tS(ZS([r]),255);if(uf(3===i.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`)),uf(3===i.shape[2]||1===i.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`)),uf("int32"===i.dtype||"float32"===i.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`)),uf("otsu"===e||"binary"===e,(()=>`Method must be binary or otsu, but was ${e}`)),3===i.shape[2]){[a,o,l]=jS(i,[1,1,1],-1);const t=tS(a,.2989),e=tS(o,.587),n=tS(l,.114);u=Zb(Zb(t,e),n)}else u=t;"otsu"===e&&(c=function(t,e){let n,r,i,s,a,o,l=ZS([-1]),u=ZS([0]),c=ZS([0]);for(let h=0;h<t.size-1;h++){n=zS(t,0,h+1),r=zS(t,h+1),a=zw(nS(n),e),o=zw(nS(r),e);const d=nS(tS(n,q_(0,n.size)));i=zw(d,nS(n));const p=_w(r.shape,n.size),f=Zb(q_(0,r.size),p),m=tS(r,f);s=zw(nS(m),nS(r));const g=eS(i,s),x=eS(i,s),y=tS(a,o);c=tS(tS(y,g),x);const v=Xw(c,u);u=t_(v,c,u),l=t_(v,ZS([h]),l)}return l}(G_(ab(j_(u),"int32"),kv([]),256),s));const h=n?H_(u,c):Xw(u,c);return ab(tS(h,255),"int32")}}),K_=Sv({transform_:function(t,e,n="nearest",r="constant",i=0,s){const a=vv(t,"image","transform","float32"),o=vv(e,"transforms","transform","float32");uf(4===a.rank,(()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`)),uf(2===o.rank&&(o.shape[0]===a.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),uf(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const l={image:a,transforms:o},u={interpolation:n,fillMode:r,fillValue:i,outputShape:s};return cv.runKernel(Gx,l,u)}}),Y_=Sv({bandPart_:function(t,e,n){uf(e%1==0,(()=>`bandPart(): numLower must be an integer, got ${e}.`)),uf(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const r=vv(t,"a","bandPart");uf(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const i=r.shape,[s,a]=r.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=s),n<0&&(n=a);const o=mw(q_(0,s,1,"int32"),[-1,1]),l=q_(0,a,1,"int32"),u=eS(o,l),c=iS(H_(u,Xb(+e,"int32")),Kw(u,Xb(-n,"int32"))),h=IS([s,a],r.dtype);return mw(KS(QS(mw(r,[-1,s,a])).map((t=>t_(c,t,h)))),i)}}),Z_=Sv({min_:function(t,e=null,n=!1){const r={x:vv(t,"x","min")},i={axis:e,keepDims:n};return cv.runKernel(Lg,r,i)}}),J_=Sv({pow_:function(t,e){let n=vv(t,"base","pow"),r=vv(e,"exp","pow");[n,r]=nv(n,r);const i={a:n,b:r};return cv.runKernel(Kg,i)}});function Q_(t,e,n=null){if(0===t.rank)return Yb(t);if(1!==t.rank&&null===n)return Q_(mw(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return nS(Yb(t),n);if(e===1/0)return Qw(Yb(t),n);if(e===-1/0)return Z_(Yb(t),n);if("euclidean"===e||2===e)return qS(nS(J_(Yb(t),Xb(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return Qw(nS(Yb(t),n[0]),n[1]-1);if(e===1/0)return Qw(nS(Yb(t),n[1]),n[0]);if(e===-1/0)return Z_(nS(Yb(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return qS(nS(vS(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const tI=Sv({norm_:function(t,e="euclidean",n=null,r=!1){const i=Q_(t=vv(t,"x","norm"),e,n);let s=i.shape;if(r){const e=bf(n,t.shape);s=fS(i.shape,e)}return mw(i,s)}}),eI=Sv({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,uf(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)uf(t[e].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`))}else e=!0,t=jS(t,t.shape[0],0).map((t=>XS(t,[0])));uf(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`));const n=[],r=t;for(let e=0;e<t.length;++e)n.push(cv.tidy((()=>{let t=r[e];if(e>0)for(let r=0;r<e;++r){const e=tS(nS(tS(n[r],t)),n[r]);t=eS(t,e)}return zw(t,tI(t,"euclidean"))})));return e?KS(n,0):n}});function nI(t,e=!1){return cv.tidy((()=>{uf(2===t.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const n=t.shape[0],r=t.shape[1];let i=Hw(n),s=ob(t);const a=__([[1]],[1,1]);let o=ob(a);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=s,l=o,u=i;[o,s,i]=cv.tidy((()=>{const e=zS(s,[t,t],[n-t,1]),l=tI(e),u=zS(s,[t,t],[1,1]),c=t_(Xw(u,0),__([[-1]]),__([[1]])),h=eS(u,tS(c,l)),d=zw(e,h);o=1===d.shape[0]?ob(a):kw([a,zS(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=wS(zw(sS(c,h),l)),f=zS(s,[t,0],[n-t,r]),m=tS(p,o),g=i_(o);if(0===t)s=eS(f,sS(m,sS(g,f)));else{const e=eS(f,sS(m,sS(g,f)));s=kw([zS(s,[0,0],[t,r]),e],0)}const x=i_(m),y=zS(i,[0,t],[n,i.shape[1]-t]);if(0===t)i=eS(y,sS(sS(y,o),x));else{const e=eS(y,sS(sS(y,o),x));i=kw([zS(i,[0,0],[n,t]),e],1)}return[o,s,i]})),Vb([e,l,u])}return!e&&n>r&&(i=zS(i,[0,0],[n,r]),s=zS(s,[0,0],[r,r])),[i,s]}))}const rI=Sv({qr_:function(t,e=!1){if(uf(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`)),2===t.rank)return nI(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=QS(mw(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),i=[],s=[];return r.forEach((t=>{const[n,r]=nI(t,e);i.push(n),s.push(r)})),[mw(KS(i,0),t.shape),mw(KS(s,0),t.shape)]}}});var iI;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(iI||(iI={}));const sI=Sv({computeWeightedLoss_:function(t,e,n=iI.SUM_BY_NONZERO_WEIGHTS){const r=vv(t,"losses","computeWeightedLoss");let i=null;null!=e&&(i=vv(e,"weights","computeWeightedLoss"));const s=null==i?r:tS(r,i);if(n===iI.NONE)return s;if(n===iI.SUM)return nS(s);if(n===iI.MEAN){if(null==i)return uS(s);{const t=r.size/i.size,e=zw(nS(s),nS(i));return t>1?zw(e,Xb(t)):e}}if(n===iI.SUM_BY_NONZERO_WEIGHTS){if(null==i)return zw(nS(s),Xb(r.size));{const t=tS(i,kS(r.shape)),e=ab(nS(SS(t,Xb(0))),"float32");return zw(nS(s),e)}}throw Error(`Unknown reduction: ${n}`)}});Sv({absoluteDifference_:function(t,e,n,r=iI.SUM_BY_NONZERO_WEIGHTS){const i=vv(t,"labels","absoluteDifference"),s=vv(e,"predictions","absoluteDifference");let a=null;null!=n&&(a=vv(n,"weights","absoluteDifference")),cf(i.shape,s.shape,"Error in absoluteDifference: ");const o=Yb(eS(i,s));return sI(o,a,r)}}),Sv({cosineDistance_:function(t,e,n,r,i=iI.SUM_BY_NONZERO_WEIGHTS){const s=vv(t,"labels","cosineDistance"),a=vv(e,"predictions","cosineDistance");let o=null;null!=r&&(o=vv(r,"weights","cosineDistance")),cf(s.shape,a.shape,"Error in cosineDistance: ");const l=Xb(1),u=eS(l,nS(tS(s,a),n,!0));return sI(u,o,i)}}),Sv({hingeLoss_:function(t,e,n,r=iI.SUM_BY_NONZERO_WEIGHTS){let i=vv(t,"labels","hingeLoss");const s=vv(e,"predictions","hingeLoss");let a=null;null!=n&&(a=vv(n,"weights","hingeLoss")),cf(i.shape,s.shape,"Error in hingeLoss: ");const o=Xb(1);i=eS(tS(Xb(2),i),o);const l=LS(eS(o,tS(i,s)));return sI(l,a,r)}}),Sv({huberLoss_:function(t,e,n,r=1,i=iI.SUM_BY_NONZERO_WEIGHTS){const s=vv(t,"labels","huberLoss"),a=vv(e,"predictions","huberLoss");let o=null;null!=n&&(o=vv(n,"weights","huberLoss")),cf(s.shape,a.shape,"Error in huberLoss: ");const l=Xb(r),u=Yb(eS(a,s)),c=cS(u,l),h=eS(u,c),d=Zb(tS(Xb(.5),vS(c)),tS(l,h));return sI(d,o,i)}}),Sv({logLoss_:function(t,e,n,r=1e-7,i=iI.SUM_BY_NONZERO_WEIGHTS){const s=vv(t,"labels","logLoss"),a=vv(e,"predictions","logLoss");let o=null;null!=n&&(o=vv(n,"weights","logLoss")),cf(s.shape,a.shape,"Error in logLoss: ");const l=Xb(1),u=Xb(r),c=wS(tS(s,Zw(Zb(a,u)))),h=tS(eS(l,s),Zw(Zb(eS(l,a),u))),d=eS(c,h);return sI(d,o,i)}});const aI=Sv({squaredDifference_:function(t,e){let n=vv(t,"a","squaredDifference"),r=vv(e,"b","squaredDifference");[n,r]=nv(n,r),xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(Dx,i,{})}});Sv({meanSquaredError_:function(t,e,n,r=iI.SUM_BY_NONZERO_WEIGHTS){const i=vv(t,"labels","meanSquaredError"),s=vv(e,"predictions","meanSquaredError");let a=null;null!=n&&(a=vv(n,"weights","meanSquaredError")),cf(i.shape,s.shape,"Error in meanSquaredError: ");const o=aI(i,s);return sI(o,a,r)}}),Sv({sigmoidCrossEntropy_:function(t,e,n,r=0,i=iI.SUM_BY_NONZERO_WEIGHTS){let s=vv(t,"multiClassLabels","sigmoidCrossEntropy");const a=vv(e,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=vv(n,"weights","sigmoidCrossEntropy")),cf(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=Xb(r),e=Xb(1),n=Xb(.5);s=Zb(tS(s,eS(e,t)),tS(n,t))}const l=function(t,e){const n=vv(t,"labels","sigmoidCrossEntropyWithLogits"),r=vv(e,"logits","sigmoidCrossEntropyWithLogits");cf(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=LS(r),s=tS(r,n),a=Jw(Ww(wS(Yb(r))));return Zb(eS(i,s),a)}(s,a);return sI(l,o,i)}});const oI=Sv({logSumExp_:function(t,e=null,n=!1){const r=vv(t,"x","logSumExp"),i=bf(e,r.shape),s=Qw(r,i,!0),a=eS(r,s),o=Ww(a),l=nS(o,i),u=Zw(l),c=Zb(mw(s,u.shape),u);if(n){const t=fS(c.shape,i);return mw(c,t)}return c}});Sv({softmaxCrossEntropy_:function(t,e,n,r=0,i=iI.SUM_BY_NONZERO_WEIGHTS){let s=vv(t,"onehotLabels","softmaxCrossEntropy");const a=vv(e,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=vv(n,"weights","softmaxCrossEntropy")),cf(s.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){const t=Xb(r),e=Xb(1),n=Xb(s.shape[1]);s=Zb(tS(s,eS(e,t)),zw(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);const r=qb(((t,e,r)=>{const i=oI(e,[n],!0),s=eS(ab(e,"float32"),i);r([t,s]);const a=wS(tS(s,t));return{value:nS(a,[n]),gradFunc:(t,e)=>{const[r,i]=e,s=fS(t.shape,[n]);return[tS(mw(t,s),eS(ab(r,"float32"),Ww(i))),tS(mw(t,s),eS(Ww(i),ab(r,"float32")))]}}}));return r(t,e)}(s,a);return sI(l,o,i)}}),Sv({sparseFillEmptyRows_:function(t,e,n,r){const i=vv(t,"indices","sparseFillEmptyRows","int32"),s=vv(e,"values","sparseFillEmptyRows"),a=vv(n,"denseShape","sparseFillEmptyRows","int32"),o=vv(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==i.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${i.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:i,values:s,denseShape:a,defaultValue:o},u=cv.runKernel(Cx,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),Sv({sparseReshape_:function(t,e,n){const r=vv(t,"inputIndices","sparseReshape","int32"),i=vv(e,"inputShape","sparseReshape","int32"),s=vv(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==i.rank)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const a={inputIndices:r,inputShape:i,newShape:s},o=cv.runKernel(Ex,a);return{outputIndices:o[0],outputShape:o[1]}}}),Sv({sparseSegmentMean_:function(t,e,n){const r=vv(t,"data","sparseSegmentMean"),i=vv(e,"indices","sparseSegmentMean","int32"),s=vv(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${i.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const a={data:r,indices:i,segmentIds:s};return cv.runKernel(Ax,a)}}),Sv({sparseSegmentSum_:function(t,e,n){const r=vv(t,"data","sparseSegmentSum"),i=vv(e,"indices","sparseSegmentSum","int32"),s=vv(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${i.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const a={data:r,indices:i,segmentIds:s};return cv.runKernel(Nx,a)}}),Sv({stringNGrams_:function(t,e,n,r,i,s,a,o){const l=vv(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=vv(e,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:i,rightPad:s,padWidth:a,preserveShortSequences:o},h={data:l,dataSplits:u},d=cv.runKernel($x,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}}),Sv({stringSplit_:function(t,e,n=!0){const r=vv(t,"input","stringSplit","string"),i=vv(e,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==i.rank)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const s={skipEmpty:n},a={input:r,delimiter:i},o=cv.runKernel(Px,a,s);return{indices:o[0],values:o[1],shape:o[2]}}}),Sv({stringToHashBucketFast_:function(t,e){const n=vv(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const i={input:n};return cv.runKernel(Ox,i,r)}});const lI={flipLeftRight:M_,grayscaleToRGB:T_,resizeNearestNeighbor:V_,resizeBilinear:W_,rotateWithOffset:C_,cropAndResize:k_,nonMaxSuppression:A_,nonMaxSuppressionAsync:async function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY){const s=vv(t,"boxes","nonMaxSuppressionAsync"),a=vv(e,"scores","nonMaxSuppressionAsync"),o=E_(s,a,n,r,i);n=o.maxOutputSize,r=o.iouThreshold,i=o.scoreThreshold;const l=await Promise.all([s.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:h}=D_(u,c,n,r,i);return s!==t&&s.dispose(),a!==e&&a.dispose(),ZS(h,"int32")},nonMaxSuppressionWithScore:B_,nonMaxSuppressionWithScoreAsync:async function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=vv(t,"boxes","nonMaxSuppressionAsync"),o=vv(e,"scores","nonMaxSuppressionAsync"),l=E_(a,o,n,r,i,s);n=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([a.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=F_(c,h,n,r,i,s);return a!==t&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:ZS(d,"int32"),selectedScores:ZS(p)}},nonMaxSuppressionPadded:U_,nonMaxSuppressionPaddedAsync:async function(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=vv(t,"boxes","nonMaxSuppressionAsync"),o=vv(e,"scores","nonMaxSuppressionAsync"),l=E_(a,o,n,r,i,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([a.data(),o.data()]),{selectedIndices:f,validOutputs:m}=L_(d,p,u,c,h,s);return a!==t&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:ZS(f,"int32"),validOutputs:Xb(m,"int32")}},threshold:X_,transform:K_},uI={bandPart:Y_,gramSchmidt:eI,qr:rI};class cI extends Kb{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=cv.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=cv.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:Wb((()=>e_(r).variable(!1)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:Wb((()=>e_(r).variable(!1)))});const i=Array.isArray(t)?t[n].tensor:t[e];if(null==i)return;const s=this.accumulatedGrads[n].variable,a=this.accumulatedUpdates[n].variable;Wb((()=>{const t=Zb(tS(s,this.rho),tS(vS(i),1-this.rho)),e=tS(zw(qS(Zb(a,this.epsilon)),qS(Zb(s,this.epsilon))),i),n=Zb(tS(a,this.rho),tS(vS(e),1-this.rho));s.assign(t),a.assign(n);const o=Zb(tS(e,-this.learningRate),r);r.assign(o)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Vb(this.accumulatedGrads.map((t=>t.variable))),Vb(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}cI.className="Adadelta",zb(cI);class hI extends Kb{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=cv.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:Wb((()=>_w(r.shape,this.initialAccumulatorValue).variable(t)))}}const i=Array.isArray(t)?t[n].tensor:t[e];if(null==i)return;const s=this.accumulatedGrads[n].variable;Wb((()=>{const t=Zb(s,vS(i));s.assign(t);const e=Zb(tS(zw(i,qS(Zb(t,cv.backend.epsilon()))),-this.learningRate),r);r.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Vb(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}hI.className="Adagrad",zb(hI);class dI extends Kb{constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Wb((()=>{this.accBeta1=Xb(e).variable(),this.accBeta2=Xb(n).variable()})),null==r&&(this.epsilon=cv.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Wb((()=>{const n=eS(1,this.accBeta1),r=eS(1,this.accBeta2);e.forEach(((e,i)=>{const s=cv.registeredVariables[e];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${e}/m`,variable:Wb((()=>e_(s).variable(!1)))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${e}/v`,variable:Wb((()=>e_(s).variable(!1)))});const a=Array.isArray(t)?t[i].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[i].variable,l=this.accumulatedSecondMoment[i].variable,u=Zb(tS(o,this.beta1),tS(a,1-this.beta1)),c=Zb(tS(l,this.beta2),tS(vS(a),1-this.beta2)),h=zw(u,n),d=zw(c,r);o.assign(u),l.assign(c);const p=Zb(tS(zw(h,Zb(qS(d),this.epsilon)),-this.learningRate),s);s.assign(p)})),this.accBeta1.assign(tS(this.accBeta1,this.beta1)),this.accBeta2.assign(tS(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Vb(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&Vb(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),Wb((()=>{this.accBeta1.assign(J_(this.beta1,this.iterations_+1)),this.accBeta2.assign(J_(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}dI.className="Adam",zb(dI);class pI extends Kb{constructor(t,e,n,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Wb((()=>{this.iteration=Xb(0).variable(),this.accBeta1=Xb(e).variable()})),null==r&&(this.epsilon=cv.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);Wb((()=>{const n=eS(1,this.accBeta1),r=zw(-this.learningRate,Zb(tS(this.iteration,this.decay),1));e.forEach(((e,i)=>{const s=cv.registeredVariables[e];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${e}/m`,variable:e_(s).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${e}/v`,variable:e_(s).variable(!1)});const a=Array.isArray(t)?t[i].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[i].variable,l=this.accumulatedWeightedInfNorm[i].variable,u=Zb(tS(o,this.beta1),tS(a,1-this.beta1)),c=tS(l,this.beta2),h=Yb(a),d=lS(c,h);o.assign(u),l.assign(d);const p=Zb(tS(zw(r,n),zw(u,Zb(d,this.epsilon))),s);s.assign(p)})),this.iteration.assign(Zb(this.iteration,1)),this.accBeta1.assign(tS(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Vb(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&Vb(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}pI.className="Adamax",zb(pI);class fI extends Kb{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const i=cv.registeredVariables[e];Wb((()=>{const t=Zb(tS(this.c,r),i);i.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=Gb(Xb(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}fI.className="SGD",zb(fI);class mI extends fI{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=Xb(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=cv.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:Wb((()=>e_(r).variable(t)))}}const i=this.accumulations[n].variable,s=Array.isArray(t)?t[n].tensor:t[e];null!=s&&Wb((()=>{let t;const e=Zb(tS(this.m,i),s);t=this.useNesterov?Zb(tS(this.c,Zb(s,tS(e,this.m))),r):Zb(tS(this.c,e),r),i.assign(e),r.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Vb(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}mI.className="Momentum",zb(mI);class gI extends Kb{constructor(t,e=.9,n=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==r&&(this.epsilon=cv.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=cv.registeredVariables[e],i=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:Wb((()=>e_(r).variable(i)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:Wb((()=>e_(r).variable(i)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:Wb((()=>e_(r).variable(i)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const a=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Wb((()=>{const t=Zb(tS(a,this.decay),tS(vS(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,i=Zb(tS(e,this.decay),tS(s,1-this.decay)),l=zw(tS(s,this.learningRate),qS(eS(t,Zb(vS(i),this.epsilon)))),u=Zb(tS(o,this.momentum),l);a.assign(t),e.assign(i),o.assign(u);const c=eS(r,u);r.assign(c)}else{const t=Zb(tS(a,this.decay),tS(vS(s),1-this.decay)),e=Zb(tS(o,this.momentum),zw(tS(s,this.learningRate),qS(Zb(t,this.epsilon))));a.assign(t),o.assign(e);const n=eS(r,e);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Vb(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Vb(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&Vb(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}gI.className="RMSProp",zb(gI);class xI{static sgd(t){return new fI(t)}static momentum(t,e,n=!1){return new mI(t,e,n)}static rmsprop(t,e=.9,n=0,r=null,i=!1){return new gI(t,e,n,r,i)}static adam(t=.001,e=.9,n=.999,r=null){return new dI(t,e,n,r)}static adadelta(t=.001,e=.95,n=null){return new cI(t,e,n)}static adamax(t=.002,e=.9,n=.999,r=null,i=0){return new pI(t,e,n,r,i)}static adagrad(t,e=.1){return new hI(t,e)}}const yI={sgd:xI.sgd,momentum:xI.momentum,adadelta:xI.adadelta,adagrad:xI.adagrad,rmsprop:xI.rmsprop,adamax:xI.adamax,adam:xI.adam},vI="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function bI(){return new Promise((t=>vI((()=>t()))))}function wI(t,e){const n=t[0].length;t.forEach(((t,e)=>{uf(t.length===n,(()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`))})),uf(e>=0&&e<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=t[0];t.forEach(((t,i)=>{for(let s=0;s<n;s++)uf(s===e||t[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${i}] (${t}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`))}))}function SI(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}var _I;function II(t,e,n){let r=new Array;if(null==n&&null==e)return r;if(null==e)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(null==n)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let i=1;i<n.length;++i){const s=n[i],a=r[r.length-n.length+i],o=r[a];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+t}] = ${s} but shape[${i+t}] = ${o}`)}else r[a]=s}return r}function kI(t){const e={FIRST_DIM_SIZE:_I.FIRST_DIM_SIZE,VALUE_ROWIDS:_I.VALUE_ROWIDS,ROW_LENGTHS:_I.ROW_LENGTHS,ROW_SPLITS:_I.ROW_SPLITS,ROW_LIMITS:_I.ROW_LIMITS,ROW_STARTS:_I.ROW_STARTS},n=[];for(const r of t){if(!(r in e))break;n.push(e[r])}return n}function MI(t){return 0===t.length?0:t[0]===_I.FIRST_DIM_SIZE?t.length-1:t.length}function TI(t,e){if(null==t||null==e)return;const n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(n,r-1);++i){const n=t[i],r=e[i+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-t.length}] = ${n} but ragged tensor input.flatValues.shape[${i-t.length}] = ${r}`)}}!function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"}(_I||(_I={}));const CI=30;function EI(t){return t<=CI?t:Nf(t,Math.floor(Math.sqrt(t)))}function AI(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function NI(t,e,n,r=!0){let i=[];if(r)i=i.concat(e.slice(0)),i.push(t[0]/n),i=i.concat(t.slice(1));else{i=i.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)i=i.concat([t[r+1]/e[r],e[r]]);i=i.concat(t.slice(n+1))}return i}function RI(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],i=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?i.push(r):n.push(r);r.push(...n),r.push(0),r.push(...i)}return r}function DI(t,e,n,r=!0){const i=[];r?i.push(t[0]/n):i.push(t[0]*n);for(let n=1;n<t.length;++n)n<=e.length?r?i.push(e[n-1]*t[n]):i.push(t[n]/e[n-1]):i.push(t[n]);return i}function LI(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function FI(t,e,n){const r=t.slice(0,1);for(let i=0;i<n;++i)r.push(t[i+1]-e[i][0]-e[i][1]);return r}function $I(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(0===pf(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const i=e.shape,s=i[i.length-1];let a=1;for(let t=0;t<i.length-1;++t)a*=i[t];const o=t.shape,l=i.slice();l.pop();let u=1;for(let t=s;t<n;++t)u*=o[t],l.push(o[t]);const c=[...Rf(t.shape).map((t=>t/u)),1].slice(0,s);return[l,a,u,c]}function PI(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${i}.`;if(n.rank<i)throw new Error(s+` update.rank < ${i}. `);if(t.length<r+(n.rank-i))throw new Error(s+` Output shape length < ${r+(n.rank-i)}`);if(n.rank!==i+t.length-r)throw new Error(s+" update.rank != "+(i+t.length-r));for(let t=0;t<i;++t)if(n.shape[t]!==e.shape[t])throw new Error(s+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-i;++e)if(n.shape[e+i]!==t[e+r])throw new Error(s+` updates.shape[${e+i}] (${n.shape[e+i]}) != shape[${e+i}] (${t[e+i]})`)}function OI(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}PI(n,e,t)}function zI(t,e,n){const r=e.shape.length,i=r>1?e.shape[r-1]:1,s=n.length;let a=1;for(let t=i;t<s;++t)a*=n[t];const o=i<1?1:i;return{sliceRank:i,numUpdates:pf(e.shape)/o,sliceSize:a,strides:[...Rf(n.slice(0,i)),1],outputSize:pf(n)}}const BI=1.7580993408473768,UI=1.0507009873554805,WI=.3275911,VI=.254829592,GI=-.284496736,HI=1.421413741,jI=-1.453152027,qI=1.061405429;function XI(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function KI(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function YI(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=0;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function ZI(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=2;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function JI(t,e){return{real:t[2*e],imag:t[2*e+1]}}function QI(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function tk(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let i=0;i<Math.ceil(t/2);i++){const s=(e?2:-2)*Math.PI*(i/t);n[i]=Math.cos(s),r[i]=Math.sin(s)}return{real:n,imag:r}}function ek(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}const nk="->",rk=/->/g,ik=",",sk="...";function ak(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(rk,"").length)/nk.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${nk}").`);const[r,i]=t.split(nk);uf(-1===r.indexOf(sk),(()=>`The ellipsis notation ("${sk}") is not supported yet.`));const s=r.split(ik),a=s.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let t=0;t<i.length;++t){const e=i[t];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let t=0;t<r.length;++t){const e=r[t];-1===o.indexOf(e)&&e!==ik&&o.push(e)}const l=new Array(s.length);for(let t=0;t<a;++t){if(new Set(s[t].split("")).size!==s[t].length)throw new Error(`Found duplicate axes in input component ${s[t]}. Support for duplicate axes in input is not implemented yet.`);l[t]=[];for(let e=0;e<s[t].length;++e)l[t].push(o.indexOf(s[t][e]))}const u=o.length,c=[];for(let t=i.length;t<u;++t)c.push(t);return{allDims:o,summedDims:c,idDims:l}}function ok(t,e){let n=new Array(t);n.fill(-1);for(let t=0;t<e.length;++t)n[e[t]]=t;const r=[];for(let e=0;e<t;++e)-1===n[e]&&r.push(e);return n=n.filter((t=>-1!==t)),{permutationIndices:n,expandDims:r}}function lk(t,e,n){const r=new Array(t);for(let t=0;t<n.length;++t){const i=n[t].shape;for(let n=0;n<e[t].length;++n)void 0===r[e[t][n]]?r[e[t][n]]=i[n]:uf(r[e[t][n]]===i[n],(()=>`Expected dimension ${r[e[t][n]]} at axis ${n} of input shaped ${JSON.stringify(i)}, but got dimension ${i[n]}`))}}function uk(t,e){const n=t,r=[];let i=0;0===t.length&&n.push(-1),i=t.length+1;for(let t=0;t<i;++t)r.push([]);const s=[];for(let t=0;t<n.length;++t){const i=hk(e,n[t]);for(const e of i)-1===s.indexOf(e)&&(r[t].push(e),s.push(e))}return{path:n,steps:r}}function ck(t){return t.every(((t,e)=>t===e))}function hk(t,e){const n=[];for(let r=0;r<t.length;++r)0!==t[r].length&&-1===t[r].indexOf(e)&&-1!==e||n.push(r);return n}function dk(t,e,n=0){let r=[];if("number"==typeof e)uf(t.shape[n]%e==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(e).fill(t.shape[n]/e);else{const i=e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0);uf(i<=1,(()=>"There should be only one negative value in split array."));const s=e.indexOf(-1);if(-1!==s){const r=e.reduce(((t,e)=>e>0?t+e:t));e[s]=t.shape[n]-r}uf(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=e}return r}function pk(t){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${t}`}function fk(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function mk(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}function gk(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function xk(t,e){return`size ${t} must be non-negative, not ${e}`}function yk(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function vk(t,e){return`Input to reshape is a SparseTensor with ${pf(t)}\n  dense values, but the requested shape requires a multiple of ${pf(e)}. inputShape=${t} outputShape= ${e}`}function bk(t,e){return`Input to reshape is a tensor with ${pf(t)} dense values, but the requested shape has ${pf(e)}. inputShape=${t} outputShape=${e}`}function wk(){return"segment ids must be >= 0"}function Sk(){return"segment ids are not increasing"}function _k(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Ik(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}function kk(t,e){let n,r=!1;for(t<=CI?(n=t,r=!0):n=Nf(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=Nf(t,n+1);return n}function Mk(t,e,n){const r=[],i=t.length;for(let s=0;s<i;s++)s!==e?r.push(t[s]):r.push(n);return r}function Tk(t,e,n,r){const i=e.shape.length,s=t.shape.length;if(0!==r&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(t.shape[n]!==e.shape[n])throw new Error(`x.shape[${n}]: ${t.shape[n]} should be equal to indices.shape[${n}]: ${e.shape[n]}.`);const a=t.shape[n],o=[];let l=1,u=1,c=1;for(let e=0;e<r;++e)o.push(t.shape[e]),l*=t.shape[e];for(let e=r;e<n;e++)o.push(t.shape[e]),u*=t.shape[e];for(let t=r;t<i;t++)o.push(e.shape[t]);for(let e=n+1;e<s;e++)o.push(t.shape[e]),c*=t.shape[e];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:o}}function Ck(t){try{return t.map((t=>Ey(t)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Ek(t){return t.map((t=>Cy(t)))}function Ak(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const r=sb(t,"int32"),i=sb([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const s=r.indexToLoc(n[e]),a=e*t.length;i.values.set(s,a)}return i.toTensor()}const Nk={kernelName:Yf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(t,d_(ab(n,"float32"),-1))}}},Rk={kernelName:Zf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=vS(ab(n,"float32")),r=qS(eS(Xb(1),e));return wS(zw(t,r))}}}},Dk={kernelName:Jf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=qS(eS(vS(ab(n,"float32")),1));return zw(t,e)}}}},Lk={kernelName:Qf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=xb(n.shape,r.shape);return{a:()=>{let e=t;const r=gb(n.shape,i);return r.length>0&&(e=nS(e,r)),mw(e,n.shape)},b:()=>{let e=t;const n=gb(r.shape,i);return n.length>0&&(e=nS(e,n)),mw(e,r.shape)}}}},Fk={kernelName:tm,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}},$k={kernelName:rm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>e_(n)}}},Pk={kernelName:im,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>e_(n)}}},Ok={kernelName:sm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zw(t,qS(eS(Xb(1),vS(ab(n,"float32")))))}}},zk={kernelName:am,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=qS(Zb(Xb(1),vS(ab(n,"float32"))));return zw(t,e)}}}},Bk={kernelName:um,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=xb(n.shape,r.shape);return{a:()=>{const e=Zb(vS(n),vS(r));let s=tS(t,zw(r,e));const a=gb(n.shape,i);return a.length>0&&(s=nS(s,a)),mw(s,n.shape)},b:()=>{const e=Zb(vS(n),vS(r));let s=wS(tS(t,zw(n,e)));const a=gb(r.shape,i);return a.length>0&&(s=nS(s,a)),mw(s,r.shape)}}}},Uk={kernelName:om,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zw(t,Zb(vS(ab(n,"float32")),1))}}},Wk={kernelName:lm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zw(t,eS(Xb(1),vS(ab(n,"float32"))))}}},Vk=Sv({avgPool3dGrad_:function(t,e,n,r,i,s){const a=vv(t,"dy","avgPool3dGrad"),o=vv(e,"input","avgPool3dGrad");let l=a,u=o,c=!1;4===o.rank&&(c=!0,l=mw(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=mw(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),uf(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),uf(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),fw("avgPool3dGrad",i,s);const h={dy:l,input:u},d={filterSize:n,strides:r,pad:i,dimRoundingMode:s},p=cv.runKernel(pm,h,d);return c?mw(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Gk={kernelName:dm,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:i,strides:s,pad:a,dimRoundingMode:o}=n;return{x:()=>Vk(t,r,i,s,a,o)}}},Hk=Sv({avgPoolGrad_:function(t,e,n,r,i){const s=vv(t,"dy","avgPoolGrad"),a=vv(e,"input","avgPoolGrad");uf(a.rank===s.rank,(()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`));let o=a,l=s,u=!1;3===a.rank&&(u=!0,o=mw(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=mw(s,[1,s.shape[0],s.shape[1],s.shape[2]])),uf(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),uf(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},h={filterSize:n,strides:r,pad:i},d=cv.runKernel(hm,c,h);return u?mw(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),jk={kernelName:cm,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:i,strides:s,pad:a}=n;return{x:()=>Hk(t,r,i,s,a)}}},qk={kernelName:fm,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,i]=e,{transposeA:s,transposeB:a}=n;return s||a?!s&&a?{a:()=>sS(t,i,!1,!1),b:()=>sS(t,r,!0,!1)}:s&&!a?{a:()=>sS(i,t,!1,!0),b:()=>sS(r,t,!1,!1)}:{a:()=>sS(i,t,!0,!0),b:()=>sS(t,r,!0,!0)}:{a:()=>sS(t,i,!1,!0),b:()=>sS(r,t,!0,!1)}}},Xk=Sv({spaceToBatchND_:function(t,e,n){const r=vv(t,"x","spaceToBatchND");uf(r.rank>=1+e.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`)),uf(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),uf(r.shape.reduce(((t,r,i)=>i>0&&i<=e.length?t&&(r+n[i-1][0]+n[i-1][1])%e[i-1]==0:t),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const i={x:r},s={blockShape:e,paddings:n};return cv.runKernel(kx,i,s)}}),Kk={kernelName:mm,gradFunc:(t,e,n)=>{const{blockShape:r,crops:i}=n;return{x:()=>Xk(t,r,i)}}},Yk={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,i=r.inputShape,s=r.shape,a=Array.from(s);for(let t=i.length-1;t>=0;t--)if(i[t]===s[t])a[t]=1;else if(1!==i[t])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${s}].`);const o=[];for(let t=0;t<a.length;t++)a[t]>1&&o.push(t);return{x:()=>nS(t,o,!0)}}},Zk={kernelName:ym,gradFunc:t=>({x:()=>t.clone()})},Jk={kernelName:vm,gradFunc:t=>({x:()=>e_(t)})},Qk={kernelName:bm,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:i,clipValueMax:s}=n;return{x:()=>t_(iS(Kw(r,i),H_(r,s)),t,e_(t))}}},tM={kernelName:Sm,inputsToSave:["x"],gradFunc:Nk.gradFunc},eM={kernelName:_m,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:i}=n,s=bf(i,e[0].shape)[0],a=r.map((t=>t[s]));return jS(t,a,s).map((t=>()=>t))}},nM={kernelName:Im,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,{dilations:s,strides:a,pad:o,dataFormat:l}=n;return uf(hw(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>Rw(r.shape,t,i,a,o,l),filter:()=>c_(r,t,i.shape,a,o,l)}}},rM={kernelName:Mm,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,{strides:s,pad:a,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Aw(t,i,s,a,o,1,l),filter:()=>c_(t,r,i.shape,s,a,o,l)}}},iM=Sv({conv3DBackpropFilter_:function(t,e,n,r,i){let s=t;4===t.rank&&(s=mw(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let a=e;4===a.rank&&(a=mw(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),uf(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),uf(5===a.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`)),uf(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),uf(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),uf(a.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:s,dy:a},l={strides:r,pad:i,filterShape:n};return cv.runKernel(Cm,o,l)}}),sM={kernelName:Tm,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:i,pad:s}=n;uf(hw(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[a,o]=e;return{x:()=>Fw(a.shape,t,o,i,s),filter:()=>iM(a,t,o.shape,i,s)}}},aM=Sv({sin_:function(t){const e={x:vv(t,"x","sin","float32")};return cv.runKernel(yx,e)}}),oM={kernelName:Am,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(wS(aM(ab(n,"float32"))),t)}}},lM=Sv({sinh_:function(t){const e={x:vv(t,"x","sinh")};return cv.runKernel(vx,e)}}),uM={kernelName:Nm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(lM(ab(n,"float32")),t)}}},cM=Sv({cumsum_:function(t,e=0,n=!1,r=!1){const i={x:vv(t,"x","cumsum")},s={axis:e,exclusive:n,reverse:r};return cv.runKernel(Dm,i,s)}}),hM={kernelName:Dm,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:i,exclusive:s,reverse:a}=n;return{x:()=>{const e=gS([i],r.rank);let n=cM(t,i,s,!a);return null!=e&&(n=i_(n,e)),n}}}},dM={kernelName:Pm,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:i,pad:s,dimRoundingMode:a}=n,o=null==r?[1,1]:r;uf(hw(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=e;return uf(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),uf(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),uf(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),uf(dw(i,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`)),fw("depthwiseConv2d",s,a),{x:()=>v_(l.shape,t,u,i,s,o,a),filter:()=>y_(l,t,u.shape,i,s,o,a)}}},pM={kernelName:Um,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,i]=e,s={x:r,filter:i,dy:t},a={x:r,filter:i,dy:t};return{x:()=>cv.runKernel(Wm,s,n),filter:()=>cv.runKernel(Vm,a,n)}}},fM={kernelName:jm,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>cv.runKernel(qm,r)}}},mM={kernelName:Xm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=tS(Ww(wS(vS(n))),2/Math.sqrt(Math.PI));return{x:()=>tS(t,r)}}},gM={kernelName:Ym,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(t,n)}}},xM={kernelName:Zm,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>mw(t,n.shape)}}},yM={kernelName:Jm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(t,Ww(n))}}},vM={kernelName:ng,gradFunc:t=>({x:()=>e_(t)})},bM={kernelName:rg,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=xb(n.shape,r.shape);return{a:()=>{const e=zw(t,ab(r,"float32")),s=gb(n.shape,i);return s.length>0?mw(nS(e,s),n.shape):e},b:()=>{let e=tS(t,ab(n,"float32"));const s=gb(r.shape,i);s.length>0&&(e=mw(nS(e,s),r.shape));const a=vS(r);return wS(zw(e,ab(a,"float32")))}}}},wM=Sv({rsqrt_:function(t){const e={x:vv(t,"x","rsqrt","float32")};return cv.runKernel(dx,e)}}),SM={kernelName:ig,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[i,s,a,o]=e,l=null==o?Xb(1):o,u=gb(s.shape,i.shape),c=[];if(1===s.rank){for(let t=0;t<i.shape.length-1;++t)c.push(i.shape[t]);c.push(1)}const h=eS(i,s),d=tS(t,l),p=wM(Zb(a,Xb(r))),f=tS(tS(tS(p,p),p),Xb(-.5));return{x:()=>1===s.rank?mw(tS(tS(t,Gw(mw(p,[1,1,1,s.shape[0]]),c)),l),i.shape):mw(tS(tS(t,p),l),i.shape),mean:()=>{let t=tS(tS(p,Xb(-1)),d);return 1===s.rank&&(t=nS(t,u)),mw(t,s.shape)},variance:()=>{let t=tS(tS(f,h),d);return 1===s.rank&&(t=nS(t,u)),mw(t,s.shape)},scale:()=>{const e=tS(h,p);let n=tS(t,e);return 1===s.rank&&(n=nS(n,u)),mw(n,s.shape)},offset:()=>{let e=t;return 1===s.rank&&(e=nS(e,u)),mw(e,s.shape)}}}},_M=Sv({unsortedSegmentSum_:function(t,e,n){const r=vv(t,"x","unsortedSegmentSum"),i=vv(e,"segmentIds","unsortedSegmentSum","int32");uf(mf(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:i},a={numSegments:n};return cv.runKernel(Xx,s,a)}}),IM={kernelName:sg,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,i]=e,{axis:s}=n,a=bf(s,r.shape)[0];return{x:()=>{const e=r.shape,n=i.size,o=e.slice(0,a),l=o.length,u=e.slice(s,e.length).slice(1),c=u.length,h=kM(0,l),d=kM(l+1,l+1+c),p=MM([o,[n],u]),f=mw(t,p),m=mw(i,[n]),g=MM([[l],h,d]),x=i_(f,g);let y=_M(x,m,r.shape[a]);const v=xS(g);return y=i_(y,v),y},indices:()=>i}}};function kM(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function MM(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const TM={kernelName:lg,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>e_(n),b:()=>e_(r)}}},CM={kernelName:ug,gradFunc:t=>({x:()=>ab(t,"float32")})},EM={kernelName:dg,gradFunc:t=>({x:()=>e_(t)})},AM={kernelName:pg,gradFunc:t=>({x:()=>e_(t)})},NM={kernelName:fg,gradFunc:t=>({x:()=>e_(t)})},RM={kernelName:mg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:i}=n,s=Xw(r,0);return{x:()=>t_(s,t,tS(t,i))}}},DM={kernelName:bg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zw(t,Zb(n,1))}}},LM={kernelName:vg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zw(t,ab(n,"float32"))}}},FM={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:i}=n;return{logits:()=>{const e=Ww(r);return eS(t,tS(nS(t,i,!0),e))}}}},$M=Sv({localResponseNormalizationBackprop_:function(t,e,n,r=5,i=1,s=1,a=.5){const o={x:t,y:e,dy:n},l={depthRadius:r,bias:i,alpha:s,beta:a};return cv.runKernel(kg,o,l)}}),PM={kernelName:Ig,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{depthRadius:s,bias:a,alpha:o,beta:l}=n;return{x:()=>$M(r,i,t,s,a,o,l)}}};function OM(t,e,n,r){return e.rank<n.rank&&(e=mw(e,fS(e.shape,r))),t.rank<n.rank&&(t=mw(t,fS(t.shape,r))),{x:()=>tS(t,ab(Uw(n,e),t.dtype))}}const zM={kernelName:Mg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:i}=r,s=e[0],a=OM(t,e[1],s,bf(i,s.shape));return{x:()=>a.x()}}},BM=Sv({less_:function(t,e){let n=vv(t,"a","less","string_or_numeric"),r=vv(e,"b","less","string_or_numeric");[n,r]=nv(n,r),xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(gg,i)}}),UM={kernelName:Tg,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>tS(t,ab(Kw(n,r),"float32")),b:()=>tS(t,ab(BM(n,r),"float32"))}}},WM=Sv({maxPool3dGrad_:function(t,e,n,r,i,s,a){const o=vv(t,"dy","maxPool3dGrad"),l=vv(e,"input","maxPool3dGrad"),u=vv(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=mw(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=mw(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=mw(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),uf(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),uf(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),uf(5===d.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`)),fw("maxPool3dGrad",s,a);const f={dy:c,input:h,output:d},m={filterSize:r,strides:i,pad:s,dimRoundingMode:a},g=cv.runKernel(Ng,f,m);return p?mw(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),VM={kernelName:Ag,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=n;return{x:()=>WM(t,r,i,s,a,o,l)}}},GM=Sv({maxPoolGrad_:function(t,e,n,r,i,s,a){const o=vv(t,"dy","maxPoolGrad"),l=vv(e,"input","maxPoolGrad"),u=vv(n,"output","maxPoolGrad");uf(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),uf(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),uf(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),fw("maxPoolGrad",s,a);const c={dy:o,input:l,output:u},h={filterSize:r,strides:i,pad:s,dimRoundingMode:a};return cv.runKernel(Eg,c,h)}}),HM={kernelName:Cg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,i]=e,{filterSize:s,strides:a,pad:o}=n;return{x:()=>GM(t,r,i,s,a,o)}}},jM={kernelName:Dg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:i}=n,s=bf(i,r.shape),a=pf(pS(r.shape,s)[1]);return{x:()=>{const e=r.shape.slice();s.forEach((t=>{e[t]=1}));const n=mw(t,e);return zw(tS(n,kS(r.shape,"float32")),a)}}}},qM={kernelName:Lg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:i}=r,[s,a]=e,o=OM(t,a,s,bf(i,s.shape));return{x:()=>o.x()}}},XM={kernelName:Fg,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>tS(t,ab(H_(n,r),"float32")),b:()=>tS(t,ab(Xw(n,r),"float32"))}}},KM={kernelName:$g,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:i}=n,s=i.map((t=>t[0]));return{x:()=>zS(t,s,r.shape)}}},YM={kernelName:Pg,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=xb(n.shape,r.shape);return{a:()=>{const e=gb(n.shape,i);return e.length>0?mw(nS(t,e),n.shape):t},b:()=>{const e=tS(t,wS(jw(zw(n,r)))),s=gb(r.shape,i);return s.length>0?mw(nS(e,s),r.shape):e}}}},ZM={kernelName:zg,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=xb(n.shape,r.shape);return{a:()=>{const e=tS(t,ab(r,"float32")),s=gb(n.shape,i);return s.length>0?mw(nS(e,s),n.shape):e},b:()=>{const e=tS(t,ab(n,"float32")),s=gb(r.shape,i);return s.length>0?mw(nS(e,s),r.shape):e}}}},JM={kernelName:Bg,gradFunc:t=>({x:()=>wS(t)})},QM={kernelName:jg,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>IS(n.shape,"float32")}}},tT={kernelName:Hg,gradFunc:t=>({x:()=>e_(t)})},eT={kernelName:qg,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return QS(t,r).map((t=>()=>t))}},nT={kernelName:Xg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:i}=n,s=i.map((t=>t[0]));return{x:()=>zS(t,s,r.shape)}}},rT={kernelName:Kg,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,i]=e,s=n,a=r,o=xb(s.shape,a.shape);return{a:()=>{const e=ab(a,"float32");let n=tS(t,tS(e,J_(s,eS(e,Xb(1)))));const r=gb(s.shape,o);return r.length>0&&(n=nS(n,r)),mw(n,s.shape)},b:()=>{const e=Xw(s,0),n=t_(e,Zw(s),e_(s));let r=tS(t,tS(i,n));const l=gb(a.shape,o);return l.length>0&&(r=nS(r,l)),mw(r,a.shape)}}}},iT={kernelName:Yg,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,i=Xw(n,0);return{x:()=>t_(i,t,tS(t,r)),alpha:()=>{let e=t_(i,e_(t),tS(t,n));const s=gb(r.shape,t.shape);return s.length>0&&(e=nS(e,s)),mw(e,r.shape)}}}},sT=Sv({cumprod_:function(t,e=0,n=!1,r=!1){const i={x:vv(t,"x","cumprod")},s={axis:e,exclusive:n,reverse:r};return cv.runKernel(Rm,i,s)}});const aT={kernelName:Zg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:i}=n;let s=[];return s=null==i?r.shape.map(((t,e)=>e)):"number"==typeof i?[i]:i,{x:()=>function(t,e,n){const r=t.shape.length,i=r-n.length,s=gS(n,r);let a=t;null!=s&&(a=i_(t,s));const o=a.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((t,e)=>t*e),1);o.push(l);let u=function(t,e,n){const r=t.shape.slice();r[n]=1;const i=mw(e,r),s=sT(t,n,!0,!1),a=sT(t,n,!0,!0),o=tS(s,a);return tS(i,o)}(a.reshape(o),e,i);if(u=u.reshape(a.shape),null!=s){const t=xS(s);u=i_(u,t)}return u}(r,t,s)}}},oT={kernelName:Gm,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=xb(n.shape,r.shape);return{a:()=>{const e=zw(t,ab(r,"float32")),s=gb(n.shape,i);return s.length>0?mw(nS(e,s),n.shape):e},b:()=>{let e=tS(t,ab(n,"float32"));const s=gb(r.shape,i);s.length>0&&(e=mw(nS(e,s),r.shape));const a=vS(r);return wS(zw(e,ab(a,"float32")))}}}},lT={kernelName:nx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zw(t,wS(vS(n)))}}},uT={kernelName:ux,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=tS(H_(n,6),d_(n));return{x:()=>tS(t,ab(r,"float32"))}}},cT={kernelName:rx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(t,ab(d_(n),"float32"))}}},hT={kernelName:ix,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>mw(t,n.shape)}}},dT={kernelName:ox,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,i={dy:t,images:r};return{images:()=>cv.runKernel(lx,i,n)}}},pT={kernelName:sx,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,i={dy:t,images:r};return{images:()=>cv.runKernel(ax,i,n)}}},fT={kernelName:cx,gradFunc:(t,e,n)=>{const{dims:r}=n,i=bf(r,t.shape);return{x:()=>FS(t,i)}}},mT={kernelName:hx,gradFunc:t=>({x:()=>e_(t)})},gT={kernelName:dx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>wS(zw(t,tS(J_(n,1.5),2)))}}},xT=Sv({logicalNot_:function(t){const e={x:vv(t,"x","logicalNot","bool")};return cv.runKernel(Sg,e)}}),yT={kernelName:mx,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>ab(e_(n),"float32"),t:()=>tS(t,ab(n,t.dtype)),e:()=>tS(t,ab(xT(n),t.dtype))}}},vT={kernelName:gx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=Xw(n,Xb(0)),r=Xb(BI),i=Xb(UI),s=tS(t,i),a=tS(tS(t,r),Ww(ab(n,"float32")));return t_(e,s,a)}}}},bT={kernelName:wx,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(t,tS(n,eS(Xb(1),n)))}}},wT={kernelName:bx,gradFunc:t=>({x:()=>e_(t)})},ST=Sv({cos_:function(t){const e={x:vv(t,"x","cos","float32")};return cv.runKernel(Am,e)}}),_T={kernelName:yx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(ST(ab(n,"float32")),t)}}},IT=Sv({cosh_:function(t){const e={x:vv(t,"x","cosh","float32")};return cv.runKernel(Nm,e)}}),kT={kernelName:vx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(IT(ab(n,"float32")),t)}}},MT={kernelName:xx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:i,size:s}=n,a=r.shape,[o,l]=Lb(r,i,s),u=[];for(let e=0;e<t.rank;e++)u.push([o[e],a[e]-o[e]-l[e]]);return{x:()=>TS(t,u)}}},TT={kernelName:Tx,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:i}=n,s=tS(t,r);return{logits:()=>eS(s,tS(nS(s,[i],!0),r))}}},CT={kernelName:Sx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(t,OS(n))}}},ET=Sv({batchToSpaceND_:function(t,e,n){const r=vv(t,"x","batchToSpaceND"),i=e.reduce(((t,e)=>t*e));uf(r.rank>=1+e.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`)),uf(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),uf(r.shape[0]%i==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`));const s={x:r},a={blockShape:e,crops:n};return cv.runKernel(mm,s,a)}}),AT={kernelName:kx,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:i}=n;return{x:()=>ET(t,r,i)}}},NT={kernelName:Mx,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>kw(t,r)}}},RT=[Nk,Rk,Dk,Lk,Fk,$k,Pk,Ok,zk,Bk,Uk,Wk,Gk,jk,qk,Kk,Yk,Zk,Jk,Qk,tM,eM,rM,nM,sM,oM,uM,hM,dM,pM,oT,fM,mM,gM,xM,yM,bM,vM,SM,IM,TM,CM,EM,AM,NM,RM,DM,LM,FM,PM,zM,zM,UM,VM,HM,jM,qM,XM,KM,YM,ZM,JM,QM,tT,eT,nT,nT,rT,iT,aT,lT,uT,cT,hT,dT,pT,fT,mT,gT,yT,vT,bT,wT,_T,kT,MT,TT,CT,AT,AT,NT,NT,{kernelName:_x,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zw(t,tS(qS(ab(n,"float32")),2))}}},{kernelName:Dx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=Xb(2);return{a:()=>tS(t,tS(i,eS(n,r))),b:()=>tS(t,tS(i,eS(r,n)))}}},{kernelName:Lx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(t,tS(ab(n,"float32"),2))}}},{kernelName:Yx,gradFunc:t=>({x:()=>e_(t)})},{kernelName:zx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,i=xb(n.shape,r.shape);return{a:()=>{let e=t;const r=gb(n.shape,i);return r.length>0&&(e=nS(e,r)),mw(e,n.shape)},b:()=>{let e=t;const n=gb(r.shape,i);return n.length>0&&(e=nS(e,n)),mw(wS(e),r.shape)}}}},{kernelName:Ix,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,i=r.shape.slice(),{axis:s}=n;bf(s,r.shape).forEach((t=>{i[t]=1}));const a=mw(t,i),o=tS(a,kS(r.shape,"float32"));return{x:()=>o}}},{kernelName:Bx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zw(t,vS(ST(n)))}}},{kernelName:Ux,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>tS(eS(Xb(1),vS(n)),t)}}},{kernelName:Wx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:i}=n;return{x:()=>{let e=e_(r);if(1===r.rank)for(let n=0;n<i[0];++n)e=Zb(e,zS(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<i[0];++n)for(let s=0;s<i[1];++s)e=Zb(e,zS(t,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<i[0];++n)for(let s=0;s<i[1];++s)for(let a=0;a<i[2];++a)e=Zb(e,zS(t,[n*r.shape[0],s*r.shape[1],a*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<i[0];++n)for(let s=0;s<i[1];++s)for(let a=0;a<i[2];++a)for(let o=0;o<i[3];++o)e=Zb(e,zS(t,[n*r.shape[0],s*r.shape[1],a*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:Hx,gradFunc:(t,e,n)=>{const r=n,{perm:i}=r,s=xS(i);return{x:()=>i_(t,s)}}},{kernelName:qx,gradFunc:(t,e,n)=>{const r=n,{axis:i}=r;return{value:()=>KS(t,i)}}},{kernelName:Xx,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=lS(e,e_(e)),r=qw(t,n);let i=Kw(e,Xb(0,"int32"));const s=r.rank-i.rank;for(let t=0;t<s;++t)i=Vw(i,t+1);i=iS(i,kS(r.shape,"bool"));const a=e_(r);return t_(i,r,a)}(t,n)}}},{kernelName:Kx,gradFunc:t=>({x:()=>e_(t)})}];for(const t of RT)uy(t);jy().prototype.abs=function(){return this.throwIfDisposed(),Yb(this)};const DT=Sv({acos_:function(t){const e={x:vv(t,"x","acos")};return cv.runKernel(Zf,e)}});jy().prototype.acos=function(){return this.throwIfDisposed(),DT(this)};const LT=Sv({acosh_:function(t){const e={x:vv(t,"x","acosh")};return cv.runKernel(Jf,e)}});jy().prototype.acosh=function(){return this.throwIfDisposed(),LT(this)},jy().prototype.add=function(t){return this.throwIfDisposed(),Zb(this,t)},jy().prototype.all=function(t,e){return this.throwIfDisposed(),Jb(this,t,e)},jy().prototype.any=function(t,e){return this.throwIfDisposed(),Qb(this,t,e)},jy().prototype.argMax=function(t){return this.throwIfDisposed(),tw(this,t)};const FT=Sv({argMin_:function(t,e=0){const n={x:vv(t,"x","argMin")},r={axis:e};return cv.runKernel(im,n,r)}});jy().prototype.argMin=function(t){return this.throwIfDisposed(),FT(this,t)},jy().prototype.asScalar=function(){return this.throwIfDisposed(),uf(1===this.size,(()=>"The array must have only 1 element.")),mw(this,[])},jy().prototype.asType=function(t){return this.throwIfDisposed(),ab(this,t)},jy().prototype.as1D=function(){return this.throwIfDisposed(),mw(this,[this.size])},jy().prototype.as2D=function(t,e){return this.throwIfDisposed(),mw(this,[t,e])},jy().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),mw(this,[t,e,n])},jy().prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),mw(this,[t,e,n,r])},jy().prototype.as5D=function(t,e,n,r,i){return this.throwIfDisposed(),mw(this,[t,e,n,r,i])};const $T=Sv({asin_:function(t){const e={x:vv(t,"x","asin")};return cv.runKernel(sm,e)}});jy().prototype.asin=function(){return this.throwIfDisposed(),$T(this)};const PT=Sv({asinh_:function(t){const e={x:vv(t,"x","asinh")};return cv.runKernel(am,e)}});jy().prototype.asinh=function(){return this.throwIfDisposed(),PT(this)};const OT=Sv({atan_:function(t){const e={x:vv(t,"x","atan")};return cv.runKernel(om,e)}});jy().prototype.atan=function(){return this.throwIfDisposed(),OT(this)};const zT=Sv({atan2_:function(t,e){let n=vv(t,"a","atan2"),r=vv(e,"b","atan2");[n,r]=nv(n,r);const i={a:n,b:r};return cv.runKernel(um,i)}});jy().prototype.atan2=function(t){return this.throwIfDisposed(),zT(this,t)};const BT=Sv({atanh_:function(t){const e={x:vv(t,"x","atanh")};return cv.runKernel(lm,e)}});jy().prototype.atanh=function(){return this.throwIfDisposed(),BT(this)},jy().prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),gw(this,t,e,n,r)},jy().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),ET(this,t,e)},jy().prototype.batchNorm=function(t,e,n,r,i){return this.throwIfDisposed(),yw(this,t,e,n,r,i)},jy().prototype.broadcastTo=function(t){return this.throwIfDisposed(),Sw(this,t)},jy().prototype.cast=function(t){return this.throwIfDisposed(),ab(this,t)};const UT=Sv({ceil_:function(t){const e={x:vv(t,"x","ceil","float32")};return cv.runKernel(vm,e)}});jy().prototype.ceil=function(){return this.throwIfDisposed(),UT(this)},jy().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Iw(this,t,e)},jy().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof Hy&&(t=[t]),kw([this,...t],e)},jy().prototype.conv1d=function(t,e,n,r,i,s){return this.throwIfDisposed(),Nw(this,t,e,n,r,i,s)},jy().prototype.conv2dTranspose=function(t,e,n,r,i){return this.throwIfDisposed(),Dw(this,t,e,n,r,i)},jy().prototype.conv2d=function(t,e,n,r,i,s){return this.throwIfDisposed(),Aw(this,t,e,n,r,i,s)},jy().prototype.cos=function(){return this.throwIfDisposed(),ST(this)},jy().prototype.cosh=function(){return this.throwIfDisposed(),IT(this)},jy().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),sT(this,t,e,n)},jy().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),cM(this,t,e,n)};const WT=Sv({depthToSpace_:function(t,e,n="NHWC"){const r=vv(t,"x","depthToSpace","float32"),i="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],a="NHWC"===n?r.shape[3]:r.shape[1];uf(e>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`)),uf(i*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e}  for depthToSpace with input shape\n    ${r.shape}`)),uf(s*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${e} for depthToSpace with input shape\n        ${r.shape}`)),uf(a%(e*e)==0,(()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:e,dataFormat:n};return cv.runKernel($m,o,l)}});jy().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),WT(this,t,e)},jy().prototype.depthwiseConv2d=function(t,e,n,r,i,s){return this.throwIfDisposed(),Pw(this,t,e,n,r,i,s)};const VT=Sv({dilation2d_:function(t,e,n,r,i=[1,1],s="NHWC"){const a=vv(t,"x","dilation2d"),o=vv(e,"filter","dilation2d");uf(3===a.rank||4===a.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`)),uf(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),uf("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=a,u=!1;3===a.rank&&(l=mw(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);const c={x:l,filter:o},h={strides:n,pad:r,dilations:i},d=cv.runKernel(Um,c,h);return u?mw(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});jy().prototype.dilation2d=function(t,e,n,r,i){return this.throwIfDisposed(),VT(this,t,e,n,r,i)};const GT=Sv({divNoNan_:function(t,e){let n=vv(t,"a","div"),r=vv(e,"b","div");[n,r]=nv(n,r);const i=zw(n,r),s=e_(i),a=Uw(r,s);return t_(a,s,i)}});jy().prototype.divNoNan=function(t){return this.throwIfDisposed(),GT(this,t)},jy().prototype.div=function(t){return this.throwIfDisposed(),zw(this,t)};const HT=Sv({dot_:function(t,e){const n=vv(t,"t1","dot"),r=vv(e,"t2","dot");uf(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const i=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(uf(i===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${s}.`)),1===n.rank&&1===r.rank){const t=mw(n,[1,-1]),e=mw(r,[-1,1]),i=sS(t,e);return mw(i,[])}if(1===n.rank&&2===r.rank){const t=mw(n,[1,-1]),e=mw(r,[r.shape[0],r.shape[1]]),i=sS(t,e);return mw(i,[i.size])}if(2===n.rank&&1===r.rank){const t=mw(r,[-1,1]),e=sS(n,t);return mw(e,[e.size])}{const t=mw(r,[r.shape[0],r.shape[1]]);return sS(n,t)}}});jy().prototype.dot=function(t){return this.throwIfDisposed(),HT(this,t)},jy().prototype.elu=function(){return this.throwIfDisposed(),Bw(this)},jy().prototype.equal=function(t){return this.throwIfDisposed(),Uw(this,t)};const jT=Sv({erf_:function(t){let e=vv(t,"x","erf");uf("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=ab(e,"float32"));const n={x:e};return cv.runKernel(Xm,n)}});jy().prototype.erf=function(){return this.throwIfDisposed(),jT(this)};const qT=Sv({euclideanNorm_:function(t,e=null,n=!1){return tI(t,"euclidean",e,n)}});jy().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),qT(this,t,e)},jy().prototype.exp=function(){return this.throwIfDisposed(),Ww(this)},jy().prototype.expandDims=function(t){return this.throwIfDisposed(),Vw(this,t)};const XT=Sv({expm1_:function(t){const e={x:vv(t,"x","expm1")};return cv.runKernel(Jm,e)}});jy().prototype.expm1=function(){return this.throwIfDisposed(),XT(this)},jy().prototype.fft=function(){return this.throwIfDisposed(),a_(this)},jy().prototype.flatten=function(){return this.throwIfDisposed(),mw(this,[this.size])},jy().prototype.floor=function(){return this.throwIfDisposed(),jw(this)},jy().prototype.floorDiv=function(t){return this.throwIfDisposed(),Ow(this,t)},jy().prototype.gather=function(t,e){return this.throwIfDisposed(),qw(this,t,e)},jy().prototype.greaterEqual=function(t){return this.throwIfDisposed(),Kw(this,t)},jy().prototype.greater=function(t){return this.throwIfDisposed(),Xw(this,t)},jy().prototype.ifft=function(){return this.throwIfDisposed(),l_(this)},jy().prototype.irfft=function(){return this.throwIfDisposed(),u_(this)};const KT=Sv({isFinite_:function(t){const e={x:vv(t,"x","isFinite")};return cv.runKernel(dg,e)}});jy().prototype.isFinite=function(){return this.throwIfDisposed(),KT(this)};const YT=Sv({isInf_:function(t){const e={x:vv(t,"x","isInf")};return cv.runKernel(pg,e)}});jy().prototype.isInf=function(){return this.throwIfDisposed(),YT(this)};const ZT=Sv({isNaN_:function(t){const e={x:vv(t,"x","isNaN")};return cv.runKernel(fg,e)}});jy().prototype.isNaN=function(){return this.throwIfDisposed(),ZT(this)},jy().prototype.leakyRelu=function(t){return this.throwIfDisposed(),Yw(this,t)},jy().prototype.lessEqual=function(t){return this.throwIfDisposed(),H_(this,t)},jy().prototype.less=function(t){return this.throwIfDisposed(),BM(this,t)};const JT=Sv({localResponseNormalization_:function(t,e=5,n=1,r=1,i=.5){const s=vv(t,"x","localResponseNormalization");uf(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),uf(mf(e),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`));let a=s,o=!1;3===s.rank&&(o=!0,a=mw(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:a},u={depthRadius:e,bias:n,alpha:r,beta:i},c=cv.runKernel(Ig,l,u);return o?mw(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});jy().prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),JT(this,t,e,n,r)};const QT=Sv({logSigmoid_:function(t){const e=vv(t,"x","logSigmoid");return qb((t=>({value:wS(HS(wS(t))),gradFunc:e=>tS(e,OS(wS(t)))})))(e)}});jy().prototype.logSigmoid=function(){return this.throwIfDisposed(),QT(this)},jy().prototype.logSoftmax=function(t){return this.throwIfDisposed(),rS(this,t)},jy().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),oI(this,t,e)},jy().prototype.log=function(){return this.throwIfDisposed(),Zw(this)},jy().prototype.log1p=function(){return this.throwIfDisposed(),Jw(this)},jy().prototype.logicalAnd=function(t){return this.throwIfDisposed(),iS(this,t)},jy().prototype.logicalNot=function(){return this.throwIfDisposed(),xT(this)};const tC=Sv({logicalOr_:function(t,e){const n=vv(t,"a","logicalOr","bool"),r=vv(e,"b","logicalOr","bool");xb(n.shape,r.shape);const i={a:n,b:r};return cv.runKernel(_g,i)}});jy().prototype.logicalOr=function(t){return this.throwIfDisposed(),tC(this,t)};const eC=Sv({logicalXor_:function(t,e){const n=vv(t,"a","logicalXor","bool"),r=vv(e,"b","logicalXor","bool");return xb(n.shape,r.shape),iS(tC(t,e),xT(iS(t,e)))}});jy().prototype.logicalXor=function(t){return this.throwIfDisposed(),eC(this,t)},jy().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),sS(this,t,e,n)},jy().prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),aS(this,t,e,n,r)},jy().prototype.max=function(t,e){return this.throwIfDisposed(),Qw(this,t,e)},jy().prototype.maximum=function(t){return this.throwIfDisposed(),lS(this,t)},jy().prototype.mean=function(t,e){return this.throwIfDisposed(),uS(this,t,e)},jy().prototype.min=function(t,e){return this.throwIfDisposed(),Z_(this,t,e)},jy().prototype.minimum=function(t){return this.throwIfDisposed(),cS(this,t)};const nC=Sv({mirrorPad_:function(t,e,n){uf("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=vv(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");uf(e.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`));const i="reflect"===n?1:0;for(let t=0;t<r.rank;t++)uf(2===e[t].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),uf(e[t][0]>=0&&e[t][0]<=r.shape[t]-i&&e[t][1]>=0&&e[t][1]<=r.shape[t]-i,(()=>`Padding in dimension ${t} cannot be greater than or equal to ${r.shape[t]-i} or less than 0 for input of shape ${r.shape}`));const s={paddings:e,mode:n},a={x:r};return cv.runKernel($g,a,s)}});jy().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),nC(this,t,e)};const rC=Sv({mod_:function(t,e){let n=vv(t,"a","mod"),r=vv(e,"b","mod");[n,r]=nv(n,r);const i={a:n,b:r};return cv.runKernel(Pg,i)}});jy().prototype.mod=function(t){return this.throwIfDisposed(),rC(this,t)},jy().prototype.mul=function(t){return this.throwIfDisposed(),tS(this,t)},jy().prototype.neg=function(){return this.throwIfDisposed(),wS(this)},jy().prototype.norm=function(t,e,n){return this.throwIfDisposed(),tI(this,t,e,n)},jy().prototype.notEqual=function(t){return this.throwIfDisposed(),SS(this,t)},jy().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),_S(this,t,e,n)},jy().prototype.onesLike=function(){return this.throwIfDisposed(),MS(this)},jy().prototype.pad=function(t,e){return this.throwIfDisposed(),TS(this,t,e)};const iC=Sv({pool_:function(t,e,n,r,i,s,a){null==i&&(i=[1,1]),null==s&&(s=1),0===r&&(r="valid");const o=vv(t,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=mw(o,[1,o.shape[0],o.shape[1],o.shape[2]])),uf(dw(s,i),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`));const c=nw(l.shape,e,s,i,r),h=[c.dilationHeight,c.dilationWidth];let d;d="same"===r?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))).map((t=>t-1)),r=n.map((t=>Math.floor(t/2))),i=n.map(((t,e)=>t-r[e]));return n.map(((t,e)=>[r[e],i[e]]))}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(t,e,n){const r=n.map((t=>t[0])),i=n.map((t=>t[1])),s=t.concat(r,i),a=e.map(((t,e)=>(t-s[e]%t)%t)),o=i.map(((t,e)=>t+a[e]));return[e.map(((t,e)=>[r[e],o[e]])),e.map(((t,e)=>[0,a[e]]))]}([c.inHeight,c.inWidth],h,d),g=p?r:"valid",x=p?l:Xk(l,h,f),y=("avg"===n?()=>gw(x,e,s,g,a):()=>aS(x,e,s,g,a))(),v=p?y:ET(y,h,m);return u?mw(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});jy().prototype.pool=function(t,e,n,r,i,s){return this.throwIfDisposed(),iC(this,t,e,n,r,i,s)},jy().prototype.pow=function(t){return this.throwIfDisposed(),J_(this,t)},jy().prototype.prelu=function(t){return this.throwIfDisposed(),CS(this,t)};const sC=Sv({prod_:function(t,e=null,n=!1){let r=vv(t,"x","prod");"bool"===r.dtype&&(r=ab(r,"int32"));const i={x:r},s={axis:e,keepDims:n};return cv.runKernel(Zg,i,s)}});jy().prototype.prod=function(t,e){return this.throwIfDisposed(),sC(this,t,e)};const aC=Sv({reciprocal_:function(t){const e={x:vv(t,"x","reciprocal")};return cv.runKernel(nx,e)}});jy().prototype.reciprocal=function(){return this.throwIfDisposed(),aC(this)},jy().prototype.relu=function(){return this.throwIfDisposed(),LS(this)},jy().prototype.relu6=function(){return this.throwIfDisposed(),h_(this)},jy().prototype.reshapeAs=function(t){return this.throwIfDisposed(),mw(this,t.shape)},jy().prototype.reshape=function(t){return this.throwIfDisposed(),mw(this,t)},jy().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),W_(this,t,e,n)},jy().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),V_(this,t,e,n)},jy().prototype.reverse=function(t){return this.throwIfDisposed(),FS(this,t)},jy().prototype.rfft=function(){return this.throwIfDisposed(),o_(this)},jy().prototype.round=function(){return this.throwIfDisposed(),j_(this)},jy().prototype.rsqrt=function(){return this.throwIfDisposed(),wM(this)},jy().prototype.selu=function(){return this.throwIfDisposed(),$S(this)},jy().prototype.separableConv2d=function(t,e,n,r,i,s){return this.throwIfDisposed(),PS(this,t,e,n,r,i,s)},jy().prototype.sigmoid=function(){return this.throwIfDisposed(),OS(this)};const oC=Sv({sign_:function(t){const e={x:vv(t,"x","sign")};return cv.runKernel(bx,e)}});jy().prototype.sign=function(){return this.throwIfDisposed(),oC(this)},jy().prototype.sin=function(){return this.throwIfDisposed(),aM(this)},jy().prototype.sinh=function(){return this.throwIfDisposed(),lM(this)},jy().prototype.slice=function(t,e){return this.throwIfDisposed(),zS(this,t,e)},jy().prototype.softmax=function(t){return this.throwIfDisposed(),GS(this,t)},jy().prototype.softplus=function(){return this.throwIfDisposed(),HS(this)},jy().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),Xk(this,t,e)},jy().prototype.split=function(t,e){return this.throwIfDisposed(),jS(this,t,e)},jy().prototype.sqrt=function(){return this.throwIfDisposed(),qS(this)},jy().prototype.square=function(){return this.throwIfDisposed(),vS(this)},jy().prototype.squaredDifference=function(t){return this.throwIfDisposed(),aI(this,t)},jy().prototype.squeeze=function(t){return this.throwIfDisposed(),XS(this,t)},jy().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof Hy?[this,t]:[this,...t];return KS(n,e)},jy().prototype.step=function(t){return this.throwIfDisposed(),d_(this,t)};const lC=Sv({stridedSlice_:function(t,e,n,r,i=0,s=0,a=0,o=0,l=0){const u={x:vv(t,"x","stridedSlice","string_or_numeric")},c={begin:e,end:n,strides:r,beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return cv.runKernel(Fx,u,c)}});jy().prototype.stridedSlice=function(t,e,n,r,i,s,a,o){return this.throwIfDisposed(),lC(this,t,e,n,r,i,s,a,o)},jy().prototype.sub=function(t){return this.throwIfDisposed(),eS(this,t)},jy().prototype.sum=function(t,e){return this.throwIfDisposed(),nS(this,t,e)};const uC=Sv({tan_:function(t){const e={x:vv(t,"x","tan","float32")};return cv.runKernel(Bx,e)}});jy().prototype.tan=function(){return this.throwIfDisposed(),uC(this)},jy().prototype.tanh=function(){return this.throwIfDisposed(),YS(this)},jy().prototype.tile=function(t){return this.throwIfDisposed(),Gw(this,t)},jy().prototype.toBool=function(){return this.throwIfDisposed(),ab(this,"bool")},jy().prototype.toFloat=function(){return this.throwIfDisposed(),ab(this,"float32")},jy().prototype.toInt=function(){return this.throwIfDisposed(),ab(this,"int32")};const cC=Sv({topk_:function(t,e=1,n=!0){const r=vv(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const i=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const s={x:r},a={k:e,sorted:n},[o,l]=cv.runKernel(Vx,s,a);return{values:o,indices:l}}});jy().prototype.topk=function(t,e){return this.throwIfDisposed(),cC(this,t,e)},jy().prototype.transpose=function(t){return this.throwIfDisposed(),i_(this,t)};const hC=Sv({unique_:function(t,e=0){const n=vv(t,"x","unique","string_or_numeric");uf(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},i={axis:e},[s,a]=cv.runKernel(jx,r,i);return{values:s,indices:a}}});jy().prototype.unique=function(t){return this.throwIfDisposed(),hC(this,t)},jy().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),_M(this,t,e)},jy().prototype.unstack=function(t){return this.throwIfDisposed(),QS(this,t)},jy().prototype.where=function(t,e){return this.throwIfDisposed(),t_(t,this,e)},jy().prototype.zerosLike=function(){return this.throwIfDisposed(),e_(this)};class dC extends Error{constructor(t){super(t),Object.setPrototypeOf(this,dC.prototype)}}class pC extends Error{constructor(t){super(t),Object.setPrototypeOf(this,pC.prototype)}}class fC extends Error{constructor(t){super(t),Object.setPrototypeOf(this,fC.prototype)}}class mC extends Error{constructor(t){super(t),Object.setPrototypeOf(this,mC.prototype)}}class gC extends Error{constructor(t){super(t),Object.setPrototypeOf(this,gC.prototype)}}class xC extends Error{constructor(t){super(t),Object.setPrototypeOf(this,xC.prototype)}}class yC{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}function vC(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function bC(t,e){if(!t)throw new gC(e)}function wC(t,e){let n=0;for(const r of t)r===e&&n++;return n}function SC(t){return 1===t.length?t[0]:t}function _C(t){return Array.isArray(t)?t:[t]}function IC(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function kC(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let MC={};function TC(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function CC(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach((t=>CC(t)));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?CC(e):t[n]=e.value)}}}function EC(t,e={},n={},r="object",i=!1){if("string"==typeof t){const i=t;let s;if(i in n)s=n[i];else if(i in MC)s=MC[i];else if(s=e[i],null==s)throw new fC(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=t;if(null==s.className||null==s.config)throw new fC(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const a=s.className;let o,l;if(a in n?[o,l]=n[a]:a in MC?[o,l]=MC.className:a in e&&([o,l]=e[a]),null==o)throw new fC(`Unknown ${r}: ${a}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const e of Object.keys(MC))t[e]=MC[e];for(const e of Object.keys(n))t[e]=n[e];s.config.customObjects=t;const e=Object.assign({},MC);for(const t of Object.keys(n))MC[t]=n[t];CC(s.config);const r=l(o,s.config,n,i);return MC=Object.assign({},e),r}{const t=Object.assign({},MC);for(const t of Object.keys(n))MC[t]=n[t];const e=new o(s.config);return MC=Object.assign({},t),e}}}function AC(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function NC(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function RC(t){if(null==t)throw new fC(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function DC(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new fC(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function LC(t,e,n=0,r=1/0){return bC(n>=0),bC(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((t=>typeof t===e))}function FC(t,e){Array.isArray(t)?(uf(t.length>0,(()=>`${e} is unexpectedly an empty array.`)),t.forEach(((t,n)=>FC(t,`element ${n+1} of ${e}`)))):uf(Number.isInteger(t)&&t>0,(()=>`Expected ${e} to be a positive integer, but got ${$C(t)}.`))}function $C(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>$C(t))).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function PC(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let OC=0;function zC(){return OC++}const BC={};function UC(t=""){return t in BC||(BC[t]=0),BC[t]+=1,t+BC[t].toString()}const WC=["channelsFirst","channelsLast"],VC=["nearest","bilinear"],GC=["valid","same","causal"],HC=["max","avg"],jC=["sum","mul","concat","ave"],qC=new Map;function XC(t){DC(WC,"DataFormat",t)}function KC(t){DC(GC,"PaddingMode",t)}function YC(t){DC(HC,"PoolMode",t)}const ZC=[],JC="/";function QC(t,e){ZC.push(t);try{const t=e();return ZC.pop(),t}catch(t){throw ZC.pop(),t}}function tE(t){if(!rE(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===ZC.length?"":ZC.join(JC)+JC)+t}function eE(t){if(!rE(t))throw new Error("Not a valid tensor name: '"+t+"'");qC.has(t)||qC.set(t,0);const e=qC.get(t);if(qC.set(t,qC.get(t)+1),e>0){const n=`${t}_${e}`;return qC.set(n,1),n}return t}const nE=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function rE(t){return!!t.match(nE)}function iE(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let i=e;i<n;++i)r*=t[i];return r}function sE(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function aE(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function oE(t,e){if(e<t)throw new fC(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let r=t;r<e;++r)n.push(r);return n}let lE;function uE(){return null==lE&&(lE=jb().epsilon()),lE}function cE(t,e){return ab(t,e)}function hE(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),mw(t,n)}function dE(t,e,n){return Wb((()=>{switch(t.rank){case 1:return BS(t,e,n);case 2:return US(t,[e,0],[n,t.shape[1]]);case 3:return WS(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return VS(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return zS(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return zS(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new fC(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}))}function pE(t,e,n){return Wb((()=>{switch(t.rank){case 1:return BS(t,e,n);case 2:return US(t,[0,e],[t.shape[0],n]);case 3:return WS(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return VS(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new fC(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}}))}function fE(t,e,n,r){return Wb((()=>{switch(t.rank){case 1:return BS(t,e,n);case 2:switch(r){case 1:return dE(t,e,n);case 2:return pE(t,e,n);default:throw new fC(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return dE(t,e,n);case 2:return WS(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return pE(t,e,n);default:throw new fC(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return dE(t,e,n);case 2:return VS(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return VS(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return pE(t,e,n);default:throw new fC(`The axis is not within the rank of the tensor ${r}`)}default:throw new fC(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}}))}function mE(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),kw(t,e)}function gE(t,e){switch(t.rank){case 1:return Mw([t,e]);case 2:return Tw([t,e],0);case 3:return Cw([t,e],0);case 4:return Ew([t,e],0);default:throw new fC(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function xE(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new fC(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return Gw(t,e)}function yE(t,e=0,n=1,r,i){return RS(t,e,n,r,i)}function vE(t,e,n,r){if(t.rank<2||e.rank<2)throw new mC(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new mC(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`);if(2===t.rank&&2===e.rank)return b_({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?SE(t.rank,r,"channelsLast"):null,activation:n});{const i=t.shape.slice(),s=i.pop();t=mw(t,[-1,s]);const a=e.shape.slice(),o=a.pop(),l=a.pop(),u=[...a,o],c=Array.from({length:e.rank},((t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n));e=mw(i_(e,c),[l,-1]);const h=[...i,...u];return mw(b_({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?SE(t.rank,r,"channelsLast"):null,activation:n}),h)}}function bE(t,e,n){return Wb((()=>(e=Array.isArray(e)?ZS(e,"int32"):ab(e,"int32"),qw(t,e,n))))}function wE(t){return tS(t,t)}function SE(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new fC(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===n)return 1===r.length?mw(e,[1,r[0],1,1,1]):mw(e,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?mw(e,[1,1,1,1,r[0]]):mw(e,[1].concat(r))}else if(4===t){if("channelsFirst"===n)return 1===r.length?mw(e,[1,r[0],1,1]):mw(e,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?mw(e,[1,1,1,r[0]]):mw(e,[1].concat(r))}else if(3===t){if("channelsFirst"===n)return 1===r.length?mw(e,[1,r[0],1]):mw(e,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?mw(e,[1,1,r[0]]):mw(e,[1].concat(r))}else if(t<3)return e;throw new fC(`Unsupported input rank by biasAdd: ${e.rank}`)}function _E(t,e,n){return Wb((()=>(null==n&&(n="channelsLast"),XC(n),Zb(t,SE(t.rank,e,n)))))}function IE(t,e,n,r){return Wb((()=>s_(t,e,n,r)))}function kE(t,e,n=!1){return n?t():e()}const ME=["fanIn","fanOut","fanAvg"],TE=["normal","uniform","truncatedNormal"];class CE extends Pb{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class EE extends CE{apply(t,e){return IS(t,e)}}EE.className="Zeros",zb(EE);class AE extends CE{apply(t,e){return kS(t,e)}}AE.className="Ones",zb(AE);class NE extends CE{constructor(t){if(super(),"object"!=typeof t)throw new fC(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new fC(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return Wb((()=>tS(Xb(this.value),kS(t,e))))}getConfig(){return{value:this.value}}}NE.className="Constant",zb(NE);class RE extends CE{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return DS(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}RE.className="RandomUniform",zb(RE);class DE extends CE{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new mC(`randomNormal does not support dType ${e}.`);return yE(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}DE.className="RandomNormal",zb(DE);class LE extends CE{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new mC(`truncatedNormal does not support dType ${e}.`);return JS(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}LE.className="TruncatedNormal",zb(LE);class FE extends CE{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return Wb((()=>{if(2!==t.length||t[0]!==t[1])throw new fC("Identity matrix initializer can only be used for 2D square matrices.");return tS(this.gain,Hw(t[0]))}))}getConfig(){return{gain:this.gain}}}FE.className="Identity",zb(FE);class $E extends CE{constructor(t){if(super(),t.scale<0)throw new fC(`scale must be a positive float. Got: ${t.scale}`);var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,DC(ME,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){DC(TE,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,r;if(XC(e),2===t.length)n=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=iE(t,2);n=t[1]*e,r=t[0]*e}else if("channelsLast"===e){const e=iE(t,0,t.length-2);n=t[t.length-2]*e,r=t[t.length-1]*e}}else{const e=iE(t);n=Math.sqrt(e),r=Math.sqrt(e)}return[n,r]}(t),r=n[0],i=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,i):s/=Math.max(1,(r+i)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new mC(`${this.getClassName()} does not support dType ${e}.`);return JS(t,0,n,e,this.seed)}{const n=Math.sqrt(3*s);return DS(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}$E.className="VarianceScaling",zb($E);class PE extends $E{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return $E.className}}PE.className="GlorotUniform",zb(PE);class OE extends $E{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return $E.className}}OE.className="GlorotNormal",zb(OE);class zE extends $E{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return $E.className}}zE.className="HeNormal",zb(zE);class BE extends $E{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return $E.className}}BE.className="HeUniform",zb(BE);class UE extends $E{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return $E.className}}UE.className="LeCunNormal",zb(UE);class WE extends $E{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return $E.className}}WE.className="LeCunNormal",zb(WE);class VE extends CE{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new mC("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return Wb((()=>{if(t.length<2)throw new mC("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=yE(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=uI.gramSchmidt(e);return t[0]>t[1]&&(n=i_(n)),tS(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}VE.className="Orthogonal",zb(VE);const GE={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function HE(t,e={}){return EC(t,Ob.getMap().classNameMap,e,"initializer")}function jE(t){return TC(t)}function qE(t){if("string"==typeof t){const e=t in GE?GE[t]:t;if("GlorotNormal"===e)return new OE;if("GlorotUniform"===e)return new PE;if("HeNormal"===e)return new zE;if("HeUniform"===e)return new BE;if("LeCunNormal"===e)return new UE;if("LeCunUniform"===e)return new WE;{const t={};return t.className=e,t.config={},HE(t)}}return t instanceof CE?t:HE(t)}function XE(t){return Array.isArray(t)&&Array.isArray(t[0])}function KE(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function YE(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new fC(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function ZE(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new fC(`Expected exactly 1 Shape; got ${t.length}`)}return t}function JE(t){let e=0;for(const n of t)0===n.shape.length?e+=1:e+=n.shape.reduce(((t,e)=>t*e));return e}const QE="Variable";class tA{constructor(t,e="float32",n=QE,r=!0,i=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=zC(),n=null==n?QE:n,this.originalName=tE(n),this.name=eE(this.originalName),this.trainable_=r,this.constraint=i,this.val=function(t,e=!0,n,r){return cv.makeVariable(t,e,n,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function eA(t){return t.map((t=>t.read()))}function nA(t){t.forEach((t=>{t[0].write(t[1])}))}class rA{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class iA{constructor(t,e,n,r,i,s,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=zC(),null!=s&&(this.originalName=tE(s),this.name=eE(this.originalName)),this.rank=e.length}}let sA=0;class aA{constructor(t,e){this.callArgs=e,this.id=sA++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const e of t.inboundLayers)null!=e&&e.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let oA=0;class lA extends Pb{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=oA++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=IC(t)+"_"+UC(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new pC(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new fC(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return SC(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return SC(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new dC(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new dC(`Layer ${this.name} is not connected, no input to return.`);return SC(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new dC(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new dC(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return SC(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((e=>e.trainable=t)),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((t=>t.trainable)):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=_C(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=_C(this.inputSpec);if(t.length!==e.length)throw new fC(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){const r=t[n],i=e[n];if(null==i)continue;const s=r.rank;if(null!=i.ndim&&s!==i.ndim)throw new fC(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${s}`);if(null!=i.maxNDim&&s>i.maxNDim)throw new fC(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${s}`);if(null!=i.minNDim&&s<i.minNDim)throw new fC(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${s}.`);if(null!=i.dtype&&r.dtype!==i.dtype)throw new fC(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${r.dtype}.`);if(i.axes){const t=r.shape;for(const e in i.axes){const r=Number(e),s=i.axes[e],a=r>=0?t[r]:t[t.length+r];if(null!=s&&-1===[s,null].indexOf(a))throw new fC(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=i.shape)for(let t=0;t<i.shape.length;++t){const e=i.shape[t],s=r.shape[t];if(null!=e&&null!=s&&e!==s)throw new fC(`Input ${n} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=_C(t);let r=!0;for(const t of n)if(!(t instanceof iA)){r=!1;break}let i=!0;for(const t of n)if(t instanceof iA){i=!1;break}if(r===i)throw new fC("Arguments to apply() must be all SymbolicTensors or all Tensors");return QC(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of _C(t))e.push(n.shape);this.build(SC(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let r=this.call(t,e);const i=_C(r),s=[];for(let t of i)-1!==n.indexOf(t)&&(t=t.clone()),s.push(t);if(r=SC(s),null!=this.activityRegularizer)throw new mC("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=_C(t);const e=[];for(const n of t)e.push(n.shape);return SC(e)}(t),r=this.computeOutputShape(n);let i;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),i=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new iA(s,n,this,_C(t),e,this.name,r))):new iA(s,r,this,_C(t),e,this.name),this.addInboundNode(t,i,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new mC("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}}))}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new dC(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new dC(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new pC(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return JE(this.weights)}build(t){this.built=!0}getWeights(t=!1){return eA(t?this.trainableWeights:this.weights)}setWeights(t){Wb((()=>{const e=this.weights;if(e.length!==t.length)throw new fC(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],r=eA(e);for(let i=0;i<r.length;++i){const s=r[i],a=e[i],o=t[i];if(!ff(s.shape,o.shape))throw new fC(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([a,o])}nA(n)}))}addWeight(t,e,n,r,i,s,a,o){if(-1!==this._addedWeightNames.indexOf(t))throw new fC(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():qE("zeros"));const l=r.apply(e,n),u=new tA(l,n,t,s,a);return l.dispose(),null!=i&&this.addLoss((()=>i.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=_C(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach((t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return e}addInboundNode(t,e,n,r,i,s,a=null){const o=_C(t);e=_C(e),n=_C(n),r=_C(r),i=KE(i),s=KE(s);const l=[],u=[],c=[];for(const t of o)l.push(t.sourceLayer),u.push(t.nodeIndex),c.push(t.tensorIndex);new aA({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:s},a);for(let t=0;t<e.length;t++)e[t].sourceLayer=this,e[t].nodeIndex=this.inboundNodes.length-1,e[t].tensorIndex=t}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach((t=>t.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function uA(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const r=uA(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of r)-1===e.indexOf(t)&&e.push(t)}return e}}}class cA extends lA{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:UC("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new fC("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new fC("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new fC("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new iA(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new aA({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new fC(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}cA.className="InputLayer",zb(cA);class hA{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof hA)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new fC(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return ab(e,t.dtype)}catch(n){throw new fC(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof iA){if(null==this.id2Value[t.id])throw new fC(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new fC(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof iA){if(null==this.id2Value[t.id])throw new fC(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new fC(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&Vb(this.id2Mask)}}const dA=new yC,pA=new yC;function fA(t,e,n,r){const i=null!=n&&n.training,s=Array.isArray(t),a=s?t:[t],o=a.map((t=>t.name)),l=[],u=e.names();for(const t of o)-1!==u.indexOf(t)?l.push(e.getValue(t)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+e.names().sort().join(",");let h,d=dA.get(c);if(null==d){const t=function(t,e){uf(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===t.length){const i=gA(t[0],e);n=i.sorted,r=i.recipientMap}else{const i=new Set;for(const s of t){const{sorted:t,recipientMap:a}=gA(s,e);for(const e of t)i.has(e.name)||(n.push(e),i.add(e.name));for(const t in a)null==r[t]&&(r[t]=new Set),a[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:mA(r)}}(a,e);d=t.sorted,h=t.recipientCounts,dA.put(c,d),pA.put(c,h)}h={},i||Object.assign(h,pA.get(c));const p=new hA(e);for(let t=0;t<d.length;++t){if(null!=r){const t=Ub().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const s=d[t],a=s.sourceLayer;if(a instanceof cA)continue;const u=[],c=[],f=[];let m=!1;for(const t of s.inputs){const n=p.getValue(t),r=p.getMask(t);u.push(n),c.push(r),null!=r&&(m=!0),i||(h[t.name]--,0!==h[t.name]||e.hasKey(t)||-1!==o.indexOf(t.name)||n.isDisposed||!0===t.sourceLayer.stateful||f.push(n))}m&&((n=n||{}).mask=c[0]);const g=_C(a.apply(u,n));let x=null;a.supportsMasking&&(x=a.computeMask(u,c));const y=xA(s),v=Array.isArray(y)?y:[y];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(x)?x[0]:x);const e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}i||Vb(f)}return p.disposeMasks(),s?l:l[0]}function mA(t){const e={};for(const n in t)e[n]=t[n].size;return e}function gA(t,e){const n=new Set,r=[],i={};for(const t of e.names())n.add(t);const s=[],a=[];for(s.push(t);s.length>0;){const t=s[s.length-1];if(n.has(t.name)){s.pop();continue}const e=a[a.length-1]===s.length-1;if(0===t.inputs.length||e)s.pop(),r.push(t),n.add(t.name),e&&a.pop();else{a.push(s.length-1);for(const e of t.inputs)null==i[e.name]&&(i[e.name]=new Set),i[e.name].add(t.name),n.has(e.name)||s.push(e)}}return{sorted:r,recipientMap:i}}function xA(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}function yA(t,e){return Wb((()=>qS(nS(tS(t,t),e,!0))))}Hf().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(t){null!=dA&&dA.setMaxEntries(t),null!=pA&&pA.setMaxEntries(t)}));class vA extends Pb{getConfig(){return{}}}class bA extends vA{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Wb((()=>{const e=yA(t,this.axis),n=Iw(e,0,this.maxValue);return tS(t,zw(n,Zb(uE(),e)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}bA.className="MaxNorm",zb(bA);class wA extends vA{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Wb((()=>zw(t,Zb(uE(),yA(t,this.axis)))))}getConfig(){return{axis:this.axis}}}wA.className="UnitNorm",zb(wA);class SA extends vA{apply(t){return LS(t)}}SA.className="NonNeg",zb(SA);class _A extends vA{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return Wb((()=>{const e=yA(t,this.axis),n=Zb(tS(this.rate,Iw(e,this.minValue,this.maxValue)),tS(1-this.rate,e));return tS(t,zw(n,Zb(uE(),e)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}_A.className="MinMaxNorm",zb(_A);const IA={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function kA(t){return TC(t)}function MA(t,e={}){return EC(t,Ob.getMap().classNameMap,e,"constraint")}function TA(t){return null==t?null:"string"==typeof t?MA({className:t in IA?IA[t]:t,config:{}}):t instanceof vA?t:MA(t)}async function CA(t){if(null==t)return;const e=[],n=[],r=[];for(const i in t){const s=t[i];if("number"!=typeof s){const t=s;e.push(t.data()),n.push(i),r.push(t)}}if(e.length>0){const i=await Promise.all(e);for(let e=0;e<i.length;++e)t[n[e]]=i[e][0];Vb(r)}}function EA(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var AA;!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(AA||(AA={}));class NA{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class RA{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class DA extends NA{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const t in e){const r=e[t];if("number"==typeof r)this.totals.hasOwnProperty(t)||(this.totals[t]=0),this.totals[t]=this.totals[t]+r*n;else{let e;t in this.totals?e=this.totals[t]:this.totals[t]=0;const i=Wb((()=>Zb(this.totals[t],tS(r,n))));this.totals[t]=i,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const t of this.params.metrics)null!=this.totals[t]&&("number"==typeof this.totals[t]?e[t]=this.totals[t]/this.seen:Wb((()=>{const n=tS(zw(1,this.seen),this.totals[t]);e[t]=n,this.totals[t].dispose(),Gb(e[t])})))}}class LA extends NA{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const t in e)null==this.history[t]&&(this.history[t]=[]),this.history[t].push(e[t])}async syncData(){const t=[],e=[],n=[];for(const r in this.history){const i=this.history[r];for(let s=0;s<i.length;++s)if("number"!=typeof i[s]){const a=i[s];t.push(a.data()),e.push(r),n.push(s)}}const r=await Promise.all(t);for(let t=0;t<r.length;++t)this.history[e[t]][n[t]].dispose(),this.history[e[t]][n[t]]=r[t][0]}}class FA extends NA{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||bI,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Cf(this.yieldEvery)&&(this.maybeWait=function(t,e,n){let r,i=null!=n?n():Ty();return(...s)=>{const a=null!=n?n():Ty();return a-i<e||(i=a,r=t(...s)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await CA(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await CA(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await CA(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await CA(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await CA(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Cf(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await CA(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await CA(t),await this.trainEnd(t))}}function $A(t,e){return null==t&&(t={}),t instanceof NA?[t]:Array.isArray(t)&&t[0]instanceof NA?t:_C(t).map((t=>new FA(t,e)))}class PA{constructor(){}static registerCallbackConstructor(t,e){uf(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`)),PA.checkForDuplicate(e),null==PA.constructors[t]&&(PA.constructors[t]=[]),PA.constructors[t].push(e)}static checkForDuplicate(t){for(const e in PA.constructors)PA.constructors[+e].forEach((e=>{if(e===t)throw new fC("Duplicate callback constructor.")}))}static clear(){PA.constructors={}}static createCallbacks(t){const e=[];for(const n in PA.constructors){const r=+n;t>=r&&e.push(...PA.constructors[r])}return e.map((t=>new t))}}function OA(t,e,n,r,i,s,a,o,l){const u=new LA,c=[new DA,...PA.createCallbacks(e)];null!=t&&c.push(...t),c.push(u);const h=new RA(c);return h.setParams({epochs:n,initialEpoch:r,samples:i,steps:s,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:h,history:u}}function zA(t,e={},n=!1){return EC(t,Ob.getMap().classNameMap,e,"layer",n)}function BA(t,e){return Wb((()=>{"float32"!==t.dtype&&(t=ab(t,"float32"));const n=nS(wE(t),e,!0),r=_w(n.shape,uE()),i=qS(lS(n,r));return zw(t,i)}))}function UA(t,e){return Wb((()=>uS(wE(eS(e,t)),-1)))}function WA(t,e){return Wb((()=>uS(Yb(eS(e,t)),-1)))}function VA(t,e){return Wb((()=>{const n=eS(t,e),r=Iw(Yb(t),uE(),Number.MAX_VALUE),i=Yb(zw(n,r));return tS(100,uS(i,-1))}))}function GA(t,e,n=!1){return Wb((()=>{if(n)e=GS(e);else{const t=nS(e,e.shape.length-1,!0);e=zw(e,t)}return e=Iw(e,uE(),1-uE()),wS(nS(tS(ab(t,"float32"),Zw(e)),e.shape.length-1))}))}function HA(t,e,n=!1){return Wb((()=>{const r=ab(jw(function(t){const e=[iE(t.shape)];return mw(t,e)}(t)),"int32"),i=(e=Iw(e,uE(),1-uE())).shape;return GA(mw(_S(r,i[i.length-1]),i),e,n)}))}function jA(t,e){return Wb((()=>{let n;return n=Iw(e,uE(),1-uE()),n=Zw(zw(n,eS(1,n))),uS(function(t,e){if(!ff(t.shape,e.shape))throw new fC(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return Wb((()=>{const n=LS(e),r=wS(Yb(e));return Zb(eS(n,tS(e,t)),Jw(Ww(r)))}))}(t,n),-1)}))}function qA(t,e){return Wb((()=>{const n=BA(t,-1),r=BA(e,-1),i=tS(n,r);return wS(nS(i,-1))}))}PA.constructors={};const XA={meanSquaredError:UA,meanAbsoluteError:WA,meanAbsolutePercentageError:VA,meanSquaredLogarithmicError:function(t,e){return Wb((()=>{const n=Iw(e,uE(),Number.MAX_VALUE),r=Zw(Zb(1,n)),i=Iw(t,uE(),Number.MAX_VALUE),s=Zw(Zb(1,i));return uS(wE(eS(r,s)),-1)}))},squaredHinge:function(t,e){return Wb((()=>{const n=lS(0,eS(1,tS(t,e)));return uS(wE(n),-1)}))},hinge:function(t,e){return Wb((()=>{const n=lS(0,eS(1,tS(t,e)));return uS(n,-1)}))},categoricalHinge:function(t,e){return Wb((()=>{const n=nS(tS(t,e),-1),r=Qw(tS(eS(1,t),e),-1);return lS(0,Zb(1,eS(r,n)))}))},logcosh:function(t,e){return Wb((()=>{const n=Math.log(2),r=eS(e,t),i=eS(Zb(r,HS(tS(-2,r))),n);return uS(i,-1)}))},categoricalCrossentropy:GA,sparseCategoricalCrossentropy:HA,binaryCrossentropy:jA,kullbackLeiblerDivergence:function(t,e){return Wb((()=>{const n=Iw(t,uE(),1),r=Iw(e,uE(),1);return nS(tS(t,Zw(zw(n,r))),-1)}))},poisson:function(t,e){return Wb((()=>{const n=Zw(Zb(uE(),e));return uS(eS(e,tS(t,n)),-1)}))},cosineProximity:qA};function KA(t){if("string"==typeof t){if(t in XA)return XA[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new fC(e)}return t}function YA(t,e){return Wb((()=>{const n=tS(.5,MS(e)),r=cE(Xw(e,n),t.dtype);return uS(Uw(t,r),-1)}))}function ZA(t,e){return Wb((()=>cE(Uw(tw(t,-1),tw(e,-1)),"float32")))}function JA(t,e){return jA(t,e)}function QA(t,e){return t.rank===e.rank&&(t=XS(t,[t.rank-1])),(e=tw(e,-1)).dtype!==t.dtype&&(e=ab(e,t.dtype)),ab(Uw(t,e),"float32")}const tN=GA,eN=HA,nN={binaryAccuracy:YA,categoricalAccuracy:ZA,precision:function(t,e){return Wb((()=>{const n=function(t,e){return Wb((()=>ab(nS(iS(Uw(t,1),Uw(e,1))),"float32")))}(t,e),r=function(t,e){return Wb((()=>ab(nS(iS(Uw(t,0),Uw(e,1))),"float32")))}(t,e),i=Zb(n,r);return ab(t_(Xw(i,0),zw(n,i),0),"float32")}))},categoricalCrossentropy:tN,sparseCategoricalCrossentropy:eN,mse:UA,MSE:UA,mae:WA,MAE:WA,mape:VA,MAPE:VA,cosine:qA};function rN(t){if("string"==typeof t&&t in nN)return nN[t];if("string"!=typeof t&&null!=t)return t;throw new fC(`Unknown metric ${t}`)}function iN(t){if(bC(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const n of Object.keys(XA))if(XA[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(nN))if(nN[n]===t){e=n;break}return void 0!==e?e:t.name}}const sN=1048576;function aN(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!oN(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>sN&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${sN}.`)}}function oN(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!=typeof n)return!1;if(!oN(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!oN(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function lN(t,e,n=console.log){let r="";for(let n=0;n<t.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=t[n],r=r.slice(0,e[n]),r+=" ".repeat(e[n]-r.length);n(r)}function uN(t,e,n){let r,i;try{i=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){i="multiple"}try{r=JSON.stringify(t.outputShape)}catch(t){r="multiple"}lN([`${t.name} (${t.getClassName()})`,i,r,t.countParams().toString()],e,n)}function cN(t,e,n,r){let i,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){s="multiple"}try{i=JSON.stringify(t.outputShape)}catch(t){i="multiple"}const a=[];for(const e of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(e)))for(let t=0;t<e.inboundLayers.length;++t){const n=e.inboundLayers[t].name,r=e.nodeIndices[t],i=e.tensorIndices[t];a.push(`${n}[${r}][${i}]`)}const o=t.name,l=t.getClassName(),u=0===a.length?"":a[0];lN([`${o} (${l})`,s,i,t.countParams().toString(),u],e,r);for(let t=1;t<a.length;++t)lN(["","","","",a[t]],e,r)}function hN(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function dN(t,e){if(null===t)return null;if("string"==typeof t)return kC(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let i=0;i<r;++i){const r=t[i];hN(e,i,r)?n.push(r):n.push(dN(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"==typeof r)e[n]=r;else{const t=kC(n);e[t]=dN(r,t)}}return e}}function pN(t,e){if(null==t)return null;if("string"==typeof t)return IC(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let i=0;i<r;++i){const r=t[i];hN(e,i,r)?n.push(r):n.push(pN(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];e[IC(n)]="name"!==n&&"className"!==n||"string"!=typeof r?pN(r,n):r}return e}}const fN="3.21.0";class mN extends lA{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=UC(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],NC(this.inputs).length!==this.inputs.length)throw new fC(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((t=>t.name))}`);NC(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((t=>t.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const t of this.outputs){const e=t.sourceLayer,n=t.nodeIndex,r=t.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const t of this.inputs){const e=t.sourceLayer,n=t.nodeIndex,r=t.tensorIndex;bC(0===n,"input layer has >1 nodes"),bC(0===r,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e];if(!(n instanceof cA))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${e} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const t of this.outputLayers)this.outputNames.push(t.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},n={},r={},i={},s={},a=[],o=(t,e,n,r,i,l)=>{null!=r&&null!=i&&null!=l||(r=t.sourceLayer,i=t.nodeIndex,l=t.tensorIndex);const u=r.inboundNodes[i];if(-1!==n.indexOf(u))throw new pC(`The tensor ${t.name} at layer "${r.name}" is part of a cycle.`);if(-1!==e.indexOf(u))return;this.containerNodes.add(mN.nodeKey(r,i)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let t=0;t<c;t++){const r=u.inputTensors[t],i=u.inboundLayers[t],s=u.nodeIndices[t],a=u.tensorIndices[t];o(r,e,n,i,s,a)}for(e.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);a.push(u)},l=[],u=[];for(const t of this.outputs)o(t,l,u);const c=a.slice().reverse();for(const t of c){n[t.id]=t,t.id in e||(e[t.id]=0);let s=e[t.id];const a=null==r[t.outboundLayer.id]?0:r[t.outboundLayer.id];s=Math.max(s,a),r[t.outboundLayer.id]=s,i[t.outboundLayer.id]=t.outboundLayer,e[t.id]=s;for(let r=0;r<t.inboundLayers.length;r++){const i=t.inboundLayers[r],a=t.nodeIndices[r],o=i.inboundNodes[a],l=null==e[o.id]?0:e[o.id];e[o.id]=Math.max(s+1,l),n[o.id]=o}}const h={};for(const t in e){const r=e[t];r in h||(h[r]=[]),h[r].push(n[t])}const d={};for(const t in r){const e=r[t];e in d||(d[e]=[]),d[e].push(i[t])}let p=Object.keys(d).map((t=>parseInt(t,10))).sort(AC);this.layers=[];for(const t of p){const e=d[t];e.sort(((t,e)=>{const n=s[t.id],r=s[e.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof mN&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((t=>parseInt(t,10))).sort(AC);const f=this.inputs.slice(),m=[];for(const t of p)for(const e of h[t]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new pC(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map((t=>t.name));for(const t of g){const e=g.filter((e=>e===t)).length;if(1!==e)throw new pC(`The name "${t}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new aA({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new fC("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let r=0;for(const t of this.layers)for(const e of t.weights){if(null!=n[e.originalName])throw new fC(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,r++}const i=[];for(const r in t){let s=r;if(null==n[r]){const t=r.split("/");s=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[s])i.push([n[s],t[r]]);else if(e)throw new fC(`Provided weight data has no target variable: ${r}`);delete n[s]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new fC(`${t.length} of ${r} weights are not set: ${t}`)}nA(i)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${fN}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=pN(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return Wb((()=>{t=_C(t);const n=new hA;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return fA(this.outputs,n,e)}))}computeMask(t,e){return Wb((()=>{let n;return t=_C(t),n=null==e?vC(null,t.length):_C(e),this.runInternalGraph(t,n)[1]}))}computeOutputShape(t){const e=KE(t);if(e.length!==this.inputLayers.length)throw new fC(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let t=0;t<e.length;t++){const r=this.inputLayers[t],i=e[t];n[r.name+"_0_0"]=i}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(AC);if(r.length>1)for(const t of r){const e=this.nodesByDepth[t];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(e.id))continue;const r=[];for(let e=0;e<t.inboundLayers.length;e++){const i=t.inboundLayers[e],s=t.nodeIndices[e],a=t.tensorIndices[e],o=n[`${i.name}_${s}_${a}`];r.push(o)}const i=KE(e.computeOutputShape(SC(r))),s=e.inboundNodes.indexOf(t);for(let t=0;t<i.length;t++)n[`${e.name}_${s}_${t}`]=i[t]}}const i=[],s=[];for(let t=0;t<this.outputLayers.length;t++){const e=this.outputLayers[t],n=this.outputLayersNodeIndices[t],r=this.outputLayersTensorIndices[t],i=`${e.name}_${n}_${r}`;s.push(i)}for(let t=0;t<s.length;t++){const e=s[t];bC(e in n),i.push(n[e])}return SC(i)}runInternalGraph(t,e){null==e&&(e=vC(null,t.length));const n={};for(let r=0;r<this.inputs.length;++r){const i=this.inputs[r],s=t[r],a=e[r];n[i.id]=[s,a]}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(AC);for(const t of r){const e=this.nodesByDepth[t];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,i=t.outputTensors,s=new Array;for(const t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,a,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){const[t,n]=s[0];null==u.mask&&(u.mask=n),o=_C(e.call(t,u)),l=_C(e.computeMask(t,n)),r=[t],a=[n]}else r=s.map((t=>t[0])),a=s.map((t=>t[1])),null==u.mask&&(u.mask=a),o=_C(e.call(r,u)),l=_C(e.computeMask(r,a));if(e.activityRegularizer)throw new mC("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<i.length;++t){const e=i[t],r=o[t],s=l[t];n[e.id]=[r,s]}}}}const i=[],s=[],a=[];for(const t of this.outputs){bC(t.id in n,`Could not compute output ${t.name} : ${t.id}`);const[e,r]=n[t.id];a.push(e.shape),i.push(e),s.push(r)}return[i,s,a]}buildNodeConversionMap(t){const e={};let n;for(const t of this.layers){n=t instanceof mN?1:0;for(let r=0;r<t.inboundNodes.length;r++){const i=mN.nodeKey(t,r);this.containerNodes.has(i)&&(e[i]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new fC(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new fC("Provide either a layer name or layer index");for(const e of this.layers)if(e.name===t)return e;throw new fC(`No such layer: ${t}`)}calculateLosses(){return Wb((()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=mN.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const t of this.layers){const r=t.getClassName(),i=t.getConfig(),s=[];for(let n=0;n<t.inboundNodes.length;n++){const r=t.inboundNodes[n],i=mN.nodeKey(t,n);let a={};if(this.containerNodes.has(i)){if(r.callArgs)try{JSON.stringify(r.callArgs),a=r.callArgs}catch(e){console.warn(`Layer ${t.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),a={}}if(r.inboundLayers.length>0){const t=[];for(let n=0;n<r.inboundLayers.length;n++){const i=r.inboundLayers[n],s=r.nodeIndices[n],o=r.tensorIndices[n];let l=e[mN.nodeKey(i,s)];null==l&&(l=0),t.push([i.name,l,o,a])}s.push(t)}}}const a={};a.name=t.name,a.className=r,a.config=i,a.inboundNodes=s,n.push(a)}t.layers=n;const r=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t],i=this.inputLayersNodeIndices[t],s=mN.nodeKey(n,i);if(!this.containerNodes.has(s))continue;let a=e[s];null==a&&(a=0);const o=this.inputLayersTensorIndices[t];r.push([n.name,a,o])}t.inputLayers=r;const i=[];for(let t=0;t<this.outputLayers.length;t++){const n=this.outputLayers[t],r=this.outputLayersNodeIndices[t],s=mN.nodeKey(n,r);if(!this.containerNodes.has(s))continue;let a=e[s];null==a&&(a=0);const o=this.outputLayersTensorIndices[t];i.push([n.name,a,o])}return t.outputLayers=i,t}static fromConfig(t,e,n={},r=!1){const i={},s={};function a(t,e){t.name in s?s[t.name].push(e):s[t.name]=[e]}function o(t,e){const n=[];let r;for(const s of e){const o=s[0],l=s[1],u=s[2];if(r=null==s[3]?{}:s[3],!(o in i))return void a(t,e);const c=i[o];if(c.inboundNodes.length<=l)return void a(t,e);const h=c.inboundNodes[l];n.push(h.outputTensors[u])}n.length>0&&t.apply(SC(n),r)}function l(t){const n=t.name,s=zA(t,null!=e.customObjects?e.customObjects:{});s.setFastWeightInitDuringBuild(r),i[n]=s,t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new fC(`Corrupted configuration, expected array for nodeData: ${t}`);a(s,t)}))}const u=e.name,c=e.layers;for(const t of c)l(t);for(;!RC(s);)for(const t of c){const e=i[t.name];if(e.name in s){const t=s[e.name];delete s[e.name];for(const n of t)o(e,n)}}const h=[],d=[],p=e.inputLayers;for(const t of p){const e=t[0],n=t[1],r=t[2];bC(e in i);const s=i[e].inboundNodes[n].outputTensors;h.push(s[r])}const f=e.outputLayers;for(const t of f){const e=t[0],n=t[1],r=t[2];bC(e in i);const s=i[e].inboundNodes[n].outputTensors;d.push(s[r])}return new t({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new fC("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Wb((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}function gN(t,e){return function(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>null));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach((e=>{e in t?n.push(t[e]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}(t,e,"classWeight")}async function xN(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=Wb((()=>{if(1===t.shape.length)return ob(t);if(2===t.shape.length){if(t.shape[1]>1)return tw(t,1);if(1===t.shape[1])return mw(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await e.data());Vb(e);const i=[];return r.forEach((t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);i.push(n[t])})),ZS(i,"float32")}return null}function yN(t,e){return tS(t,e)}const vN=32;function bN(t,e){let n,r;const i=e;n=i.xs,r=i.ys,uf(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`));const s=wN("input",t.inputNames,n),a=wN("output",t.outputNames,r),o=s[0].shape[0];uf(s.length===t.inputs.length,(()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`)),uf(a.length===t.outputs.length,(()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`));for(let e=0;e<s.length;e++)uf(s[e].shape[0]===o,(()=>`Batch size mismatch: input ${t.inputNames[e]} has ${s[e].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`));for(let e=0;e<a.length;e++)uf(a[e].shape[0]===o,(()=>`Batch size mismatch: output ${t.outputNames[e]} has ${a[e].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`));return{xs:s,ys:a}}function wN(t,e,n){if(n instanceof Hy)return[n];if(Array.isArray(n))return uf(n.length===e.length,(()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`)),n;{const r=[];for(const i of e){if(null==n[i])throw new fC(`The feature data generated by the dataset lacks the required ${t} key '${i}'.`);r.push(n[i])}return r}}function SN(t){return"function"==typeof t.iterator}function _N(t){uf(t>0&&Number.isInteger(t),(()=>`batchSize is required to be a positive integer, but got ${t}`))}function IN(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((t=>dE(t,e,n-e))):dE(t,e,n-e)}function kN(t,e){return Wb((()=>null==t?null:Array.isArray(t)?t.map((t=>kN(t,e))):bE(t,"int32"===e.dtype?e:ab(e,"int32"))))}function MN(t,e){const n=[];let r=0,i=null;for(;r<t;)i=r+e,i>=t&&(i=t),n.push([r,i]),r=i;return n}function TN(t){const e=[];t instanceof Hy&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(hE(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function CN(t,e){if(null==t)return;const n=[];if(e instanceof Hy)n.push(e.id);else if(Array.isArray(e))e.forEach((t=>n.push(t.id)));else if(null!=e)for(const t in e){const r=e[t];n.push(r.id)}const r=[];if(t instanceof Hy)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach((t=>{-1===n.indexOf(t.id)&&r.push(t)}));else if(null!=t)for(const e in t){const i=t[e];-1===n.indexOf(i.id)&&r.push(i)}r.forEach((t=>{t.isDisposed||t.dispose()}))}function EN(t){return Array.isArray(t)}function AN(t){return!function(t){return t instanceof Hy}(t)&&!EN(t)}function NN(t,e,n,r=!0,i=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(EN(t)&&t.length>0)e=!0;else if(AN(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new fC(`Error when checking model ${i} expected no data, but got ${t}`)}return[]}if(null==t)return e.map((t=>null));let s;if(AN(t)){s=[];for(const n of e){if(null==t[n])throw new fC(`No data provided for "${n}". Need data for each key in: ${e}`);s.push(t[n])}}else if(EN(t)){if(t.length!==e.length)throw new fC(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);s=t}else{if(e.length>1)throw new fC(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);s=[t]}if(s=TN(s),null!=n)for(let t=0;t<e.length;++t){if(null==n[t])continue;const a=s[t];if(a.shape.length!==n[t].length)throw new fC(`Error when checking ${i}: expected ${e[t]} to have ${n[t].length} dimension(s). but got array with shape ${a.shape}`);for(let e=0;e<n[t].length;++e){if(0===e&&!r)continue;const s=a.shape[e],o=n[t][e];if(null!=o&&o>=0&&s!==o)throw new fC(`${i} expected a batch of elements where each example has shape [${n[t].slice(1,n[t].length)}] (i.e.,tensor shape [*,${n[t].slice(1,n[t].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function RN(t,e,n,r=!0,i=""){let s;if(Array.isArray(t)){if(t.length!==e.length)throw new fC(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);s=t}else{if(e.length>1)throw new fC(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);s=[t]}if(null!=n)for(let t=0;t<e.length;++t){if(null==n[t])continue;const a=s[t];if(a.shape.length!==n[t].length)throw new fC(`Error when checking ${i}: expected ${e[t]} to have ${n[t].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let s=0;s<n[t].length;++s){if(0===s&&!r)continue;const o=a.shape[s],l=n[t][s];if(null!=l&&l!==o)throw new fC(`Error when checking ${i}: expected ${e[t]} to have shape ${JSON.stringify(n[t])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}class DN extends mN{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new fC("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,r=console.log){const i=function(t){let e=!0;const n=[],r=[];for(const e in t.nodesByDepth)n.push(t.nodesByDepth[e]);for(const t of n){if(t.length>1||1===t.length&&t[0].inboundLayers.length>1){e=!1;break}r.push(...t)}if(e)for(const n of t.layers){let t=!1;for(const i of n.inboundNodes)if(-1!==r.indexOf(i)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),s=["Layer (type)","Input Shape","Output shape","Param #"];let a;if(i?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((t=>Math.floor(e*t)))),!i){s.push("Receives inputs"),a=[];for(const e in t.nodesByDepth)a.push(...t.nodesByDepth[e])}r("_".repeat(e)),lN(s,n,r),r("=".repeat(e));const o=t.layers;for(let t=0;t<o.length;++t)i?uN(o[t],n,r):cN(o[t],n,a,r),r((t===o.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=null!=t.collectedTrainableWeights?JE(t.collectedTrainableWeights):JE(t.trainableWeights),e}(t),u=JE(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>yI.adagrad(.01),Adadelta:()=>yI.adadelta(1,.95,uE()),Adam:()=>yI.adam(.001,.9,.999,uE()),Adamax:()=>yI.adamax(.002,.9,.999,uE(),0),RMSProp:()=>yI.rmsprop(.001,.9,0,uE()),SGD:()=>yI.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new fC(`Unknown Optimizer ${t}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Kb))throw new fC("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new fC(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);const n=t.loss;e=n.map((t=>KA(t)))}else{const n=KA(t.loss);this.outputs.forEach((t=>{e.push(n)}))}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new fC(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(KA(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let t=0;t<this.outputs.length;++t){const e=this.internalOutputShapes[t],n=this.outputNames[t];this.feedOutputNames.push(n),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[t])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],QC("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}}));const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>[]));let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);n=t}if(Array.isArray(n))return e.map((t=>n));{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),i=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};QC("metric",(()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,r,s;for(const a of e){if("string"==typeof a&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(a)){const e=this.internalOutputShapes[t];let i;1===e[e.length-1]||this.lossFunctions[t]===jA?-1!==["accuracy","acc"].indexOf(a)?r=YA:-1!==["crossentropy","ce"].indexOf(a)&&(r=JA):this.lossFunctions[t]===HA?-1!==["accuracy","acc"].indexOf(a)?r=QA:-1!==["crossentropy","ce"].indexOf(a)&&(r=eN):-1!==["accuracy","acc"].indexOf(a)?r=ZA:-1!==["crossentropy","ce"].indexOf(a)&&(r=tN),-1!==["accuracy","acc"].indexOf(a)?i="acc":-1!==["crossentropy","ce"].indexOf(a)&&(i="ce"),s=r,n=""+i}else{const t=rN(a);s=t,n=""+iN(a)}let e;QC(n,(()=>{e=s})),i(t,n,e)}})(r[t])})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const r=null==n.batchSize?32:n.batchSize;_N(r);const i=this.standardizeUserDataXY(t,e,!0,r);try{const t=i[0].concat(i[1]);this.makeTestFunction();const e=this.testFunction;return SC(this.testLoop(e,t,r,n.verbose,n.steps))}finally{CN(i[0],t),CN(i[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,i=t.testFunction;let s=[];if(n.verbose>0)throw new mC("Verbose mode is not implemented yet.");uf(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const a="function"==typeof e.next?e:await e.iterator();let o=0,l=0;for(;!r||l<n.batches;){const e=await a.next();if(s=Wb((()=>{if(e.value){const{xs:n,ys:r}=bN(t,e.value),a=n.concat(r),u=Wb((()=>i(a)));if(Vb(a),0===l)for(let t=0;t<u.length;++t)s.push(Xb(0));const c=a[0].shape[0];for(let t=0;t<u.length;++t){const e=u[t],n=s[t];s[t]=Wb((()=>Zb(s[t],tS(c,e)))),l>0&&Vb(n)}Vb(u),o+=c,++l}return s})),e.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let t=0;t<s.length;++t){const e=s[t];s[t]=zw(s[t],o),Vb(e)}return SC(s)}(this,t,e)}checkNumSamples(t,e,n,r="steps"){let i;if(null!=n){if(i=null,null!=e)throw new fC(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else{if(null==t)throw new fC(`Either the input data should have a defined shape, or ${r} shoud be specified.`);i=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return i}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new fC("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=n?e:[e],i=this.retrieveSymbolicTensors(r),s=new hA;if(t instanceof Hy&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new fC(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const e of this.inputs){const n=t[e.name];if(null==n)throw new fC(`No value is provided for the model's input ${e.name}`);s.add(e,n)}const a=fA(i,s);return n?a:a[0]}retrieveSymbolicTensors(t){const e=vC(null,t.length);let n=t.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],s=i.map((t=>t.name));for(let r=0;r<t.length;++r){const a=s.indexOf(t[r]);if(-1!==a&&(e[r]=i[a],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach(((e,r)=>{null==e&&n.push(t[r])})),new fC(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,n=!1){return Wb((()=>{const r=this.checkNumSamples(t);if(n)throw new mC("Verbose predictLoop() is not implemented yet.");const i=MN(r,e),s=this.outputs.map((t=>[]));for(let e=0;e<i.length;++e)Wb((()=>{const n=i[e][0],r=i[e][1],s=IN(t,n,r),a=[];if(Array.isArray(s))for(let t=0;t<s.length;++t)a.push({key:this.inputs[t],value:s[t]});else a.push({key:this.inputs[0],value:s});const o=new hA(a);return fA(this.outputs,o)})).forEach(((t,e)=>s[e].push(t)));return SC(s.map((t=>kw(t,0))))}))}predict(t,e={}){const n=TN(t);RN(n,this.inputNames,this.feedInputShapes,!1);try{const t=null==e.batchSize?32:e.batchSize;return _N(t),this.predictLoop(n,t)}finally{CN(n,t)}}predictOnBatch(t){RN(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,r){if(null==this.optimizer_)throw new pC("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let t=0;t<this.feedOutputShapes.length;++t){const e=this.feedOutputShapes[t];this.feedLossFns[t]===HA?i.push(e.slice(0,e.length-1).concat([1])):i.push(e)}if(function(t,e,n){const r=NC(t.map((t=>t.shape[0])));r.sort();const i=NC(e.map((t=>t.shape[0])));if(i.sort(),r.length>1)throw new fC(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((t=>t.shape)))}`);if(i.length>1)throw new fC(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((t=>t.shape)))}`);if(r.length>0&&i.length>0&&!ff(r,i))throw new fC(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}(t=NN(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=NN(e,this.feedOutputNames,i,!1,"target")),function(t,e,n){const r=[UA,jA,GA];for(let i=0;i<t.length;++i){const s=t[i],a=e[i],o=n[i];if(null!=a){if(a===GA&&1===s.shape[s.shape.length-1])throw new fC(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(a)){const t=s.shape.slice(1),e=o.slice(1);for(let n=0;n<t.length;++n){const r=t[n],i=e[n];if(null!=i&&r!==i)throw new fC(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&t[0].shape[0]%r!=0)throw new fC(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,r,i=!0,s){const[a,o]=this.standardizeUserDataXY(t,e,i,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=gN(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await xN(o[e],null,t[e]))}return[a,o,l]}testLoop(t,e,n,r=0,i){return Wb((()=>{const s=this.checkNumSamples(e,n,i,"steps"),a=[];if(r>0)throw new mC("Verbose mode is not implemented yet.");if(null!=i)throw new mC("steps mode in testLoop() is not implemented yet");{const r=MN(s,n),i=ZS(oE(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],o=r[n][1],l=dE(i,s,o-s),u=kN(e,l),c=t(u);if(0===n)for(let t=0;t<c.length;++t)a.push(Xb(0));for(let t=0;t<c.length;++t){const e=c[t];a[t]=Zb(a[t],tS(o-s,e))}}for(let t=0;t<a.length;++t)a[t]=zw(a[t],s)}return a}))}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let i=r;wC(t,r)>1&&(i+=`_${wC(t.slice(0,n),r)}`),e.push(i)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],a=this.collectedTrainableWeights.map((t=>t.read()));return[this.optimizer_.minimize((()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const a=new hA(t),o=fA(this.outputs,a,{training:!0});let l;for(let t=0;t<this.lossFunctions.length;++t){let n=(0,this.lossFunctions[t])(r[t],o[t]);null!=i[t]&&(n=yN(n,i[t]));const s=uS(n);e.push(s),l=0===t?n:Zb(l,n)}for(let t=0;t<this.metricsTensors.length;++t){let n;if(this.outputs.length>1&&t<this.outputs.length)n=e[t];else{const e=this.metricsTensors[t][0],i=this.metricsTensors[t][1];n=uS(e(r[i],o[i]))}Gb(n),s.push(n)}return l=uS(l),this.calculateLosses().forEach((t=>{l=Zb(l,t)})),l}),!0,a)].concat(s)}}makeTestFunction(){this.testFunction=t=>Wb((()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let t=0;t<this.inputs.length;++t)s.push({key:this.inputs[t],value:r[t]});const a=new hA(s),o=fA(this.outputs,a);for(let t=0;t<this.lossFunctions.length;++t){const r=this.lossFunctions[t],s=uS(r(i[t],o[t]));n=0===t?s:Zb(n,s),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][0],r=this.metricsTensors[t][1],s=uS(n(i[r],o[r]));e.push(s)}return e}))}async fit(t,e,n={}){return async function(t,e,n,r={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,s,a,o,l,u,c,h,d;t.isTraining=!0;try{const p=null==r.batchSize?32:r.batchSize;_N(p);const f=!1,m=await t.standardizeUserData(e,n,r.sampleWeight,r.classWeight,f,p);i=m[0],s=m[1],d=m[2];let g,x=!1;if(null!=r.validationData&&r.validationData.length>0){if(x=!0,2!==r.validationData.length)throw 3===r.validationData.length?new mC("validationData including sample weights is not supported yet."):new fC(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);l=r.validationData[0],u=r.validationData[1];const e=!0,n=await t.standardizeUserData(l,u,null,null,e,p);c=n[0],h=n[1],g=c.concat(h)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){x=!0;const t=Math.floor(i[0].shape[0]*(1-r.validationSplit)),e=i[0].shape[0];c=IN(i,t,e),a=i,i=IN(i,0,t),h=IN(s,t,e),o=s,s=IN(s,0,t),g=c.concat(h)}else null!=r.validationSteps&&(x=!0);const y=i.concat(s).concat(d);t.checkTrainableWeightsConsistency();const v=t.makeTrainFunction(),b=t.getDedupedMetricsNames();let w,S;x?(t.makeTestFunction(),w=t.testFunction,S=b.slice().concat(b.map((t=>"val_"+t)))):(w=null,g=[],S=b.slice());const _=$A(r.callbacks,r.yieldEvery),I=await async function(t,e,n,r,i,s,a,o,l,u,c,h,d,p,f){null==i&&(i=32),null==s&&(s=1),null==c&&(c=!0),null==d&&(d=0);let m=!1;null!=l&&null!=u&&(m=!0);const g=t.checkNumSamples(n,i,p,"steps_per_epoch");let x;null!=g&&(x=oE(0,g)),null==a&&(a=1);const{callbackList:y,history:v}=OA(o,a,s,d,g,p,i,m,h);y.setModel(t),t.history=v,await y.onTrainBegin(),t.stopTraining_=!1;for(let a=d;a<s;++a){await y.onEpochBegin(a);const s={};{if("batch"===c)throw new mC("batch shuffling is not implemneted yet");c&&sf(x);const a=ZS(x),o=MN(g,i);for(let c=0;c<o.length;++c){const h={};if(await y.onBatchBegin(c,h),Wb((()=>{const d=o[c][0],p=o[c][1],f=dE(a,d,p-d);h.batch=c,h.size=p-d;const g=kN(n,f),x=e(g);for(let t=0;t<r.length;++t){const e=r[t],n=x[t];h[e]=n,Gb(n)}if(c===o.length-1&&m){const e=t.testLoop(l,u,i);for(let t=0;t<r.length;++t){const n=r[t],i=e[t];Gb(i),s["val_"+n]=i}}})),await y.onBatchEnd(c,h),EA(h),t.stopTraining_)break}a.dispose()}if(await y.onEpochEnd(a,s),t.stopTraining_)break}return await y.onTrainEnd(),await t.history.syncData(),t.history}(t,v,y,b,p,r.epochs,r.verbose,_,w,g,r.shuffle,S,r.initialEpoch,null);return I}finally{t.isTraining=!1,CN(i,e),CN(s,n),CN(a,e),CN(o,n),CN(c,l),CN(h,u),null!=d&&Vb(d)}}(this,t,e,n)}async fitDataset(t,e){return async function(t,e,n){const r=null!=n.batchesPerEpoch;if(uf(null!=t.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),uf(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),uf(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),uf(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),uf(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const i=null!=n.validationData;let s,a;if(i)if(SN(n.validationData))uf(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const t=function(t){if(3===t.length)throw new mC("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);s=t.xs,a=t.ys}const o=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;u=i?l.slice().concat(l.map((t=>"val_"+t))):l.slice();const c=$A(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=OA(c,h,n.epochs,null,null,function(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}(e,n),null,i,u);d.setModel(t),t.history=p,await d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await e.iterator();for(;f<n.epochs;){const u={};await d.onEpochBegin(f);let c=0,h=0;for(r||(m=await e.iterator());!r||c<n.batchesPerEpoch;){const e=await m.next();if(r&&e.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:i}=bN(t,e.value),s={};s.batch=h,s.size=r[0].shape[0],await d.onBatchBegin(h,s);const a=[];if(null!=n.classWeight){const e=gN(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)a.push(await xN(i[t],null,e[t]))}const u=r.concat(i).concat(a),p=o(u);Vb(u);for(let t=0;t<l.length;++t){const e=l[t],n=p[t];s[e]=n,Gb(n)}await d.onBatchEnd(h,s),EA(s),h++,c++}if(r?c>=n.batchesPerEpoch:e.done){if(i){let e;e=SN(n.validationData)?_C(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):_C(t.evaluate(s,a,{batchSize:null==n.validationBatchSize?vN:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)u[`val_${t.metricsNames[n]}`]=e[n]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(f,u),f++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],i=n[1],s=this.makeTrainFunction()(r.concat(i)),a=[];for(const t of s){const e=await t.data();a.push(e[0])}return Vb(s),CN(n[0],t),CN(n[1],e),SC(a)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n);for(let t=0;t<r.length;++t)n&&!r[t].trainable||e.push({name:r[t].originalName,tensor:i[t]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=Ub().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-Ub().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=IC(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map((t=>IC(t)))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=IC(n[r])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[IC(iN(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((t=>IC(iN(t))));{const t={};for(const e in this.metrics)t[e]=IC(iN(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=zA(dN(t.optimizer_config));let n,r;if("string"==typeof t.loss)n=kC(t.loss);else if(Array.isArray(t.loss))n=t.loss.map((t=>kC(t)));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=kC(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map((t=>kC(t)));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=kC(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"==typeof t){const e=(n=t,Lv.getSaveHandlers(n));if(0===e.length)throw new fC(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new fC(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}var n;if(null==t.save)throw new fC("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await Tv(this.getNamedWeights(e)),i={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${fN}`,convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){i.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:n}=await Tv(await this.optimizer.getWeights(),t);r.specs.push(...n),r.data=Nv([r.data,e])}if(null!=this.userDefinedMetadata){const t=!0;aN(this.userDefinedMetadata,this.name,t),i.userDefinedMetadata=this.userDefinedMetadata}return i.weightData=r.data,i.weightSpecs=r.specs,t.save(i)}setUserDefinedMetadata(t){aN(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}DN.className="Model",zb(DN);class LN extends DN{}LN.className="Functional",zb(LN);class FN extends DN{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:UC("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new fC(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof FN||t instanceof DN;let n;if(e){if(n=t,1!==n.outputs.length)throw new fC("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new fC("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new fC("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new fC("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new cA({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new fC(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new fC("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=uA(this.outputs[0])}this.inboundNodes=[],new aA({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:vC(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(ZE(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new DN({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new pC("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new pC("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new pC("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new pC("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},r=!1){let i,s={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new fC("Legacy serialization format not supported yet.");i=e}else uf(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),i=e.layers,delete e.layers,s=e;const a=new t(s);if(!(a instanceof FN))throw new mC(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const t of i){const e=zA(t,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),a.add(e)}return a}set stopTraining(t){if(null==this.model)throw new fC("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new fC("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}FN.className="Sequential",zb(FN);class $N extends Pb{getConfig(){return{}}}class PN extends $N{apply(t,e=1){return function(t,e=1){if(1!==e)throw new mC(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Bw(t)}(t,e)}}PN.className="elu",zb(PN);class ON extends $N{apply(t){return $S(t)}}ON.className="selu",zb(ON);class zN extends $N{apply(t){return LS(t)}}zN.className="relu",zb(zN);class BN extends $N{apply(t){return Wb((()=>cS(6,LS(t))))}}BN.className="relu6",zb(BN);class UN extends $N{apply(t){return t}}UN.className="linear",zb(UN);class WN extends $N{apply(t){return OS(t)}}WN.className="sigmoid",zb(WN);class VN extends $N{apply(t){return function(t){return Wb((()=>{const e=Zb(.5,tS(.2,t));return Iw(e,0,1)}))}(t)}}VN.className="hardSigmoid",zb(VN);class GN extends $N{apply(t){return HS(t)}}GN.className="softplus",zb(GN);class HN extends $N{apply(t){return function(t){return Wb((()=>zw(t,Zb(Yb(t),1))))}(t)}}HN.className="softsign",zb(HN);class jN extends $N{apply(t){return YS(t)}}jN.className="tanh",zb(jN);class qN extends $N{apply(t,e=-1){return GS(t,e)}}qN.className="softmax",zb(qN);class XN extends $N{apply(t,e=-1){return rS(t,e)}}XN.className="logSoftmax",zb(XN);class KN extends $N{apply(t,e=1){return Wb((()=>tS(OS(tS(t,e)),t)))}}KN.className="swish",zb(KN);class YN extends $N{apply(t){return Wb((()=>tS(t,YS(HS(t)))))}}function ZN(t){return t.getClassName()}function JN(t,e={}){return EC(t,Ob.getMap().classNameMap,e,"activation")}function QN(t){if(null==t){return JN({className:"linear",config:{}})}if("string"==typeof t){const e={};return e.className=t,e.config={},JN(e)}return t instanceof $N?t:JN(t)}YN.className="mish",zb(YN);class tR extends Pb{}class eR extends tR{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return Wb((()=>{let e=IS([1]);return this.hasL1&&(e=Zb(e,nS(tS(this.l1,Yb(t))))),this.hasL2&&(e=Zb(e,nS(tS(this.l2,wE(t))))),mw(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}eR.className="L1L2",zb(eR);const nR={l1l2:"L1L2"};function rR(t){return TC(t)}function iR(t,e={}){return EC(t,Ob.getMap().classNameMap,e,"regularizer")}function sR(t){return null==t?null:"string"==typeof t?iR({className:t in nR?nR[t]:t,config:{}}):t instanceof tR?t:iR(t)}class aR extends lA{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=YE(t);let n=LS(t);return null!=this.maxValue&&(n=Iw(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}aR.className="ReLU",zb(aR);class oR extends lA{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=YE(t);return Yw(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}oR.className="LeakyReLU",zb(oR);class lR extends lA{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=qE(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=sR(t.alphaRegularizer),this.alphaConstraint=TA(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new fC(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=ZE(t)).slice(1);if(null!=this.sharedAxes)for(const t of this.sharedAxes)e[t-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let e=1;e<t.length;++e)n[e]=t[e];this.inputSpec=[new rA({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=YE(t),CS(t,this.alpha.read())}getConfig(){const t={alphaInitializer:jE(this.alphaInitializer),alphaRegularizer:rR(this.alphaRegularizer),alphaConstraint:kA(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}lR.className="PReLU",zb(lR);class uR extends lA{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new mC(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=YE(t);return Bw(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}uR.className="ELU",zb(uR);class cR extends lA{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=YE(t);return tS(n,ab(Xw(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}cR.className="ThresholdedReLU",zb(cR);class hR extends lA{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new qN).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=YE(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function dR(t,e,n){if("number"==typeof t)return vC(t,e);if(t.length!==e)throw new fC(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let i=0;i<e;++i){const s=t[i];if((r=s)!==parseInt(r.toString(),10))throw new fC(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${s}`)}return t;var r}function pR(t,e,n,r,i=1){if(null==t)return t;let s;return s="same"===n?t:t-(e+(e-1)*(i-1))+1,Math.floor((s+r-1)/r)}function fR(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+aE([n-e,0]);else{if("same"!==r)throw new fC(`Unsupport padding mode: ${r}.`);t*=e}return t}function mR(t,e){return Wb((()=>(XC(e),"channelsFirst"===e?i_(t,[0,2,3,1]):t)))}function gR(t,e){return Wb((()=>(XC(e),"channelsFirst"===e?i_(t,[0,2,3,4,1]):t)))}function xR(t,e,n,r=[1,1],i="valid",s,a,o=null){return Wb((()=>{if(null==s&&(s="channelsLast"),XC(s),3!==t.rank&&4!==t.rank)throw new fC(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new fC(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=mR(t,s);if("causal"===i)throw new mC("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=x_({x:l,filter:e,strides:r,pad:"same"===i?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=i_(l,[0,3,1,2])),l}))}hR.className="Softmax",zb(hR);class yR extends lA{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",yR.verifyArgs(e),this.rank=t,FC(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new mC(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=dR(e.kernelSize,t,"kernelSize"),this.strides=dR(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,KC(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,XC(this.dataFormat),this.activation=QN(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=qE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=TA(e.biasConstraint),this.biasRegularizer=sR(e.biasRegularizer),this.activityRegularizer=sR(e.activityRegularizer),this.dilationRate=dR(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new fC(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new fC(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new fC(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(bC("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!LC(t.kernelSize,"number",1,3))throw new fC(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ZN(this.activation),useBias:this.useBias,biasInitializer:jE(this.biasInitializer),biasRegularizer:rR(this.biasRegularizer),activityRegularizer:rR(this.activityRegularizer),biasConstraint:kA(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class vR extends yR{constructor(t,e){super(t,e),this.kernel=null,vR.verifyArgs(e),this.filters=e.filters,FC(this.filters,"filters"),this.kernelInitializer=qE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=TA(e.kernelConstraint),this.kernelRegularizer=sR(e.kernelRegularizer)}build(t){t=ZE(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new fC(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return Wb((()=>{let e;t=YE(t);const n=null==this.bias?null:this.bias.read(),r=PC(this.activation.getClassName());if(null!=r&&2===this.rank)e=xR(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=function(t,e,n,r=1,i="valid",s,a=1){return Wb((()=>{if(null==s&&(s="channelsLast"),XC(s),3!==t.shape.length)throw new fC(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new fC(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new fC(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===s&&(t=i_(t,[0,2,1])),"causal"===i)throw new mC("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Nw(t,e,r,"same"===i?"same":"valid","NWC",a);return null!=n&&(o=_E(o,n)),o}))}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=xR(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new mC("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,r=[1,1,1],i="valid",s,a){return Wb((()=>{if(null==s&&(s="channelsLast"),XC(s),4!==t.rank&&5!==t.rank)throw new fC(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new fC(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let o=gR(t,s);if("causal"===i)throw new mC("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Lw(o,e,r,"same"===i?"same":"valid","NDHWC",a),null!=n&&(o=_E(o,n)),"channelsFirst"===s&&(o=i_(o,[0,4,1,2,3])),o}))}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=ZE(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let t=0;t<n.length;++t){const r=pR(n[t],this.kernelSize[t],this.padding,this.strides[t],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[t]);e.push(r)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:jE(this.kernelInitializer),kernelRegularizer:rR(this.kernelRegularizer),kernelConstraint:kA(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new fC(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class bR extends vR{constructor(t){super(2,t),bR.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!LC(t.kernelSize,"number",1,2))throw new fC(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}bR.className="Conv2D",zb(bR);class wR extends vR{constructor(t){super(3,t),wR.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new fC(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}wR.className="Conv3D",zb(wR);class SR extends bR{constructor(t){if(super(t),this.inputSpec=[new rA({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new fC(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=ZE(t)).length)throw new fC("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new fC("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new rA({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return Wb((()=>{let e=YE(t);if(4!==e.shape.length)throw new fC(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape,r=n[0];let i,s;"channelsFirst"===this.dataFormat?(i=2,s=3):(i=1,s=2);const a=n[i],o=n[s],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],h=this.strides[1],d=[r,fR(a,c,l,this.padding),fR(o,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=i_(e,[0,2,3,1]));let p=Dw(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=i_(p,[0,3,1,2])),null!=this.bias&&(p=_E(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(t){const e=(t=ZE(t)).slice();let n,r,i;"channelsFirst"===this.dataFormat?(n=1,r=2,i=3):(n=3,r=1,i=2);const s=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=fR(e[r],o,s,this.padding),e[i]=fR(e[i],l,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}SR.className="Conv2DTranspose",zb(SR);class _R extends wR{constructor(t){if(super(t),this.inputSpec=[new rA({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new fC(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=ZE(t)).length)throw new fC("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new fC("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new rA({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return Wb((()=>{let e=YE(t);if(5!==e.shape.length)throw new fC(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape,r=n[0];let i,s,a;"channelsFirst"===this.dataFormat?(a=2,i=3,s=4):(a=1,i=2,s=3);const o=n[a],l=n[i],u=n[s],c=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,fR(o,p,c,this.padding),fR(l,f,h,this.padding),fR(u,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=i_(e,[0,2,3,4,1]));let x=$w(e,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(x=i_(x,[0,4,1,2,3])),null!==this.bias&&(x=_E(x,this.bias.read(),this.dataFormat)),null!==this.activation&&(x=this.activation.apply(x)),x}))}computeOutputShape(t){const e=(t=ZE(t)).slice();let n,r,i,s;"channelsFirst"===this.dataFormat?(n=1,r=2,i=3,s=4):(n=4,r=1,i=2,s=3);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[r]=fR(e[r],u,a,this.padding),e[i]=fR(e[i],c,o,this.padding),e[s]=fR(e[s],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}_R.className="Conv3DTranspose",zb(_R);class IR extends vR{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new fC("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new fC("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new fC(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=qE(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=sR(e.depthwiseRegularizer),this.depthwiseConstraint=TA(e.depthwiseConstraint),this.pointwiseInitializer=qE(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=sR(e.pointwiseRegularizer),this.pointwiseConstraint=TA(e.pointwiseConstraint)}build(t){if((t=ZE(t)).length<this.rank+2)throw new fC(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new fC(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),i=[];for(let t=0;t<this.rank;++t)i.push(1);i.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new rA({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return Wb((()=>{let e;if(t=YE(t),1===this.rank)throw new mC("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=i_(t,[0,2,3,1])),e=PS(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=_E(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=i_(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=jE(this.depthwiseInitializer),t.pointwiseInitializer=jE(this.pointwiseInitializer),t.depthwiseRegularizer=rR(this.depthwiseRegularizer),t.pointwiseRegularizer=rR(this.pointwiseRegularizer),t.depthwiseConstraint=kA(this.depthwiseConstraint),t.pointwiseConstraint=kA(this.pointwiseConstraint),t}}IR.className="SeparableConv";class kR extends IR{constructor(t){super(2,t)}}kR.className="SeparableConv2D",zb(kR);class MR extends vR{constructor(t){super(1,t),MR.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!LC(t.kernelSize,"number",1,1))throw new fC(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}MR.className="Conv1D",zb(MR);class TR extends lA{constructor(t){super(t),"number"==typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return Wb((()=>{if(t=YE(t),"channelsLast"===this.dataFormat){const e=fE(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return fE(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=fE(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return fE(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}TR.className="Cropping2D",zb(TR);class CR extends lA{constructor(t){var e;super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,XC(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,e=this.interpolation,DC(VC,"InterpolationFormat",e)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}{const e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return Wb((()=>{let e=YE(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=i_(e,[0,2,3,1]);const t=this.size[0]*n[2],r=this.size[1]*n[3],i="nearest"===this.interpolation?lI.resizeNearestNeighbor(e,[t,r]):lI.resizeBilinear(e,[t,r]);return i_(i,[0,3,1,2])}{const t=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?lI.resizeNearestNeighbor(e,[t,r]):lI.resizeBilinear(e,[t,r])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}CR.className="UpSampling2D",zb(CR);class ER extends yR{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=qE(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=TA(t.depthwiseConstraint),this.depthwiseRegularizer=sR(t.depthwiseRegularizer)}build(t){if((t=ZE(t)).length<4)throw new fC(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new fC(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Wb((()=>{let e=function(t,e,n=[1,1],r="valid",i,s){return Wb((()=>{null==i&&(i="channelsLast"),XC(i);let a=mR(t,i);if(4!==t.rank)throw new fC(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new fC(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=Pw(a,e,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===i&&(a=i_(a,[0,3,1,2])),a}))}(t=YE(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=_E(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=ZE(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=pR(e,this.kernelSize[0],this.padding,this.strides[0]),s=pR(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,i,s]:[t[0],i,s,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=jE(this.depthwiseInitializer),t.depthwiseRegularizer=rR(this.depthwiseRegularizer),t.depthwiseConstraint=kA(this.depthwiseRegularizer),t}}function AR(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new fC("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function i(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=i(e),constants:n=i(n)}}function NR(t,e,n,r=!1,i,s,a=!1,o=!1){return Wb((()=>{const l=e.shape.length;if(l<3)throw new fC(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(oE(2,l));if(e=i_(e,u),null!=s)throw new mC("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=ab(ab(i,"bool"),"float32")).rank===l-1&&(i=Vw(i,-1)),i=i_(i,u)),r&&(e=FS(e,0),null!=i&&(i=FS(i,0)));const c=[];let h,d=n;const p=e.shape[0],f=QS(e);let m,g;null!=i&&(m=QS(i));for(let e=0;e<p;++e){const n=f[e],r=Wb((()=>t(n,d)));if(null==i)h=r[0],d=r[1];else{const t=Wb((()=>{const t=m[e],n=eS(MS(t),t);return{output:Zb(tS(r[0],t),tS(d[0],n)),newStates:d.map(((e,i)=>Zb(tS(r[1][i],t),tS(e,n))))}}));h=t.output,d=t.newStates}o&&c.push(h)}return o&&(g=KS(c,1)),[h,g,d]}))}ER.className="DepthwiseConv2D",zb(ER);class RR extends lA{constructor(t){let e;if(super(t),null==t.cell)throw new fC("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new BR({cells:t.cell}):t.cell,null==e.stateSize)throw new fC("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new rA({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?oE(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((t=>null)):this.states_}setStates(t){this.states_=t}computeOutputShape(t){XE(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return Wb((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new mC("Constants support is not implemented in RNN yet.");XE(t)&&(t=t[0]);const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new rA({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let i;if(this.cell.build(r),i=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!ff(this.stateSpec.map((t=>t.shape[t.shape.length-1])),i))throw new fC(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map((t=>new rA({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t,e=!1){Wb((()=>{if(!this.stateful)throw new dC("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new fC("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>IS([n,t]))):this.states_=[IS([n,this.cell.stateSize])];else if(null==t)Vb(this.states_),null!=this.keptStates&&(Vb(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>IS([n,t]))):this.states_[0]=IS([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new fC(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):Vb(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,s=[n,i];if(!ff(r.shape,s))throw new fC(`State ${e} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[e]=r}}this.states_=this.states_.map((t=>Gb(t.clone())))}))}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const i=AR(t,n,r,this.numConstants);t=i.inputs,n=i.initialState,r=i.constants;let s=[],a=[];if(null!=n){e.initialState=n,s=s.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new rA({shape:t.shape}));a=a.concat(this.stateSpec)}if(null!=r&&(e.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof iA){const n=[t].concat(s),r=this.inputSpec.concat(a),i=this.inputSpec;this.inputSpec=r;const o=super.apply(n,e);return this.inputSpec=i,o}return super.apply(t,e)}call(t,e){return Wb((()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let i=null==e?null:e.initialState;t=YE(t),null==i&&(i=this.stateful?this.states_:this.getInitialState(t));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==s)throw new fC(`RNN Layer has ${s} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},o=NR(((t,e)=>{const n=this.cell.call([t].concat(e),a);return[n[0],n.slice(1)]}),t,i,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h}))}getInitialState(t){return Wb((()=>{let e=IS(t.shape);return e=nS(e,[1,2]),e=hE(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?xE(e,[1,t]):e)):this.cell.stateSize>1?[xE(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===RR.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){const r=zA(e.cell,n);return new t(Object.assign(e,{cell:r}))}}RR.className="RNN",zb(RR);class DR extends lA{}class LR extends DR{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,FC(this.units,"units"),this.activation=QN(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=qE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=qE(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=qE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=sR(t.kernelRegularizer),this.recurrentRegularizer=sR(t.recurrentRegularizer),this.biasRegularizer=sR(t.biasRegularizer),this.kernelConstraint=TA(t.kernelConstraint),this.recurrentConstraint=TA(t.recurrentConstraint),this.biasConstraint=TA(t.biasConstraint),this.dropout=sE([1,aE([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=sE([1,aE([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ZE(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Wb((()=>{if(2!==t.length)throw new fC(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const r=null!=e.training&&e.training;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=UR({ones:()=>MS(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=UR({ones:()=>MS(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;i=vE(null!=s?tS(t,s):t,this.kernel.read()),null!=this.bias&&(i=_E(i,this.bias.read())),null!=a&&(n=tS(n,a));let o=Zb(i,vE(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:ZN(this.activation),useBias:this.useBias,kernelInitializer:jE(this.kernelInitializer),recurrentInitializer:jE(this.recurrentInitializer),biasInitializer:jE(this.biasInitializer),kernelRegularizer:rR(this.kernelRegularizer),recurrentRegularizer:rR(this.recurrentRegularizer),biasRegularizer:rR(this.biasRegularizer),activityRegularizer:rR(this.activityRegularizer),kernelConstraint:kA(this.kernelConstraint),recurrentConstraint:kA(this.recurrentConstraint),biasConstraint:kA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}LR.className="SimpleRNNCell",zb(LR);class FR extends RR{constructor(t){t.cell=new LR(t),super(t)}call(t,e){return Wb((()=>{null!=this.cell.dropoutMask&&(Vb(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Vb(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,i=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})}))}static fromConfig(t,e){return new t(e)}}FR.className="SimpleRNN",zb(FR);class $R extends DR{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new fC("GRUCell does not support reset_after parameter set to true.");this.units=t.units,FC(this.units,"units"),this.activation=QN(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=QN(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=qE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=qE(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=qE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=sR(t.kernelRegularizer),this.recurrentRegularizer=sR(t.recurrentRegularizer),this.biasRegularizer=sR(t.biasRegularizer),this.kernelConstraint=TA(t.kernelConstraint),this.recurrentConstraint=TA(t.recurrentConstraint),this.biasConstraint=TA(t.biasConstraint),this.dropout=sE([1,aE([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=sE([1,aE([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=ZE(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return Wb((()=>{if(2!==t.length)throw new fC(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=UR({ones:()=>MS(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=UR({ones:()=>MS(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,s=this.recurrentDropoutMask;let a,o,l;0<this.dropout&&this.dropout<1&&(t=tS(t,i[0]));let u=vE(t,this.kernel.read());this.useBias&&(u=_E(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=tS(r,s[0]));const c=this.recurrentKernel.read(),[h,d]=jS(c,[2*this.units,this.units],c.rank-1),p=vE(r,h),[f,m,g]=jS(u,3,u.rank-1),[x,y]=jS(p,2,p.rank-1);a=this.recurrentActivation.apply(Zb(f,x)),o=this.recurrentActivation.apply(Zb(m,y));const v=vE(tS(o,r),d);l=this.activation.apply(Zb(g,v));const b=Zb(tS(a,r),tS(Zb(1,wS(a)),l));return[b,b]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:ZN(this.activation),recurrentActivation:ZN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:jE(this.kernelInitializer),recurrentInitializer:jE(this.recurrentInitializer),biasInitializer:jE(this.biasInitializer),kernelRegularizer:rR(this.kernelRegularizer),recurrentRegularizer:rR(this.recurrentRegularizer),biasRegularizer:rR(this.biasRegularizer),activityRegularizer:rR(this.activityRegularizer),kernelConstraint:kA(this.kernelConstraint),recurrentConstraint:kA(this.recurrentConstraint),biasConstraint:kA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}$R.className="GRUCell",zb($R);class PR extends RR{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new $R(t),super(t)}call(t,e){return Wb((()=>{null!=this.cell.dropoutMask&&(Vb(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Vb(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,i=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}PR.className="GRU",zb(PR);class OR extends DR{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,FC(this.units,"units"),this.activation=QN(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=QN(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=qE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=qE(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=qE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=sR(t.kernelRegularizer),this.recurrentRegularizer=sR(t.recurrentRegularizer),this.biasRegularizer=sR(t.biasRegularizer),this.kernelConstraint=TA(t.kernelConstraint),this.recurrentConstraint=TA(t.recurrentConstraint),this.biasConstraint=TA(t.biasConstraint),this.dropout=sE([1,aE([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=sE([1,aE([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const n=(t=ZE(t))[t.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,n=this.units;r=new((e=class extends CE{apply(e,r){const i=t.apply([n]),s=(new AE).apply([n]),a=t.apply([2*n]);return gE(gE(i,s),a)}}).className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return Wb((()=>{const n=null!=e.training&&e.training;if(3!==t.length)throw new fC(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=UR({ones:()=>MS(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=UR({ones:()=>MS(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(t=tS(t,s[0]));let h=vE(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=tS(r,a[0])),h=Zb(h,vE(r,this.recurrentKernel.read())),this.useBias&&(h=_E(h,this.bias.read()));const[d,p,f,m]=jS(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),u=Zb(tS(l,i),tS(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=tS(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:ZN(this.activation),recurrentActivation:ZN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:jE(this.kernelInitializer),recurrentInitializer:jE(this.recurrentInitializer),biasInitializer:jE(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:rR(this.kernelRegularizer),recurrentRegularizer:rR(this.recurrentRegularizer),biasRegularizer:rR(this.biasRegularizer),activityRegularizer:rR(this.activityRegularizer),kernelConstraint:kA(this.kernelConstraint),recurrentConstraint:kA(this.recurrentConstraint),biasConstraint:kA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}OR.className="LSTMCell",zb(OR);class zR extends RR{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new OR(t),super(t)}call(t,e){return Wb((()=>{null!=this.cell.dropoutMask&&(Vb(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Vb(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,i=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}zR.className="LSTM",zb(zR);class BR extends DR{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return Wb((()=>{let n=t.slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const i=[];let s;for(let a=0;a<this.cells.length;++a){const o=this.cells[a];n=r[a],s=0===a?[t[0]].concat(n):[s[0]].concat(n),s=o.call(s,e),i.push(s.slice(1))}n=[];for(const t of i.slice().reverse())n.push(...t);return[s[0]].concat(n)}))}build(t){let e;XE(t)&&(t=t[0]),this.cells.forEach(((n,r)=>{QC(`RNNCell_${r}`,(()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign({},t,e)}static fromConfig(t,e,n={}){const r=[];for(const t of e.cells)r.push(zA(t,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return eA(t)}setWeights(t){const e=[];for(const n of this.cells){const r=n.weights.length,i=t.splice(r);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],i[t]])}nA(e)}}function UR(t){const{ones:e,rate:n,training:r=!1,count:i=1,dropoutFunc:s}=t,a=()=>null!=s?s(e(),n):IE(e(),n),o=()=>kE(a,e,r);return!i||i<=1?Gb(o().clone()):Array(i).fill(void 0).map(o).map((t=>Gb(t.clone())))}BR.className="StackedRNNCells",zb(BR);var WR,VR,GR,HR;class jR extends RR{constructor(t){if(t.unroll)throw new mC("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new mC("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new rA({ndim:5})]}call(t,e){return Wb((()=>{if(null!=this.cell.dropoutMask&&(Vb(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Vb(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new fC("ConvRNN2D cell does not support constants");const n=null==e?null:e.mask,r=null==e?null:e.training,i=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:i})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return Wb((()=>{const{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),i=IS([r[0],...r.slice(2)]);return Array.isArray(e)?Array(e.length).fill(i):[i]}))}resetStates(t,e=!1){Wb((()=>{if(!this.stateful)throw new dC("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)];if(null==n[0])throw new fC("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>IS(i))):this.states_=[IS(i)];else if(null==t)Vb(this.states_),null!=this.keptStates&&(Vb(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>IS(i))):this.states_[0]=IS(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new fC(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Vb(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=i;if(!ff(n.shape,r))throw new fC(`State ${e} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[e]=n}}this.states_=this.states_.map((t=>Gb(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:r,padding:i,strides:s,dilationRate:a}=this.cell,o="channelsFirst"===e,l=t[o?3:2],u=t[o?4:3],c=pR(l,r[0],i,s[0],a[0]),h=pR(u,r[1],i,s[1],a[1]);return[...t.slice(0,2),...o?[n,c,h]:[c,h,n]]}}jR.className="ConvRNN2D";class qR extends OR{constructor(t){const{filters:e,kernelSize:n,strides:r,padding:i,dataFormat:s,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,FC(this.filters,"filters"),this.kernelSize=dR(n,2,"kernelSize"),this.kernelSize.forEach((t=>FC(t,"kernelSize"))),this.strides=dR(r||1,2,"strides"),this.strides.forEach((t=>FC(t,"strides"))),this.padding=i||"valid",KC(this.padding),this.dataFormat=s||"channelsLast",XC(this.dataFormat),this.dilationRate=dR(a||1,2,"dilationRate"),this.dilationRate.forEach((t=>FC(t,"dilationRate")))}build(t){var e;t=ZE(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new fC(`The channel dimension of the input should be defined. Found ${t[n]}`);const r=t[n],i=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;t=new((e=class extends CE{apply(t,e){return mE([n.apply([r]),kS([r]),n.apply([2*r])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return Wb((()=>{if(3!==t.length)throw new fC(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training||!1,r=t[0],i=t[1],s=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=UR({ones:()=>MS(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=(t,e,n)=>e&&e[n]?tS(e[n],t):t;let l=o(r,a,0),u=o(r,a,1),c=o(r,a,2),h=o(r,a,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=UR({ones:()=>MS(i),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=o(i,d,0),f=o(i,d,1),m=o(i,d,2),g=o(i,d,3);const[x,y,v,b]=jS(this.kernel.read(),4,3),[w,S,_,I]=this.useBias?jS(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,x,w,this.padding),u=this.inputConv(u,y,S,this.padding),c=this.inputConv(c,v,_,this.padding),h=this.inputConv(h,b,I,this.padding);const[k,M,T,C]=jS(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,k),f=this.recurrentConv(f,M),m=this.recurrentConv(m,T),g=this.recurrentConv(g,C);const E=this.recurrentActivation.apply(Zb(l,p)),A=this.recurrentActivation.apply(Zb(u,f)),N=Zb(tS(A,s),tS(E,this.activation.apply(Zb(c,m)))),R=tS(this.recurrentActivation.apply(Zb(h,g)),this.activation.apply(N));return[R,R,N]}))}getConfig(){const t=super.getConfig(),{units:e}=t,n=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(t);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(t,r[i])&&(n[r[i]]=t[r[i]])}return n}(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(t,e,n,r){const i=Aw(t,e,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?_E(i,n,this.dataFormat):i}recurrentConv(t,e){return Aw(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}qR.className="ConvLSTM2DCell",zb(qR);class XR extends jR{constructor(t){const e=new qR(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}XR.className="ConvLSTM2D",zb(XR);class KR extends lA{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let t=0;t<this.noiseShape.length;++t)n.push(null==this.noiseShape[t]?e[t]:this.noiseShape[t]);return n}call(t,e){return Wb((()=>{this.invokeCallHook(t,e);const n=YE(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return kE((()=>IE(n,this.rate,r,this.seed)),(()=>n),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}KR.className="Dropout",zb(KR);class YR extends KR{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}YR.className="SpatialDropout1D",zb(YR);class ZR extends lA{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,FC(this.units,"units"),this.activation=QN(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=qE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=qE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=TA(t.kernelConstraint),this.biasConstraint=TA(t.biasConstraint),this.kernelRegularizer=sR(t.kernelRegularizer),this.biasRegularizer=sR(t.biasRegularizer),this.activityRegularizer=sR(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=ZE(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=ZE(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return Wb((()=>{this.invokeCallHook(t,e);const n=YE(t),r=PC(this.activation.getClassName());let i;return null!=r?i=vE(n,this.kernel.read(),r,this.bias?this.bias.read():null):(i=vE(n,this.kernel.read()),null!=this.bias&&(i=_E(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i}))}getConfig(){const t={units:this.units,activation:ZN(this.activation),useBias:this.useBias,kernelInitializer:jE(this.kernelInitializer),biasInitializer:jE(this.biasInitializer),kernelRegularizer:rR(this.kernelRegularizer),biasRegularizer:rR(this.biasRegularizer),activityRegularizer:rR(this.activityRegularizer),kernelConstraint:kA(this.kernelConstraint),biasConstraint:kA(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}ZR.className="Dense",zb(ZR);class JR extends lA{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=ZE(t);for(const e of t.slice(1))if(null==e)throw new fC(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],iE(t,1)]}call(t,e){return Wb((()=>{this.invokeCallHook(t,e);let n=YE(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=i_(n,t)}return function(t){if(t.rank<=1)throw new fC(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],iE(t.shape,1)];return mw(t,e)}(n)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}JR.className="Flatten",zb(JR);class QR extends lA{constructor(t){super(t),this.supportsMasking=!0,this.activation=QN(t.activation)}call(t,e){return Wb((()=>{this.invokeCallHook(t,e);const n=YE(t);return this.activation.apply(n)}))}getConfig(){const t={activation:ZN(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}QR.className="Activation",zb(QR);class tD extends lA{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return Wb((()=>{return t=YE(t),e=t,n=this.n,Wb((()=>{if(2!==e.shape.length)throw new fC(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return xE(hE(e,1),[1,n,1])}));var e,n}))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}tD.className="RepeatVector",zb(tD);class eD extends lA{constructor(t){super(t),this.targetShape=t.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let i=1,s=null;for(let t=0;t<r.length;++t){const e=r[t];if(this.isUnknown(e)){if(null!==s)throw new fC("Can only specifiy one unknown dimension.");s=t}else i*=e}const a=iE(t);if(null!==s){if(0===i||a%i!=0)throw new fC(n);r[s]=a/i}else if(a!==i)throw new fC(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return Wb((()=>{this.invokeCallHook(t,e);const n=YE(t),r=n.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return mw(n,i)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}eD.className="Reshape",zb(eD);class nD extends lA{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=oE(1,t.dims.length+1);if(!ff(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new rA({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=ZE(t)).slice();return this.dims.forEach(((n,r)=>{e[r+1]=t[n]})),e}call(t,e){return i_(YE(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}nD.className="Permute",zb(nD);class rD extends lA{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=YE(t);return Qb(SS(n,this.maskValue),-1)}call(t,e){return Wb((()=>{this.invokeCallHook(t,e);const n=YE(t),r=Qb(SS(n,this.maskValue),-1,!0);return tS(n,ab(r,n.dtype))}))}}rD.className="Masking",zb(rD);class iD extends lA{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(_C(t.inputLength))}this.inputDim=t.inputDim,FC(this.inputDim,"inputDim"),this.outputDim=t.outputDim,FC(this.outputDim,"outputDim"),this.embeddingsInitializer=qE(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=sR(t.embeddingsRegularizer),this.activityRegularizer=sR(t.activityRegularizer),this.embeddingsConstraint=TA(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return Wb((()=>this.maskZero?(t=YE(t),SS(t,e_(t))):null))}computeOutputShape(t){if(t=ZE(t),null==this.inputLength)return[...t,this.outputDim];const e=_C(this.inputLength);if(e.length!==t.length-1)throw new fC(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let r=0;r<e.length;++r){const i=e[r],s=t[r+1];if(null!=i&&null!=s&&i!==s)throw new fC(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==i&&(e[n]=s),n++}}return[t[0],...e,this.outputDim]}call(t,e){return Wb((()=>{this.invokeCallHook(t,e);let n=YE(t);"int32"!==n.dtype&&(n=cE(n,"int32"));const r=bE(this.embeddings.read(),mw(n,[n.size]));return mw(r,ZE(this.computeOutputShape(n.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:jE(this.embeddingsInitializer),embeddingsRegularizer:rR(this.embeddingsRegularizer),activityRegularizer:rR(this.activityRegularizer),embeddingsConstraint:kA(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}iD.className="Embedding",zb(iD);class sD extends lA{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new mC}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const i=t[t.length-e.length+r],s=e[r];if(null==i||null==s||i<0||s<0)n.push(null);else if(1===i)n.push(s);else if(1===s)n.push(i);else{if(i!==s)throw new fC("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(i)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[ZE(t)]),t.length<2)throw new fC(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const n of t)null!=n&&null!==n[0]&&e.push(n[0]);if(e=NC(e),e.length>1)throw new fC(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let e=1;e<t.length;++e){const r=null==t[e]?null:t[e].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=t.map((t=>t.length));-1===t.indexOf(null)&&1===NC(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return Wb((()=>{if(this.reshapeRequired){const e=[],n=t.map((t=>t.rank));if(-1===n.indexOf(null)){const r=aE(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=hE(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const r of t){const t=r.rank;if(null==t){const t=r.shape,i=t[0],s=t.slice(1).concat([i]);let a=mw(r,[i].concat(iE(t.slice(1))));a=i_(a,[1,0]),a=mw(a,s),e.push(a),n=!0}else if(t>1){const i=oE(1,t).concat([0]);e.push(i_(r,i)),n=!0}else e.push(r)}let r=this.mergeFunction(e);const i=r.rank;if(n)if(null==i){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=mw(i_(mw(r,[-1,e]),[1,0]),n)}else if(i>1){const t=[i-1].concat(oE(0,i-1));r=i_(r,t)}return r}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let n=1;n<t.length;++n){const r=null==t[n]?null:t[n].slice(1);e=this.computeElementwiseOpOutputShape(e,r)}let n=[];for(const e of t)null!=e&&null!==e[0]&&n.push(e[0]);return n=NC(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return Wb((()=>{if(null==e)return null;if(!Array.isArray(e))throw new fC("`mask` should be an Array");if(!Array.isArray(t))throw new fC("`inputs` should be an Array");if(e.length!==t.length)throw new fC(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every((t=>null==t)))return null;let n=(e=e.map((t=>null==t?t:Vw(t,0))))[0];for(let t=1;t<e.length-1;++t)n=iS(n,e[t]);return n}))}}class aD extends sD{constructor(t){super(t)}mergeFunction(t){return Wb((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Zb(e,t[n]);return e}))}}aD.className="Add",zb(aD);class oD extends sD{constructor(t){super(t)}mergeFunction(t){return Wb((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=tS(e,t[n]);return e}))}}oD.className="Multiply",zb(oD);class lD extends sD{constructor(t){super(t)}mergeFunction(t){return Wb((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Zb(e,t[n]);return tS(1/t.length,e)}))}}lD.className="Average",zb(lD);class uD extends sD{constructor(t){super(t)}mergeFunction(t){return Wb((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=lS(e,t[n]);return e}))}}uD.className="Maximum",zb(uD);class cD extends sD{constructor(t){super(t)}mergeFunction(t){return Wb((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=cS(e,t[n]);return e}))}}cD.className="Minimum",zb(cD);class hD extends sD{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new fC("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const n of t)if(null!=n){e=!1;break}if(e)return;const n=[];for(let e=0;e<t.length;++e){const r=t[e].slice();r.splice(this.axis,1);let i=!1;for(const t of n)if(ff(t,r)){i=!0;break}i||n.push(r)}if(n.length>1)throw new fC("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return Wb((()=>mE(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new fC("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const t of e.slice(1)){if(null==n[r]||null==t[r]){n[r]=null;break}n[r]+=t[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new fC("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new fC("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new fC(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return Wb((()=>{let n=!0;if(e.forEach((t=>{null==t||(n=!1)})),n)return null;const r=[];for(let n=0;n<t.length;++n)null==e[n]?r.push(ab(MS(t[n]),"bool")):e[n].rank<t[n].rank?r.push(Vw(e[n],-1)):r.push(e[n]);const i=kw(r,this.axis);return Jb(i,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function dD(t,e){for(;t<0;)t+=e;return t}hD.className="Concatenate",zb(hD);class pD extends sD{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){uf(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new mC("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new fC(`Dimension incompatibility: ${e[r[0]]} !== ${n[r[1]]}`)}mergeFunction(t){if(2!==t.length)throw new fC(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,n)=>dD(e,t[n].shape.length))):[dD(this.axes,n.shape.length),dD(this.axes,r.shape.length)],this.normalize&&(n=BA(n,e[0]),r=BA(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new mC("batchDot is not implemented for tensors of 4D or higher rank yet");if(uf(t.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`)),uf(t.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new mC("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,i=e.shape.length;null==n&&(n=[r-1,i-2]);const s=n;return Wb((()=>{let n,a;if(r>i){n=r-i;const t=[];for(let e=0;e<n;++e)t.push(1);e=mw(e,e.shape.concat(t))}else if(i>r){n=i-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=mw(t,t.shape.concat(e))}else n=0;if(2===t.shape.length&&2===e.shape.length)a=s[0]===s[1]?nS(tS(t,e),s[0]):nS(tS(i_(t,[1,0]),e),s[1]);else{const n=s[0]!==t.shape.length-1,r=s[1]===e.shape.length-1;a=sS(t,e,n,r)}if(n>0){let t;t=r>i?r+i-3:r-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);a=XS(a,e)}return 1===a.shape.length&&(a=Vw(a,1)),a}))}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[dD(this.axes,t.length),dD(this.axes,e.length)],n}computeOutputShape(t){uf(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new mC("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const i=e.concat(n);return 1===i.length&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}pD.className="Dot",zb(pD);class fD extends lA{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return Wb((()=>{this.invokeCallHook(t,e);const n=YE(t);return kE((()=>Zb(yE(n.shape,0,this.stddev),n)),(()=>n),e.training||!1)}))}}fD.className="GaussianNoise",zb(fD);class mD extends lA{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Wb((()=>{this.invokeCallHook(t,e);const n=YE(t);return this.rate>0&&this.rate<1?kE((()=>{const t=Math.sqrt(this.rate/(1-this.rate));return tS(n,yE(n.shape,1,t))}),(()=>n),e.training||!1):n}))}}mD.className="GaussianDropout",zb(mD);class gD extends lA{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||YE(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return Wb((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return kE((()=>{const e=YE(t),r=-1.7580993408473766;let i=Kw(DS(n),this.rate);i=cE(i,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,a=-s*r*this.rate,o=Zb(tS(e,i),tS(Zb(i,-1),r));return Zb(tS(o,s),a)}),(()=>YE(t)),e.training||!1)}return t}))}}function xD(t,e,n,r,i,s=.001){let a;if(2===t.rank)a=vw(t,e,n,r,i,s);else if(3===t.rank)a=bw(t,e,n,r,i,s);else{if(4!==t.rank)throw new mC(`batchNormalization is not implemented for array of rank ${t.rank} yet`);a=ww(t,e,n,r,i,s)}return a}gD.className="AlphaDropout",zb(gD);class yD extends lA{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=qE(t.betaInitializer||"zeros"),this.gammaInitializer=qE(t.gammaInitializer||"ones"),this.movingMeanInitializer=qE(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=qE(t.movingVarianceInitializer||"ones"),this.betaConstraint=TA(t.betaConstraint),this.gammaConstraint=TA(t.gammaConstraint),this.betaRegularizer=sR(t.betaRegularizer),this.gammaRegularizer=sR(t.gammaRegularizer)}build(t){t=ZE(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new fC(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new rA({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return Wb((()=>{const n=null!=e.training&&e.training,r=YE(t),i=r.shape,s=i.length,a=oE(0,s),o=this.axis>=0?this.axis:this.axis+s;a.splice(o,1);const l=vC(1,s);l[o]=i[o];const u=a.slice();u.sort();const c=!ff(u,oE(0,s).slice(0,s-1));if(!n)return(()=>{if(c){const t=mw(this.movingMean.read(),l),e=mw(this.movingVariance.read(),l),n=this.center?mw(this.beta.read(),l):null,i=this.scale?mw(this.gamma.read(),l):null;return xD(r,t,e,n,i,this.epsilon)}return xD(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=function(t,e,n,r,i=.001){return ff(r.slice().sort(),oE(0,t.rank-1))?function(t,e,n,r,i=.001){return Wb((()=>{const s=bS(t,r),a=s.mean,o=s.variance;return[xD(t,a,o,n,e,i),a,o]}))}(t,e,n,r,i):function(t,e,n,r,i=.001){return Wb((()=>{const s=bS(t,r),a=s.mean,o=s.variance,l=[];for(const e of oE(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const u=mw(a,l),c=mw(o,l),h=null==e?null:mw(e,l),d=null==n?null:mw(n,l);return[xD(t,u,c,d,h,i),a,o]}))}(t,e,n,r,i)}(r,this.gamma.read(),this.beta.read(),a,this.epsilon),f=(t,e,n)=>{Wb((()=>{const r=1-n,i=t.read(),s=tS(eS(i,e),r);t.write(eS(i,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:jE(this.betaInitializer),gammaInitializer:jE(this.gammaInitializer),movingMeanInitializer:jE(this.movingMeanInitializer),movingVarianceInitializer:jE(this.movingVarianceInitializer),betaRegularizer:rR(this.betaRegularizer),gammaRegularizer:rR(this.gammaRegularizer),betaConstraint:kA(this.betaConstraint),gammaConstraint:kA(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}yD.className="BatchNormalization",zb(yD);class vD extends lA{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=qE(t.betaInitializer||"zeros"),this.gammaInitializer=qE(t.gammaInitializer||"ones"),this.betaRegularizer=sR(t.betaRegularizer),this.gammaRegularizer=sR(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=ZE(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let t=0;t<this.axis.length;++t)this.axis[t]<0&&(this.axis[t]+=e);for(const t of this.axis)if(t<0||t>=e)throw new Error(`Invalid axis: ${t}`);if(this.axis.length!==NC(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(t,e){const n=YE(t),r=n.shape,i=r.length;return Wb((()=>{let{mean:t,variance:e}=bS(n,this.axis,!0);const s=vC(1,i);for(const t of this.axis)s[t]=r[t];const a=t=>null!=t&&t.shape.length!==i?mw(t,s):t;let o=this.scale?a(this.gamma.read()):null,l=this.center?a(this.beta.read()):null;const u=[],c=[];for(let t=0;t<i;++t)-1!==this.axis.indexOf(t)?(u.push(r[t]),c.push(1)):(u.push(1),c.push(r[t]));return t=Gw(t,u),e=Gw(e,u),null!=o&&(o=Gw(o,c)),null!=l&&(l=Gw(l,c)),xD(n,t,e,l,o,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:jE(this.betaInitializer),gammaInitializer:jE(this.gammaInitializer),betaRegularizer:rR(this.betaRegularizer),gammaRegularizer:rR(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}vD.className="LayerNormalization",zb(vD);class bD extends lA{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new fC(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new fC(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new fC(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new rA({ndim:4})]}computeOutputShape(t){let e,n;return t=ZE(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return Wb((()=>{return e=YE(t),n=this.padding,r=this.dataFormat,Wb((()=>{if(4!==e.rank)throw new fC(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new fC("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new fC(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],TS(e,t)}));var e,n,r}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function wD(t,e,n,r,i,s){return Wb((()=>{let a;XC(i),YC(s),KC(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),t=mR(t,i);const o="same"===r?"same":"valid";return a="max"===s?aS(t,e,n,o):gw(t,e,n,o),"channelsFirst"===i&&(a=i_(a,[0,3,1,2])),a}))}function SD(t,e,n,r,i,s){return Wb((()=>{let a;XC(i),YC(s),KC(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),t=gR(t,i);const o="same"===r?"same":"valid";return a="max"===s?oS(t,e,n,o):xw(t,e,n,o),"channelsFirst"===i&&(a=i_(a,[0,4,1,2,3])),a}))}bD.className="ZeroPadding2D",zb(bD);class _D extends lA{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new fC(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(FC(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new fC(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}FC(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,KC(this.padding),this.inputSpec=[new rA({ndim:3})]}computeOutputShape(t){const e=pR((t=ZE(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return Wb((()=>{this.invokeCallHook(t,e),t=hE(YE(t),2);const n=this.poolingFunction(YE(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return XS(n,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class ID extends _D{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return XC(i),KC(r),wD(t,e,n,r,i,"max")}}ID.className="MaxPooling1D",zb(ID);class kD extends _D{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return XC(i),KC(r),wD(t,e,n,r,i,"avg")}}kD.className="AveragePooling1D",zb(kD);class MD extends lA{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new fC(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];FC(this.poolSize,"poolSize"),FC(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,XC(this.dataFormat),KC(this.padding),this.inputSpec=[new rA({ndim:4})]}computeOutputShape(t){t=ZE(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=pR(e,this.poolSize[0],this.padding,this.strides[0]),n=pR(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return Wb((()=>(this.invokeCallHook(t,e),this.poolingFunction(YE(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class TD extends MD{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return XC(i),KC(r),wD(t,e,n,r,i,"max")}}TD.className="MaxPooling2D",zb(TD);class CD extends MD{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return XC(i),KC(r),wD(t,e,n,r,i,"avg")}}CD.className="AveragePooling2D",zb(CD);class ED extends lA{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new fC(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];FC(this.poolSize,"poolSize"),FC(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,XC(this.dataFormat),KC(this.padding),this.inputSpec=[new rA({ndim:5})]}computeOutputShape(t){t=ZE(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=pR(e,this.poolSize[0],this.padding,this.strides[0]),n=pR(n,this.poolSize[1],this.padding,this.strides[1]),r=pR(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return Wb((()=>(this.invokeCallHook(t,e),this.poolingFunction(YE(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class AD extends ED{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return XC(i),KC(r),SD(t,e,n,r,i,"max")}}AD.className="MaxPooling3D",zb(AD);class ND extends ED{constructor(t){super(t)}poolingFunction(t,e,n,r,i){return XC(i),KC(r),SD(t,e,n,r,i,"avg")}}ND.className="AveragePooling3D",zb(ND);class RD extends lA{constructor(t){super(t),this.inputSpec=[new rA({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new mC}}class DD extends RD{constructor(t){super(t||{})}call(t,e){return Wb((()=>{const e=YE(t);return uS(e,1)}))}}DD.className="GlobalAveragePooling1D",zb(DD);class LD extends RD{constructor(t){super(t||{})}call(t,e){return Wb((()=>{const e=YE(t);return Qw(e,1)}))}}LD.className="GlobalMaxPooling1D",zb(LD);class FD extends lA{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,XC(this.dataFormat),this.inputSpec=[new rA({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new mC}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class $D extends FD{call(t,e){return Wb((()=>{const e=YE(t);return"channelsLast"===this.dataFormat?uS(e,[1,2]):uS(e,[2,3])}))}}$D.className="GlobalAveragePooling2D",zb($D);class PD extends FD{call(t,e){return Wb((()=>{const e=YE(t);return"channelsLast"===this.dataFormat?Qw(e,[1,2]):Qw(e,[2,3])}))}}PD.className="GlobalMaxPooling2D",zb(PD);class OD extends lA{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const r=zA(e.layer,n);delete e.layer;const i={layer:r};return Object.assign(i,e),new t(i)}}class zD extends OD{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=ZE(t)).length<3)throw new fC(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=ZE(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return Wb((()=>NR(((t,n)=>[YE(this.layer.call(t,e)),[]]),t=YE(t),[],!1,null,null,!1,!0)[1]))}}zD.className="TimeDistributed",zb(zD);class BD extends OD{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=zA(n),e.goBackwards=!0!==e.goBackwards;const r={};var i;if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=zA(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,i=this.mergeMode,DC(jC,"BidirectionalMergeMode",i),t.weights)throw new mC("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e,n,r,i=this.forwardLayer.computeOutputShape(t);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),this.returnState?(r=i.slice(1),e=i[0]):e=i[0],"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):SC(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const i=AR(t,n,r,this.numConstants);if(t=i.inputs,n=i.initialState,r=i.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const s=[],a=[];if(null!=n){const t=n.length;if(t%2>0)throw new fC("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,s.push(...n);const r=n.map((t=>new rA({shape:t.shape})));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),a.push(...r)}if(null!=r)throw new mC("Support for constants in Bidirectional layers is not implemented yet.");const o=s[0]instanceof iA;for(const t of s)if(t instanceof iA!==o)throw new fC("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[t].concat(s),r=this.inputSpec.concat(a),i=this.inputSpec;this.inputSpec=r;const o=super.apply(n,e);return this.inputSpec=i,o}return super.apply(t,e)}call(t,e){return Wb((()=>{const n=e.initialState;let r,i,s,a;if(null==n)r=this.forwardLayer.call(t,e),i=this.backwardLayer.call(t,e);else{const s=n.slice(0,n.length/2),a=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:s})),i=this.backwardLayer.call(t,Object.assign(e,{initialState:a}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=FS(i,1)),"concat"===this.mergeMode?a=mE([r,i]):"sum"===this.mergeMode?a=Zb(r,i):"ave"===this.mergeMode?a=tS(.5,Zb(r,i)):"mul"===this.mergeMode?a=tS(r,i):null==this.mergeMode&&(a=[r,i]),this.returnState?null==this.mergeMode?a.concat(s):[a].concat(s):a}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){QC(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),QC(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=zA(e.layer);if(delete e.layer,null!=e.numConstants)throw new mC("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}BD.className="Bidirectional",zb(BD);class UD extends lA{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return Wb((()=>("float32"!==(t=YE(t)).dtype&&(t=cE(t,"float32")),Zb(tS(t,this.scale),this.offset))))}}function WD(t,e,n=new Map,r=new Set){if(null==t)return null;if("function"==typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(jD(t)){const i=Array.isArray(t)?[]:{};r.add(t);for(const s in t){const a=WD(t[s],e,n,r);i[s]=a}return r.delete(t),t.__proto__&&(i.__proto__=t.__proto__),i}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return n.set(t,i.value),i.value}function VD(t,e=HD){return GD(t,e)}function GD(t,e,n=new Set){const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(jD(r)){const i=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=GD(t.map((t=>t[s])),e,n);i[s]=r}return n.delete(r),i}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return i.value}function HD(t){return null===t?null:jD(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function jD(t){let e=!1;if(Hf().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:r}=n(977);e=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof Hy)&&!(t instanceof Promise)&&!e)}function qD(t){return WD(t,XD)}function XD(t){return t instanceof Hy?{value:t.clone(),recurse:!1}:jD(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}UD.className="Rescaling",zb(UD),Hf().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"}(WR||(WR={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(VR||(VR={}));class KD{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class YD extends KD{constructor(){super(YD.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let t=0;t<n;t++)e[t]=this.get(this.wrap(this.begin+t));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}YD.INITIAL_CAPACITY=32;class ZD{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new aL(this,t)}filter(t){return new iL(this,t)}map(t){return new sL(this,t)}mapAsync(t){return new oL(this,t)}serialMapAsync(t){return new oL(this,t).serial()}flatmap(t){return new uL(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t,e=!0){return new rL(this,t,e)}columnMajorBatch(t,e=!0,n=HD){return this.rowMajorBatch(t,e).map((t=>VD(t,n)))}concatenate(t,e){return new cL(new JD([this,t]),e)}take(t){return t<0||null==t?this:new nL(this,t)}skip(t){return t<0||null==t?this:new eL(this,t)}prefetch(t){return new hL(this,t)}shuffle(t,e){return new dL(this,t,e)}serial(){return new tL(this)}}class JD extends ZD{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:qD(t),done:!1}}}class QD extends ZD{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class tL extends ZD{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class eL extends ZD{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;Vb(t.value)}return this.upstream.next()}}class nL extends ZD{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class rL extends ZD{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class iL extends ZD{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;Vb(t.value)}}}class sL extends ZD{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=iv(t.value),n=this.transform(t.value),r=iv(n);for(const t of e)rv(t,r)||t.dispose();return{value:n,done:!1}}}class aL extends ZD{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class oL extends ZD{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=iv(t.value),n=await this.transform(t.value),r=iv(n);for(const t of e)rv(t,r)||t.dispose();return{value:n,done:!1}}}class lL extends ZD{constructor(){super(),this.outputQueue=new YD,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class uL extends lL{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=iv(t.value),n=this.transform(t.value),r=iv(n);this.outputQueue.pushAll(n);for(const t of e)rv(t,r)||t.dispose();return!0}}class cL extends ZD{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}(HR=GR||(GR={}))[HR.FAIL=0]="FAIL",HR[HR.SHORTEST=1]="SHORTEST",HR[HR.LONGEST=2]="LONGEST";class hL extends ZD{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new KD(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class dL extends hL{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=ES.alea(n||Ty().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class pL{constructor(){this.size=null}batch(t,e=!0){const n=this;let r;return uf(t>0,(()=>`batchSize needs to be positive, but it is\n      ${t}`)),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),fL((async()=>(await n.iterator()).columnMajorBatch(t,e,mL)),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,fL((async()=>(await e.iterator()).concatenate(await t.iterator())),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,fL((async()=>(await e.iterator()).filter((e=>Wb((()=>t(e)))))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return fL((async()=>(await e.iterator()).map((e=>Wb((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return fL((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return fL((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,fL((async()=>{return n=(i=async()=>({value:await e.iterator(),done:!1}),new QD(i)).take(t),new cL(n,r);var n,r,i}),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,fL((async()=>(await e.iterator()).skip(t)),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,i=ES.alea(e||Ty().toString());return fL((async()=>{let e=i.int32();return n&&(e+=i.int32()),(await r.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,fL((async()=>(await e.iterator()).take(t)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function fL(t,e=null){return new class extends pL{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function mL(t){if(null===t)return null;return null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof Hy||kf(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Hy?KS(t):kv(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function gL(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&uf("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the CPU backend.`))}))}pL.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const xL=Ak;class yL extends nf{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ef(this,Bb())}nextDataId(){return yL.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,Hf().get("IS_NODE")&&ey("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:n,refCount:1}),r}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&Tf(n[0])){const i=n.map((t=>Cy(t)));r=this.write(i,t,e)}else r=this.write(n,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,e,n,r,i){this.data.set(t,{values:e,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);return"complex64"===e?XI(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>Ey(t)));return sb(t.shape,t.dtype,n)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return sb(t.shape,t.dtype,e)}makeOutput(t,e,n){return Bb().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=Ty();return t(),{kernelMs:Ty()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){gL([t],"where");const e=this.readSync(t.dataId);return xL(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function vL(t,e,n){return({inputs:r,attrs:i,backend:s})=>{const{x:a}=r;if(gL(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=s,l=o.data.get(a.dataId).values,u=pf(a.shape),c=n||a.dtype,h=_f(c,u);for(let t=0;t<u;++t)h[t]=e(l[t],i);return o.makeTensorInfo(a.shape,c,h)}}function bL(t,e,n){return({inputs:r,attrs:i,backend:s})=>{const{x:a}=r;if(gL(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=s,l=o.data.get(a.dataId).values,u=n||a.dtype,c=e(l,u,i);return o.makeTensorInfo(a.shape,u,c)}}yL.nextDataId=0,Hb("cpu",(()=>new yL),1);const wL=vL(jm,(t=>t>=0?t:Math.exp(t)-1)),SL={kernelName:jm,backendName:"cpu",kernelFunc:wL};function _L(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const IL={kernelName:ug,backendName:"cpu",kernelFunc:_L};function kL(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{alpha:s}=r;gL([i],"leakyRelu");const a=pf(i.shape),o=n.data.get(i.dataId).values,l=Sf("float32",a);for(let t=0;t<o.length;t++)l[t]=o[t]<0?s*o[t]:o[t];return n.makeTensorInfo(i.shape,"float32",l)}const ML={kernelName:mg,backendName:"cpu",kernelFunc:kL};function TL(t){return(e,n,r,i,s)=>{const a=xb(e,n),o=a.length,l=Rf(a),u=Sf(s,pf(a)),c=e.length,h=n.length,d=Rf(e),p=Rf(n),f=mb(e,a),m=mb(n,a);if(f.length+m.length===0)for(let e=0;e<u.length;++e)u[e]=t(r[e%r.length],i[e%i.length]);else for(let e=0;e<u.length;++e){const n=Bf(e,o,l),s=n.slice(-c);f.forEach((t=>s[t]=0));const a=zf(s,c,d),g=n.slice(-h);m.forEach((t=>g[t]=0));const x=zf(g,h,p);u[e]=t(r[a],i[x])}return[u,a]}}const CL=TL(((t,e)=>t<0?e*t:t));function EL(t){const{inputs:e,backend:n}=t,{x:r,alpha:i}=e;gL([r,i],"prelu");const s=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values,[o,l]=CL(r.shape,i.shape,s,a,"float32");return n.makeTensorInfo(l,"float32",o)}const AL={kernelName:Yg,backendName:"cpu",kernelFunc:EL},NL=vL(rx,(t=>Math.max(0,t))),RL={kernelName:rx,backendName:"cpu",kernelFunc:NL},DL=vL(ux,(t=>Math.min(Math.max(0,t),6))),LL={kernelName:ux,backendName:"cpu",kernelFunc:DL};function FL(t){return(e,n,r)=>{const i=Sf(n,e.length);for(let n=0;n<e.length;++n)i[n]=t(e[n],r);return i}}const $L=FL((t=>1/(1+Math.exp(-t)))),PL=vL(wx,(t=>1/(1+Math.exp(-t)))),OL={kernelName:wx,backendName:"cpu",kernelFunc:PL};function zL(t,e,n,r,i){if("linear"===n)return _L({inputs:{x:e},backend:t});if("relu"===n)return NL({inputs:{x:e},backend:t});if("elu"===n)return wL({inputs:{x:e},backend:t});if("relu6"===n)return DL({inputs:{x:e},backend:t});if("prelu"===n)return EL({inputs:{x:e,alpha:r},backend:t});if("leakyrelu"===n)return kL({inputs:{x:e},backend:t,attrs:{alpha:i}});if("sigmoid"===n)return PL({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function BL(t){const{inputs:e,backend:n}=t,{real:r,imag:i}=e,s=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(i.shape,"float32",a)},o}const UL={kernelName:wm,backendName:"cpu",kernelFunc:BL};function WL(t,e,n="float32"){if("complex64"===n)return BL({inputs:{real:WL(t,e,"float32"),imag:WL(t,e,"float32")},backend:t});const r=$f(pf(e),n);return t.makeTensorInfo(e,n,r)}function VL(t){const{inputs:e,backend:n}=t,{input:r}=e,i=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,s)}const GL={kernelName:ex,backendName:"cpu",kernelFunc:VL};function HL(t,e,n,r){if("int32"===r)return[e,"int32",Int32Array.from(t)];if("bool"===r){const r=My([0],n),[i,s]=TL(((t,e)=>t!==e?1:0))(e,[],t,r,"bool");return[s,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function jL(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dtype:s}=r;if("complex64"===s){if("complex64"===i.dtype)return _L({inputs:{x:i},backend:n});const t=WL(n,i.shape,i.dtype),e=jL({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),r=BL({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),r}if("complex64"===i.dtype){const t=VL({inputs:{input:i},backend:n}),e=jL({inputs:{x:t},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(t),e}if(!If(i.dtype,s)){const t=_L({inputs:{x:i},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:s}}const a=n.data.get(i.dataId).values,[o,l,u]=HL(a,i.shape,i.dtype,s);return n.makeTensorInfo(o,l,u)}const qL={kernelName:ym,backendName:"cpu",kernelFunc:jL};function XL(t,e,n,r){return null==n?({inputs:n,backend:i})=>{const{a:s,b:a}=n,o=i;gL([s,a],t);const l=o.data.get(s.dataId).values,u=o.data.get(a.dataId).values,c="string"===s.dtype?Ck(l):l,h="string"===s.dtype?Ck(u):u,d=r||s.dtype,[p,f]=e(s.shape,a.shape,c,h,d);return o.makeTensorInfo(f,d,p)}:({inputs:t,backend:i})=>{const{a:s,b:a}=t,o=i;if("complex64"===s.dtype||"complex64"===a.dtype){const t=jL({inputs:{x:s},backend:o,attrs:{dtype:"complex64"}}),e=o.data.get(t.dataId),r=e.complexTensorInfos.real,i=e.complexTensorInfos.imag,l=o.data.get(r.dataId).values,u=o.data.get(i.dataId).values,c=jL({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),h=o.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=o.data.get(d.dataId).values,m=o.data.get(p.dataId).values,[g,x,y]=n(s.shape,a.shape,l,u,f,m),v=o.makeTensorInfo(y,"float32",g),b=o.makeTensorInfo(y,"float32",x),w=BL({inputs:{real:v,imag:b},backend:o});return o.disposeIntermediateTensorInfo(t),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(b),w}{const t=o.data.get(s.dataId).values,n=o.data.get(a.dataId).values,i=r||s.dtype,[l,u]=e(s.shape,a.shape,t,n,i);return o.makeTensorInfo(u,i,l)}}}function KL(t){return(e,n,r,i,s,a)=>{const o=xb(e,n),l=pf(o),u=o.length,c=Rf(o),h=Sf("float32",l),d=Sf("float32",l),p=mb(e,o),f=mb(n,o),m=XI(r,i),g=XI(s,a),x=e.length,y=Rf(e),v=n.length,b=Rf(n);if(p.length+f.length===0)for(let e=0;e<h.length;e++){const n=e%m.length,r=e%g.length,i=t(m[2*n],m[2*n+1],g[2*r],g[2*r+1]);h[e]=i.real,d[e]=i.imag}else for(let e=0;e<h.length;e++){const n=Bf(e,u,c),r=n.slice(-x);p.forEach((t=>r[t]=0));const i=zf(r,x,y),s=n.slice(-v);f.forEach((t=>s[t]=0));const a=zf(s,v,b),o=t(m[2*i],m[2*i+1],g[2*a],g[2*a+1]);h[e]=o.real,d[e]=o.imag}return[h,d,o]}}const YL=TL(((t,e)=>t+e)),ZL=KL(((t,e,n,r)=>({real:t+n,imag:e+r}))),JL=XL(Qf,YL,ZL),QL={kernelName:Qf,backendName:"cpu",kernelFunc:JL};function tF(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{shape:s}=r,a=pf(i.shape),o=vf(s,a),l=pf(o);uf(a===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(i.dataId);const u=n.data.get(i.dataId);if(null!=u.complexTensorInfos){const t=u.complexTensorInfos.real,e=u.complexTensorInfos.imag;t.shape=o,e.shape=o}return{dataId:i.dataId,shape:o,dtype:i.dtype}}const eF={kernelName:ix,backendName:"cpu",kernelFunc:tF};function nF(t){const{inputs:e,backend:n,attrs:r}=t,{a:i,b:s}=e,{transposeA:a,transposeB:o}=r;gL([i,s],"matMul");const l=i.shape.length,u=s.shape.length,c=a?i.shape[l-2]:i.shape[l-1],h=o?s.shape[u-1]:s.shape[u-2],d=a?i.shape[l-1]:i.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=i.shape.slice(0,-2),m=s.shape.slice(0,-2),g=pf(f),x=pf(m),y=xb(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);uf(c===h,(()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${a} and transposeB=${o} must match.`));const v=o?[x,p,h]:[x,h,p],b=tF({inputs:{x:i},backend:n,attrs:{shape:a?[g,c,d]:[g,d,c]}}),w=tF({inputs:{x:s},backend:n,attrs:{shape:v}}),S=a?b.shape[1]:b.shape[2],_=a?b.shape[2]:b.shape[1],I=o?w.shape[1]:w.shape[2],k=Math.max(g,x),M=n.data.get(b.dataId).values,T=n.data.get(w.dataId).values,C=Rf(b.shape),E=Rf(w.shape),[A,N,R]=a?[C[0],1,C[1]]:[C[0],C[1],1],[D,L,F]=o?[1,E[1],E[0]]:[E[1],1,E[0]],$=_*I,P=sb([k,_,I],b.dtype),O=P.values,z=n.blockSize;for(let t=0;t<k;t++)for(let e=0;e<_;e+=z)for(let n=0;n<I;n+=z)for(let r=0;r<S;r+=z){const i=Math.min(e+z,_),s=Math.min(n+z,I),a=Math.min(r+z,S);for(let o=e;o<i;o++)for(let e=n;e<s;e++){let n=0;for(let i=r;i<a;i++){const r=Math.min(t,g-1)*A,s=Math.min(t,x-1)*F;n+=M[r+o*N+i*R]*T[i*D+e*L+s]}O[t*$+(o*I+e)]+=n}}return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,P.dtype,P.values)}const rF={kernelName:fm,backendName:"cpu",kernelFunc:nF},iF={kernelName:Jx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:i,b:s,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=nF({inputs:{a:i,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(p=JL({inputs:{a:d,b:a},backend:n}),m.push(d),d=p),c&&(f=zL(n,d,c,o,h),m.push(d),d=f);for(const t of m)n.disposeIntermediateTensorInfo(t);return d}};function sF(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const aF={kernelName:Yf,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;gL(e,"abs");let r=new Float32Array(pf(e.shape));return r=sF(n.data.get(e.dataId).values),n.makeOutput(r,e.shape,e.dtype)}},oF=vL(Zf,(t=>Math.acos(t))),lF={kernelName:Zf,backendName:"cpu",kernelFunc:oF},uF=vL(Jf,(t=>Math.acosh(t))),cF={kernelName:Jf,backendName:"cpu",kernelFunc:uF},hF={kernelName:tm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,r=e;gL(e,"addN");const i=r.map((t=>n.data.get(t.dataId).values)),s=sb(r[0].shape,r[0].dtype),a=s.values;for(let t=0;t<r.length;t++){const e=i[t];for(let t=0;t<a.length;t++)a[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function dF(t,e,n,r,i){const s=e.length,a=pf(e),o=Rf(e),l=Rf(i),u=Sf(n,pf(i));for(let e=0;e<a;++e){const n=Bf(e,s,o),i=new Array(n.length);for(let t=0;t<i.length;t++)i[t]=n[r[t]];u[zf(i,s,l)]=t[e]}return u}function pF(t){const{inputs:e,attrs:n,backend:r}=t,{x:i}=e,{perm:s}=n;gL(i,"transpose");const a=i.shape.length,o=new Array(a);for(let t=0;t<o.length;t++)o[t]=i.shape[s[t]];const l=dF(r.data.get(i.dataId).values,i.shape,i.dtype,s,o);return{dataId:r.write(l,o,i.dtype),shape:o,dtype:i.dtype}}const fF={kernelName:Hx,backendName:"cpu",kernelFunc:pF},mF={kernelName:em,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;gL(i,"all");const o=bf(s,i.shape);let l=o;const u=gS(l,i.shape.length);let c=i;null!=u&&(c=pF({inputs:{x:i},backend:n,attrs:{perm:u}}),l=yS(l.length,i.shape.length)),mS("all",l,c.shape.length);const[h,d]=pS(c.shape,l),p=pf(d),f=$f(pf(h),c.dtype),m=n.data.get(c.dataId).values;for(let t=0;t<f.length;++t){const e=t*p;let n=m[e];for(let t=0;t<p;++t){const r=m[e+t];n=n&&r}f[t]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const t=tF({inputs:{x:g},backend:n,attrs:{shape:fS(h,o)}});return n.disposeIntermediateTensorInfo(g),t}return g}},gF={kernelName:nm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;gL(i,"any");const o=bf(s,i.shape);let l=o;const u=gS(l,i.shape.length);let c=i;null!=u&&(c=pF({inputs:{x:i},backend:n,attrs:{perm:u}}),l=yS(l.length,i.shape.length)),mS("any",l,c.shape.length);const[h,d]=pS(c.shape,l),p=pf(d),f=$f(pf(h),c.dtype),m=n.data.get(c.dataId).values;for(let t=0;t<f.length;++t){const e=t*p;let n=m[e];for(let t=0;t<p;++t){const r=m[e+t];n=n||r}f[t]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const t=tF({inputs:{x:g},backend:n,attrs:{shape:fS(h,o)}});return n.disposeIntermediateTensorInfo(g),t}return g}},xF={kernelName:rm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r;gL(i,"argMax");let a=bf(s,i.shape);const o=gS(a,i.shape.length);let l=i;const u=[];null!=o&&(l=pF({inputs:{x:i},backend:n,attrs:{perm:o}}),u.push(l),a=yS(a.length,l.shape.length)),a=[a[0]],mS("argMax",a,l.shape.length);const[c,h]=pS(l.shape,a),d=$f(pf(c),"int32"),p=pf(h),f=n.data.get(l.dataId).values;for(let t=0;t<d.length;++t){const e=t*p;let n=f[e],r=0;for(let t=0;t<p;++t){const i=f[e+t];i>n&&(n=i,r=t)}d[t]=r}return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(c,"int32",d)}},yF={kernelName:im,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r;gL(i,"argMin");let a=bf(s,i.shape);const o=gS(a,i.shape.length);let l=i;const u=[];null!=o&&(l=pF({inputs:{x:i},backend:n,attrs:{perm:o}}),u.push(l),a=yS(a.length,l.shape.length)),a=[a[0]],mS("argMin",a,l.shape.length);const[c,h]=pS(l.shape,a),d=$f(pf(c),"int32"),p=pf(h),f=n.data.get(l.dataId).values;for(let t=0;t<d.length;++t){const e=t*p;let n=f[e],r=0;for(let t=0;t<p;++t){const i=f[e+t];i<n&&(n=i,r=t)}d[t]=r}return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(c,"int32",d)}},vF=vL(sm,(t=>Math.asin(t))),bF={kernelName:sm,backendName:"cpu",kernelFunc:vF},wF=vL(am,(t=>Math.asinh(t))),SF={kernelName:am,backendName:"cpu",kernelFunc:wF},_F=vL(om,(t=>Math.atan(t))),IF={kernelName:om,backendName:"cpu",kernelFunc:_F},kF=TL(((t,e)=>Math.atan2(t,e))),MF=XL(um,kF),TF={kernelName:um,backendName:"cpu",kernelFunc:MF},CF=vL(lm,(t=>Math.atanh(t))),EF={kernelName:lm,backendName:"cpu",kernelFunc:CF};function AF(t,e,n,r,i,s){const a=i.strideHeight,o=i.strideWidth,l=i.dilationHeight,u=i.dilationWidth,c=i.effectiveFilterHeight,h=i.effectiveFilterWidth,d=i.padInfo.top,p=i.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=sb(i.outShape,n),g=m.values,x=i.outShape[1]*i.outShape[2]*i.outShape[3],y=i.outShape[2]*i.outShape[3],v=i.outShape[3];for(let e=0;e<i.batchSize;++e){const n=e*x,m=e*r[0];for(let e=0;e<i.inChannels;++e)for(let x=0;x<i.outHeight;++x){const b=x*a-d,w=Math.max(0,b),S=Math.min(i.inHeight,c+b),_=n+x*y;for(let n=0;n<i.outWidth;++n){const a=n*o-p,c=Math.max(0,a),d=Math.min(i.inWidth,h+a);let x=f,y=0,b=0;for(let n=w;n<S;n+=l){const i=m+n*r[1];for(let n=c;n<d;n+=u){const a=t[i+n*r[2]+e];"max"===s&&a>x?x=a:"avg"===s&&(y+=a,b++)}if(isNaN(x))break}g[_+n*v+e]="avg"===s?y/b:x}}}return m}function NF(t,e,n,r,i=!1,s=!1){const a=sb(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=sb(e,n,t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let n=0;n<r.outHeight;++n){const g=n*o-p;let x=g;for(;x<0;)x+=u;const y=Math.min(r.inHeight,h+g);for(let o=0;o<r.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const v=Math.min(r.inWidth,d+h);let b=Number.NEGATIVE_INFINITY,w=-1;for(let n=x;n<y;n+=u){const a=n-g;for(let o=p;o<v;o+=c){const l=o-h,u=m.get(t,n,o,e);u>b&&(b=u,w=i?s?((t*r.inHeight+n)*r.inWidth+o)*r.inChannels+e:(n*r.inWidth+o)*r.inChannels+e:a*d+l)}}a.set(w,t,n,o,e)}}return a}function RF(t,e,n,r,i,s){const a=i.strideDepth,o=i.strideHeight,l=i.strideWidth,u=i.dilationDepth,c=i.dilationHeight,h=i.dilationWidth,d=i.effectiveFilterDepth,p=i.effectiveFilterHeight,f=i.effectiveFilterWidth,m=i.padInfo.front,g=i.padInfo.top,x=i.padInfo.left,y="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=sb(i.outShape,n),b=v.values,w=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],S=i.outShape[2]*i.outShape[3]*i.outShape[4],_=i.outShape[3]*i.outShape[4],I=i.outShape[4];for(let e=0;e<i.batchSize;++e){const n=e*w,v=e*r[0];for(let e=0;e<i.inChannels;++e)for(let w=0;w<i.outDepth;++w){const k=w*a-m;let M=k;for(;M<0;)M+=u;const T=Math.min(i.inDepth,d+k),C=n+w*S;for(let n=0;n<i.outHeight;++n){const a=n*o-g;let d=a;for(;d<0;)d+=c;const m=Math.min(i.inHeight,p+a),w=C+n*_;for(let n=0;n<i.outWidth;++n){const a=n*l-x;let o=a;for(;o<0;)o+=h;const p=Math.min(i.inWidth,f+a),g=w+n*I;let S=y,_=0,k=0;for(let n=M;n<T;n+=u){const i=v+n*r[1];for(let n=d;n<m;n+=c){const a=i+n*r[2];for(let n=o;n<p;n+=h){const i=t[a+n*r[3]+e];if("max"===s&&i>S?S=i:"avg"===s&&(_+=i,k++),isNaN(S))break}if(isNaN(S))break}if(isNaN(S))break}b[g+e]="avg"===s?_/k:S}}}}return v}const DF={kernelName:cm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;gL(i,"avgPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;uf(dw(a,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=nw(i.shape,s,a,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&ff(u.inShape,u.outShape))c=_L({inputs:{x:i},backend:n});else{const t=n.data.get(i.dataId).values,e=Rf(i.shape),r=AF(t,i.shape,i.dtype,e,u,"avg");c=n.makeTensorInfo(u.outShape,i.dtype,r.values)}return c}},LF={kernelName:dm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r;gL(i,"avgPool3d");const c=rw(i.shape,s,a,1,o,l,u),h=RF(n.data.get(i.dataId).values,i.shape,i.dtype,Rf(i.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},FF={kernelName:pm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;gL([i,s],"avgPool3DGrad");const c=rw(s.shape,a,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,x=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,b=c.effectiveFilterDepth,w=c.effectiveFilterHeight,S=c.effectiveFilterWidth,_=b-1-c.padInfo.front,I=S-1-c.padInfo.left,k=w-1-c.padInfo.top,M=sb(s.shape,"float32"),T=1/(f*m*g),C=n.bufferSync(i);for(let t=0;t<c.batchSize;++t)for(let e=0;e<c.inChannels;++e)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let i=0;i<c.inWidth;++i){const s=n-_,a=r-k,o=i-I;let l=0;for(let n=0;n<b;n+=x){const r=(s+n)/h;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let n=0;n<w;n+=y){const i=(a+n)/d;if(!(i<0||i>=c.outHeight||Math.floor(i)!==i))for(let n=0;n<S;n+=v){const s=(o+n)/p;s<0||s>=c.outWidth||Math.floor(s)!==s||(l+=C.get(t,r,i,s,e))}}}M.set(l*T,t,n,r,i,e)}return n.makeTensorInfo(M.shape,M.dtype,M.values)}},$F={kernelName:hm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,a=s;gL([i,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=nw(a.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,x=c.effectiveFilterHeight,y=c.effectiveFilterWidth,v=y-1-c.padInfo.left,b=x-1-c.padInfo.top,w=sb(a.shape,"float32"),S=1/(p*f),_=n.data.get(i.dataId).values,I=sb(i.shape,"float32",_);for(let t=0;t<c.batchSize;++t)for(let e=0;e<c.inChannels;++e)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const i=n-b,s=r-v;let a=0;for(let n=0;n<x;n+=m){const r=(i+n)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let n=0;n<y;n+=g){const i=(s+n)/d;i<0||i>=c.outWidth||Math.floor(i)!==i||(a+=I.get(t,r,i,e))}}w.set(a*S,t,n,r,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},PF={kernelName:ig,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,scale:s,offset:a,mean:o,variance:l}=e;uf(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),uf(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),uf(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),gL([i,o,l,s,a],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(i.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=a?n.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,x=p.length,y=d.length,v=h.length;let b=0,w=0,S=0,_=0;for(let t=0;t<c.length;++t)m[t]=f[b++]+(c[t]-h[w++])*p[S++]/Math.sqrt(d[_++]+u),b>=g&&(b=0),w>=v&&(w=0),S>=x&&(S=0),_>=y&&(_=0);return n.makeTensorInfo(i.shape,i.dtype,m)}};function OF(t,e,n,r,i){const s=Rb(r,e,n),a=pf(n),o=Rf(r);if(s){const n=Db(e,o);return"string"===i?t.slice(n,n+a):t.subarray(n,n+a)}const l=sb(r,i,"string"===i?Ck(t):t),u=sb(n,i);for(let t=0;t<u.size;++t){const n=u.indexToLoc(t),r=n.map(((t,n)=>t+e[n]));u.set(l.get(...r),...n)}return"string"===i?Ek(u.values):u.values}function zF(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,size:a}=r;gL(i,"slice");const[o,l]=Lb(i,s,a);bb(i,o,l);const u=OF(n.data.get(i.dataId).values,o,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,u)}const BF={kernelName:xx,backendName:"cpu",kernelFunc:zF},UF={kernelName:mm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,crops:a}=r;gL([i],"batchToSpaceND");const o=s.reduce(((t,e)=>t*e)),l=NI(i.shape,s,o),u=RI(l.length,s.length),c=DI(i.shape,s,o),h=LI(a,s.length),d=FI(c,a,s.length),p=tF({inputs:{x:i},backend:n,attrs:{shape:l}}),f=pF({inputs:{x:p},backend:n,attrs:{perm:u}}),m=tF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=zF({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function WF(t,e,n,r,i){const s=pf(r),a=$f(i,n);for(let n=0;n<t.length;n++){const r=t[n];if(r<0)throw new Error("Input x must be non-negative!");r>=i||(a[r]+=s>0?e[n]:1)}return a}function VF(t,e,n,r=!1){const i=t.shape[0],s=t.shape[1],a=sb([i,n],e.dtype);for(let o=0;o<i;o++)for(let i=0;i<s;i++){const s=t.get(o,i);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?a.set(1,o,s):e.size>0?a.set(a.get(o,s)+e.get(o,i),o,s):a.set(a.get(o,s)+1,o,s))}return a}const GF={kernelName:gm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:a}=r,o=WF(n.data.get(i.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,o)}},HF={kernelName:xm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:i}=e,s=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values,o=xb(Array.from(s),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},jF=FL((t=>Math.ceil(t))),qF=bL(vm,jF),XF={kernelName:vm,backendName:"cpu",kernelFunc:qF},KF=vL(bm,((t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t})),YF={kernelName:bm,backendName:"cpu",kernelFunc:KF},ZF={kernelName:Sm,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(pf(e.shape)),i=n.data.get(e.dataId),s=i.complexTensorInfos.real,a=i.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values;for(let t=0;t<o.length;t++){const e=o[t],n=l[t];r[t]=Math.hypot(e,n)}return n.makeOutput(r,e.shape,"float32")}};function JF(t,e,n,r){const i=_f(n,pf(e));if(r&&"string"!==n){let e=0;t.forEach((t=>{const n=pf(t.shape);i.set(t.vals,e),e+=n}))}else{let r=0;t.forEach((t=>{const s="string"===n?Ck(t.vals):t.vals;let a=0;for(let n=0;n<t.shape[0];++n){const o=n*e[1]+r;for(let e=0;e<t.shape[1];++e)i[o+e]=s[a++]}r+=t.shape[1]}))}return i}function QF(t){const{inputs:e,backend:n}=t,{input:r}=e,i=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,s)}const t$={kernelName:hg,backendName:"cpu",kernelFunc:QF};function e$(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r,s=bf(i,e[0].shape)[0];wI(e.map((t=>t.shape)),s);let a=SI(e.map((t=>t.shape)),s);if(0===pf(a))return n.makeTensorInfo(a,e[0].dtype,[]);const o=e.filter((t=>pf(t.shape)>0));if(1===o.length)return _L({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const t=o.map((t=>VL({inputs:{input:t},backend:n}))),e=o.map((t=>QF({inputs:{input:t},backend:n}))),r=e$({inputs:t,backend:n,attrs:{axis:s}}),i=e$({inputs:e,backend:n,attrs:{axis:s}}),a=BL({inputs:{real:r,imag:i},backend:n});return t.forEach((t=>n.disposeIntermediateTensorInfo(t))),e.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}const l=o.map((t=>{const e=pf(t.shape.slice(s));return tF({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})})),u=l.map((t=>({vals:n.data.get(t.dataId).values,shape:t.shape})));a=SI(l.map((t=>t.shape)),1);const c=1===l[0].shape[0],h=JF(u,a,e[0].dtype,c),d=SI(o.map((t=>t.shape)),s),p=n.makeTensorInfo(d,e[0].dtype,h);return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}const n$={kernelName:_m,backendName:"cpu",kernelFunc:e$};function r$(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;gL([i,s],"conv2d");const h=pw(l),d=iw(i.shape,s.shape,a,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,x=d.padInfo.left,y=d.padInfo.top,v="channelsLast"===d.dataFormat,b=new Uy(d.outShape,i.dtype),w=Rf(i.shape),S=Rf(s.shape),_=w[0],I=v?w[1]:w[2],k=v?w[2]:1,M=v?1:w[1],T=b.strides[0],C=v?b.strides[1]:b.strides[2],E=v?b.strides[2]:1,A=v?1:b.strides[1],N=n.data.get(i.dataId).values,R=n.data.get(s.dataId).values,D=b.values;for(let t=0;t<d.batchSize;++t){const e=t*_,n=t*T;for(let t=0;t<d.outHeight;++t){const r=n+t*C,i=t*d.strideHeight-y;for(let t=0;t<p;++t){const n=i+t*m;if(n<0||n>=d.inHeight)continue;const s=t*S[0],a=e+n*I;for(let t=0;t<d.outWidth;++t){const e=r+t*E,n=t*d.strideWidth-x;for(let t=0;t<f;++t){const r=n+t*g;if(r<0||r>=d.inWidth)continue;const i=a+r*k;let o=s+t*S[1];for(let t=0;t<d.inChannels;++t){const n=N[i+t*M];for(let t=0;t<d.outChannels;++t)D[e+t*A]+=n*R[o+t];o+=d.outChannels}}}}}}return n.makeTensorInfo(b.shape,b.dtype,D)}const i$={kernelName:Im,backendName:"cpu",kernelFunc:r$},s$={kernelName:km,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;gL([i,s],"conv2dBackpropFilter");const h=pw(l),d=iw(i.shape,c,a,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,x="channelsLast"===d.dataFormat,y=new Uy(d.filterShape,"float32"),v=d.padInfo.left,b=d.padInfo.top,w=n.data.get(i.dataId).values,S=n.data.get(s.dataId).values,_=new Uy(i.shape,i.dtype,w),I=new Uy(s.shape,s.dtype,S);for(let t=0;t<m;++t){const e=Math.max(0,Math.ceil((b-t)/p)),n=Math.min(d.outHeight,(d.inHeight+b-t)/p);for(let r=0;r<g;++r){const i=Math.max(0,Math.ceil((v-r)/f)),s=Math.min(d.outWidth,(d.inWidth+v-r)/f);for(let a=0;a<d.inChannels;++a)for(let o=0;o<d.outChannels;++o){let l=0;for(let u=0;u<d.batchSize;++u)for(let c=e;c<n;++c){const e=t+c*p-b;for(let t=i;t<s;++t){const n=r+t*f-v;l+=x?_.get(u,e,n,a)*I.get(u,c,t,o):_.get(u,a,e,n)*I.get(u,o,c,t)}}y.set(l,t,r,a,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},a$={kernelName:Mm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;gL([i,s],"conv2dBackpropInput");const h=Rf(s.shape),d=Rf(i.shape);let p=pw(u);const f=iw(a,s.shape,o,1,l,c,!1,p),m=new Uy(f.inShape,"float32"),g=m.values,x=n.data.get(i.dataId).values,y=n.data.get(s.dataId).values,[v,b,w]=h,{batchSize:S,filterHeight:_,filterWidth:I,inChannels:k,inHeight:M,inWidth:T,outChannels:C,outHeight:E,outWidth:A,strideHeight:N,strideWidth:R}=f;p=f.dataFormat;const D=_-1-f.padInfo.top,L=I-1-f.padInfo.left,F="channelsLast"===p,$=m.strides[0],P=F?m.strides[1]:m.strides[2],O=F?m.strides[2]:1,z=F?1:m.strides[1],B=d[0],U=F?d[1]:d[2],W=F?d[2]:1,V=F?1:d[1];for(let t=0;t<S;++t)for(let e=0;e<k;++e)for(let n=0;n<M;++n){const r=n-D,i=Math.max(0,Math.ceil(r/N)),s=Math.min(E,(_+r)/N);for(let a=0;a<T;++a){const o=a-L,l=Math.max(0,Math.ceil(o/R)),u=Math.min(A,(I+o)/R);let c=0;for(let n=i;n<s;++n){const i=n*N-r;for(let r=l;r<u;++r){const s=B*t+U*n+W*r,a=v*(_-1-i)+b*(I-1-(r*R-o))+w*e;for(let t=0;t<C;++t)c+=x[s+V*t]*y[a+t]}}g[$*t+P*n+O*a+z*e]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},o$={kernelName:Tm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l}=r;gL([i,s],"conv3d");const u=sw(i.shape,s.shape,a,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,x=g.front,y=g.left,v=g.top,b=new Uy(u.outShape,i.dtype),w=n.data.get(i.dataId).values,S=n.data.get(s.dataId).values,_=b.values,I=Rf(i.shape),k=Rf(s.shape);for(let t=0;t<u.batchSize;++t){const e=t*I[0],n=t*b.strides[0];for(let t=0;t<u.outDepth;++t){const r=n+t*b.strides[1],i=t*u.strideDepth-x;for(let t=0;t<c;++t){const n=i+t*p;if(n<0||n>=u.inDepth)continue;const s=t*k[0],a=e+n*I[1];for(let t=0;t<u.outHeight;++t){const e=r+t*b.strides[2],n=t*u.strideHeight-v;for(let t=0;t<h;++t){const r=n+t*f;if(r<0||r>=u.inHeight)continue;const i=s+t*k[1],o=a+r*I[2];for(let t=0;t<u.outWidth;++t){const n=e+t*u.outChannels,r=t*u.strideWidth-y;for(let t=0;t<d;++t){const e=r+t*m;if(e<0||e>=u.inWidth)continue;const s=i+t*k[2],a=o+e*u.inChannels;let l=s;for(let t=0;t<u.inChannels;++t){const e=w[a+t];for(let t=0;t<u.outChannels;++t)_[n+t]+=e*S[l+t];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},l$={kernelName:Cm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,pad:o,filterShape:l}=r;gL([i,s],"conv3dBackpropFilterV2");const u=Rf(i.shape),c=Rf(s.shape),h=sw(i.shape,l,a,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,x=h.filterWidth,y=new Uy(h.filterShape,"float32"),v=y.values,[b,w,S,_]=y.strides,I=n.data.get(s.dataId).values,[k,M,T,C]=c,E=n.data.get(i.dataId).values,[A,N,R,D]=u,L=h.padInfo.front,F=h.padInfo.left,$=h.padInfo.top;for(let t=0;t<m;++t){const e=Math.max(0,Math.ceil((L-t)/d)),n=Math.min(h.outDepth,(h.inDepth+L-t)/d),r=t*b;for(let i=0;i<g;++i){const s=Math.max(0,Math.ceil(($-i)/p)),a=Math.min(h.outHeight,(h.inHeight+$-i)/p),o=i*w+r;for(let r=0;r<x;++r){const l=Math.max(0,Math.ceil((F-r)/f)),u=Math.min(h.outWidth,(h.inWidth+F-r)/f),c=r*S+o;for(let o=0;o<h.inChannels;++o){const m=o*_+c;for(let c=0;c<h.outChannels;++c){let g=0;for(let m=0;m<h.batchSize;++m){const h=m*A,x=m*k;for(let m=e;m<n;++m){const e=(t+m*d-L)*N+h,n=m*M+x;for(let t=s;t<a;++t){const s=(i+t*p-$)*R+e,a=t*T+n;for(let t=l;t<u;++t){const e=t*C+a;g+=E[(r+t*f-F)*D+s+o]*I[e+c]}}}}v[m+c]=g}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},u$={kernelName:Em,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{pad:a,strides:o,inputShape:l}=r;gL([i],"conv3dBackpropInputV2");const u=Rf(i.shape),c=Rf(s.shape),h=sw(l,s.shape,o,1,a),d=new Uy(h.inShape,"float32"),p=d.values,[f,m,g,x]=d.strides,y=n.data.get(i.dataId).values,[v,b,w,S]=u,_=n.data.get(s.dataId).values,[I,k,M,T]=c,{batchSize:C,filterDepth:E,filterHeight:A,filterWidth:N,inChannels:R,inDepth:D,inHeight:L,inWidth:F,outChannels:$,outDepth:P,outHeight:O,outWidth:z,strideDepth:B,strideHeight:U,strideWidth:W}=h,V=E-1-h.padInfo.front,G=A-1-h.padInfo.top,H=N-1-h.padInfo.left;for(let t=0;t<C;++t)for(let e=0;e<R;++e)for(let n=0;n<D;++n){const r=n-V,i=Math.max(0,Math.ceil(r/B)),s=Math.min(P,(E+r)/B);for(let a=0;a<L;++a){const o=a-G,l=Math.max(0,Math.ceil(o/U)),u=Math.min(O,(A+o)/U);for(let c=0;c<F;++c){const h=c-H,d=Math.max(0,Math.ceil(h/W)),C=Math.min(z,(N+h)/W);let R=0;for(let n=i;n<s;++n){const i=n*B-r;for(let r=l;r<u;++r){const s=r*U-o;for(let a=d;a<C;++a){const o=v*t+b*n+w*r+S*a,l=I*(E-1-i)+k*(A-1-s)+M*(N-1-(a*W-h))+T*e;for(let t=0;t<$;++t)R+=y[o+t]*_[l+t]}}}p[f*t+m*n+g*a+x*c+e]=R}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},c$=vL(Am,(t=>Math.cos(t))),h$={kernelName:Am,backendName:"cpu",kernelFunc:c$},d$=vL(Nm,(t=>Math.cosh(t))),p$={kernelName:Nm,backendName:"cpu",kernelFunc:d$},f$={kernelName:Lm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:i,boxes:s,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=r,[c,h,d,p]=i.shape,f=s.shape[0],[m,g]=o,x=sb([f,m,g,p],"float32"),y=n.data.get(s.dataId).values,v=n.data.get(a.dataId).values,b=n.data.get(i.dataId).values,w=Rf(i.shape),S=Rf(x.shape);for(let t=0;t<f;t++){const e=4*t,n=y[e],r=y[e+1],i=y[e+2],s=y[e+3],a=v[t];if(a>=c)continue;const o=m>1?(i-n)*(h-1)/(m-1):0,f=g>1?(s-r)*(d-1)/(g-1):0;for(let e=0;e<m;e++){const c=m>1?n*(h-1)+e*o:.5*(n+i)*(h-1);if(c<0||c>h-1)for(let n=0;n<g;n++)for(let r=0;r<p;r++){const i=r+n*S[2]+e*S[1]+t*S[0];x.values[i]=u}else if("bilinear"===l){const n=Math.floor(c),i=Math.ceil(c),o=c-n;for(let l=0;l<g;l++){const c=g>1?r*(d-1)+l*f:.5*(r+s)*(d-1);if(c<0||c>d-1){for(let n=0;n<p;n++){const r=n+l*S[2]+e*S[1]+t*S[0];x.values[r]=u}continue}const h=Math.floor(c),m=Math.ceil(c),y=c-h;for(let r=0;r<p;r++){let s=r+h*w[2]+n*w[1]+a*w[0];const u=b[s];s=r+m*w[2]+n*w[1]+a*w[0];const c=b[s];s=r+h*w[2]+i*w[1]+a*w[0];const d=b[s];s=r+m*w[2]+i*w[1]+a*w[0];const p=u+(c-u)*y,f=d+(b[s]-d)*y;s=r+l*S[2]+e*S[1]+t*S[0],x.values[s]=p+(f-p)*o}}}else for(let n=0;n<g;++n){const i=g>1?r*(d-1)+n*f:.5*(r+s)*(d-1);if(i<0||i>d-1){for(let r=0;r<p;r++){const i=r+n*S[2]+e*S[1]+t*S[0];x.values[i]=u}continue}const o=Math.round(i),l=Math.round(c);for(let r=0;r<p;r++){const i=r+o*w[2]+l*w[1]+a*w[0],s=r+n*S[2]+e*S[1]+t*S[0];x.values[s]=b[i]}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},m$={kernelName:Rm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;gL(i,"cumprod");const l=gS([s],i.shape.length);let u=i;null!=l&&(u=pF({inputs:{x:i},backend:n,attrs:{perm:l}}));const c=yS(1,i.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=tv(u.dtype,"int32"),d=Ff(pf(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let t=0;t<p.length;t+=f)for(let e=0;e<f;e++){const n=m(t,e);if(0===e)d[n]=a?1:p[n];else{const r=m(t,e-1);d[n]=a?p[r]*d[r]:p[n]*d[r]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const t=pF({inputs:{x:g},backend:n,attrs:{perm:xS(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}},g$={kernelName:Dm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;gL(i,"cumsum");const l=gS([s],i.shape.length);let u=i;null!=l&&(u=pF({inputs:{x:i},backend:n,attrs:{perm:l}}));const c=yS(1,i.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=tv(u.dtype,"int32"),d=$f(pf(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let t=0;t<p.length;t+=f)for(let e=0;e<f;e++){const n=m(t,e);if(0===e)d[n]=a?0:p[n];else{const r=m(t,e-1);d[n]=a?p[r]+d[r]:p[n]+d[r]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const t=pF({inputs:{x:g},backend:n,attrs:{perm:xS(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}},x$={kernelName:Fm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:a,binaryOutput:o}=r;if(1===i.shape.length){const t=WF(n.data.get(i.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,t)}if(2===i.shape.length){const t=VF(n.bufferSync(i),n.bufferSync(s),a,o);return n.makeTensorInfo(t.shape,s.dtype,t.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}},y$={kernelName:$m,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockSize:s,dataFormat:a}=r;uf("NHWC"===a,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`));const o=i.shape[0],l=i.shape[1],u=i.shape[2],c=i.shape[3],h=l*s,d=u*s,p=c/(s*s),f=n.data.get(i.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let t=0;t<o;++t)for(let e=0;e<h;++e){const n=Math.floor(e/s),r=e%s;for(let e=0;e<d;++e){const i=Math.floor(e/s),a=(r*s+e%s)*p;for(let e=0;e<p;++e){const r=e+a+c*(i+u*(n+l*t));m[g++]=f[r]}}}return n.makeTensorInfo([o,h,d,p],i.dtype,m)}};function v$(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=r;gL([i,s],"depthwiseConv2DNative");const c=Rf(i.shape),h=Rf(s.shape);let d=l;null==d&&(d=[1,1]),uf(dw(a,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`));const p=iw(i.shape,s.shape,a,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:x,padInfo:y}=p,v=y.left,b=y.top,w=p.outChannels/p.inChannels,S=new Uy(p.outShape,i.dtype),_=n.data.get(i.dataId).values,I=n.data.get(s.dataId).values,k=S.values;for(let t=0;t<p.batchSize;++t){const e=t*c[0],n=t*S.strides[0];for(let t=0;t<p.outHeight;++t){const r=n+t*S.strides[1],i=t*p.strideHeight-b;for(let t=0;t<f;++t){const n=i+t*g;if(n<0||n>=p.inHeight)continue;const s=t*h[0],a=e+n*c[1];for(let t=0;t<p.outWidth;++t){const e=r+t*S.strides[2],n=t*p.strideWidth-v;for(let t=0;t<m;++t){const r=n+t*x;if(r<0||r>=p.inWidth)continue;const i=s+t*h[1],o=a+r*p.inChannels;let l=e,u=i;for(let t=0;t<p.inChannels;++t){const e=_[o+t];for(let t=0;t<w;++t)k[l+t]+=e*I[u+t];l+=w,u+=w}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const b$={kernelName:Pm,backendName:"cpu",kernelFunc:v$},w$={kernelName:Om,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;gL([i,s],"depthwiseConv2dNativeBackpropFilter");const h=iw(i.shape,c,a,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new Uy(h.filterShape,"float32"),x=h.padInfo.left,y=h.padInfo.top,v=h.outChannels/h.inChannels,b=n.data.get(i.dataId).values,w=new Uy(i.shape,i.dtype,b),S=n.data.get(s.dataId).values,_=new Uy(s.shape,s.dtype,S);for(let t=0;t<f;++t){const e=Math.max(0,Math.ceil((y-t)/d)),n=Math.min(h.outHeight,(h.inHeight+y-t)/d);for(let r=0;r<m;++r){const i=Math.max(0,Math.ceil((x-r)/p)),s=Math.min(h.outWidth,(h.inWidth+x-r)/p);for(let a=0;a<h.outChannels;++a){const o=Math.trunc(a/v),l=a%v;let u=0;for(let l=0;l<h.batchSize;++l)for(let c=e;c<n;++c){const e=t+c*d-y;for(let t=i;t<s;++t){const n=r+t*p-x;u+=w.get(l,e,n,o)*_.get(l,c,t,a)}}g.set(u,t,r,o,l)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},S$={kernelName:zm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;gL([i,s],"depthwiseConv2DNativeBackpropInput");const h=Rf(i.shape),d=Rf(s.shape),p=iw(c,s.shape,a,o,l,u,!0),f=new Uy(p.inShape,"float32"),m=f.values,[g,x,y]=f.strides,v=n.data.get(i.dataId).values,[b,w,S]=h,_=n.data.get(s.dataId).values,[I,k,M]=d,{batchSize:T,filterHeight:C,filterWidth:E,inChannels:A,inHeight:N,inWidth:R,outChannels:D,outHeight:L,outWidth:F,strideHeight:$,strideWidth:P}=p,O=C-1-p.padInfo.top,z=E-1-p.padInfo.left,B=D/A;for(let t=0;t<T;++t)for(let e=0;e<A;++e)for(let n=0;n<N;++n){const r=n-O,i=Math.max(0,Math.ceil(r/$)),s=Math.min(L,(C+r)/$);for(let a=0;a<R;++a){const o=a-z,l=Math.max(0,Math.ceil(o/P)),u=Math.min(F,(E+o)/P);let c=0;for(let n=i;n<s;++n){const i=n*$-r;for(let r=l;r<u;++r){const s=b*t+w*n+S*r,a=I*(C-1-i)+k*(E-1-(r*P-o))+M*e;for(let t=0;t<B;++t)c+=v[s+(e*B+t)]*_[a+t]}}m[g*t+x*n+y*a+e]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},_$={kernelName:Bm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,i=pf(r.shape),s=n.data.get(r.dataId).values,a=sb([i,i],r.dtype),o=a.values;for(let t=0;t<s.length;t++)o[t*i+t]=s[t];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,a.dtype,a.values)}},I$={kernelName:Um,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:i}=t,{strides:s,pad:a,dilations:o}=n,l=e,u=l.data.get(r.dataId).values,c=r.shape.length,h=l.data.get(i.dataId).values,d=i.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:x,outWidth:y,padInfo:v,strideHeight:b,strideWidth:w,filterHeight:S,filterWidth:_,dilationHeight:I,dilationWidth:k,outShape:M}=ew(r.shape,i.shape,s,a,"NHWC",o),T=pf(M),C=M.length,E=_f(r.dtype,T);for(let t=0;t<p;++t)for(let e=0;e<x;++e){const n=e*b-v.top;for(let s=0;s<y;++s){const a=s*w-v.left;for(let o=0;o<g;++o){let l=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const s=n+e*I;if(s>=0&&s<f)for(let n=0;n<_;++n){const p=a+n*k;if(p>=0&&p<m){const a=zf([t,s,p,o],c,Rf(r.shape)),f=zf([e,n,o],d,Rf(i.shape)),m=u[a]+h[f];m>l&&(l=m)}}}E[zf([t,e,s,o],C,Rf(M))]=l}}}return{dataId:l.write(My(E,r.dtype),M,r.dtype),shape:M,dtype:r.dtype}}},k$={kernelName:Vm,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:i,dy:s}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=Lf(r.shape,u.data.get(r.dataId).values),h=Lf(i.shape,u.data.get(i.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:x,padInfo:y,strideHeight:v,strideWidth:b,filterHeight:w,filterWidth:S,dilationHeight:_,dilationWidth:I,outShape:k}=ew(r.shape,i.shape,a,o,"NHWC",l);uf(s.rank===k.length,(()=>`Error in ${Vm}, dy must have the same rank as output ${k.length}, but got ${s.rank}`));const M=Lf(k,u.data.get(s.dataId).values),T=Pf(i.shape,i.dtype);for(let t=0;t<d;++t)for(let e=0;e<g;++e){const n=e*v-y.top;for(let r=0;r<x;++r){const i=r*b-y.left;for(let s=0;s<m;++s){let a=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let e=0;e<w;++e){const r=n+e*_;if(r>=0&&r<p)for(let n=0;n<S;++n){const u=i+n*I;if(u>=0&&u<f){const i=c[t][r][u][s]+h[e][n][s];i>a&&(a=i,o=e,l=n)}}}T[o][l][s]+=M[t][e][r][s]}}}return{dataId:u.write(My(T,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},M$={kernelName:Wm,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:i,dy:s}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=Lf(r.shape,u.data.get(r.dataId).values),h=Lf(i.shape,u.data.get(i.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:x,padInfo:y,strideHeight:v,strideWidth:b,filterHeight:w,filterWidth:S,dilationHeight:_,dilationWidth:I,outShape:k}=ew(r.shape,i.shape,a,o,"NHWC",l);uf(s.rank===k.length,(()=>`Error in ${Wm}, dy must have the same rank as output ${k.length}, but got ${s.rank}`));const M=Lf(k,u.data.get(s.dataId).values),T=Pf(r.shape,r.dtype);for(let t=0;t<d;++t)for(let e=0;e<g;++e){const n=e*v-y.top;for(let r=0;r<x;++r){const i=r*b-y.left;for(let s=0;s<m;++s){let a=Number.MIN_SAFE_INTEGER,o=n<0?0:n,l=i<0?0:i;for(let e=0;e<w;++e){const r=n+e*_;if(r>=0&&r<p)for(let n=0;n<S;++n){const u=i+n*I;if(u>=0&&u<f){const i=c[t][r][u][s]+h[e][n][s];i>a&&(a=i,o=r,l=u)}}}T[t][o][l][s]+=M[t][e][r][s]}}}return{dataId:u.write(My(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},T$=TL(((t,e)=>t*e)),C$=KL(((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n}))),E$=XL(zg,T$,C$),A$={kernelName:zg,backendName:"cpu",kernelFunc:E$};function N$(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;let o;gL(i,"sum"),o="bool"===i.dtype?jL({inputs:{x:i},backend:n,attrs:{dtype:"int32"}}):_L({inputs:{x:i},backend:n});const l=o.shape.length,u=bf(s,o.shape),c=gS(u,l);let h=u,d=o;null!=c&&(d=pF({inputs:{x:o},backend:n,attrs:{perm:c}}),h=yS(h.length,l)),mS("sum",h,d.shape.length);const[p,f]=pS(d.shape,h);let m=WL(n,p,tv(d.dtype,"int32"));const g=pf(f),x=n.data.get(m.dataId).values,y=n.data.get(d.dataId).values;for(let t=0;t<x.length;++t){const e=t*g;let n=0;for(let t=0;t<g;++t)n+=y[e+t];x[t]=n}if(a){const t=m;m=tF({inputs:{x:m},backend:n,attrs:{shape:fS(m.shape,u)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),m}const R$={kernelName:Ix,backendName:"cpu",kernelFunc:N$},D$={kernelName:Hm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:i}=r,s=e,{allDims:a,summedDims:o,idDims:l}=ak(i,s.length);lk(a.length,l,s);const{path:u,steps:c}=uk(o,l),h=c.length;let d=null,p=a.length;const f=[];for(let t=0;t<h;++t){for(const e of c[t]){const{permutationIndices:t,expandDims:r}=ok(p,l[e]);let i;ck(t)?i=s[e]:(i=pF({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(i));const a=i.shape.slice();for(let t=0;t<r.length;++t)a.splice(r[t],0,1);ff(i.shape,a)||(i=tF({inputs:{x:i},backend:n,attrs:{shape:a}}),f.push(i)),null===d?d=i:(d=E$({inputs:{a:i,b:d},backend:n}),f.push(d))}t<h-1&&(u[t]>=0&&(d=N$({inputs:{x:d},backend:n,attrs:{axis:u[t]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const t of f)t!==d&&n.disposeIntermediateTensorInfo(t);return d}},L$={kernelName:qm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:r,y:i}=e;gL([r,i],"eluGrad");const s=new Float32Array(pf(i.shape)),a=n.data.get(i.dataId).values,o=n.data.get(r.dataId).values;for(let t=0;t<a.length;++t){const e=a[t];s[t]=e>=1?o[t]:o[t]*(e+1)}return n.makeTensorInfo(i.shape,"float32",s)}},F$=TL(((t,e)=>t===e?1:0)),$$=XL(Km,F$,null,"bool"),P$={kernelName:Km,backendName:"cpu",kernelFunc:$$},O$=WI,z$=VI,B$=GI,U$=HI,W$=jI,V$=qI,G$=vL(Xm,(t=>{const e=Math.sign(t),n=Math.abs(t),r=1/(1+O$*n);return e*(1-((((V$*r+W$)*r+U$)*r+B$)*r+z$)*r*Math.exp(-n*n))})),H$={kernelName:Xm,backendName:"cpu",kernelFunc:G$},j$=FL((t=>Math.exp(t))),q$=bL(Ym,j$,"float32"),X$={kernelName:Ym,backendName:"cpu",kernelFunc:q$};function K$(t){const{inputs:e,backend:n,attrs:r}=t,{input:i}=e,{dim:s}=r,a=i.shape.length,o=i.shape.slice();let l=s;return s<0&&(uf(-(a+1)<=s,(()=>`Axis must be in the interval [${-(a+1)}, ${a}]`)),l=a+s+1),o.splice(l,0,1),tF({inputs:{x:i},backend:n,attrs:{shape:o}})}const Y$={kernelName:Zm,backendName:"cpu",kernelFunc:K$},Z$=FL((t=>Math.expm1(t))),J$=bL(Jm,Z$),Q$={kernelName:Jm,backendName:"cpu",kernelFunc:J$},tP=TL(((t,e)=>t/e)),eP=XL(Gm,tP),nP={kernelName:Gm,backendName:"cpu",kernelFunc:eP},rP=TL(((t,e)=>t-e)),iP=KL(((t,e,n,r)=>({real:t-n,imag:e-r}))),sP=XL(zx,rP,iP),aP={kernelName:zx,backendName:"cpu",kernelFunc:sP};function oP(t,e,n){const r=t.shape,i=r[0],s=r[1],a=n.data.get(t.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[i,s],c=pf(u),h=Sf("float32",c),d=Sf("float32",c);for(let t=0;t<i;t++){const r=zF({inputs:{x:o},backend:n,attrs:{begin:[t,0],size:[1,s]}}),i=zF({inputs:{x:l},backend:n,attrs:{begin:[t,0],size:[1,s]}}),a=BL({inputs:{real:r,imag:i},backend:n}),{real:u,imag:c}=lP(a,e,n),p=XI(u,c);for(let e=0;e<s;e++){const n=JI(p,e);h[t*s+e]=n.real,d[t*s+e]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),m=BL({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function lP(t,e,n){const r=pf(t.shape),i=n.data.get(t.dataId),s=n.data.get(i.complexTensorInfos.real.dataId).values,a=n.data.get(i.complexTensorInfos.imag.dataId).values;if(0==((o=r)&o-1)){const i=uP(s,a,r,e,n),o=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(o,"float32",i.real),e=n.makeTensorInfo(o,"float32",i.imag),s=n.makeTensorInfo([],"float32",ky(r,"float32")),a=_L({inputs:{x:s},backend:n}),l=nP.kernelFunc({inputs:{a:t,b:s},backend:n}),u=nP.kernelFunc({inputs:{a:e,b:a},backend:n}),c=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:h}}return i}{const t=function(t,e,n){const r=new Float32Array(2*e);for(let i=0;i<e;i++){let s=0,a=0;for(let r=0;r<e;r++){const o=ek(i*r,e,n),l=JI(t,r);s+=l.real*o.real-l.imag*o.imag,a+=l.real*o.imag+l.imag*o.real}n&&(s/=e,a/=e),QI(r,s,a,i)}return r}(XI(s,a),r,e);return KI(t)}var o}function uP(t,e,n,r,i){if(1===n)return{real:t,imag:e};const s=XI(t,e),a=n/2,o=YI(s),l=o.real,u=o.imag,c=[l.length],h=i.makeTensorInfo(c,"float32",l),d=i.makeTensorInfo(c,"float32",u),p=BL({inputs:{real:h,imag:d},backend:i}),f=ZI(s),m=f.real,g=f.imag,x=[m.length],y=i.makeTensorInfo(x,"float32",m),v=i.makeTensorInfo(x,"float32",g),b=BL({inputs:{real:y,imag:v},backend:i}),w=uP(l,u,a,r,i),S=w.real,_=w.imag,I=[S.length],k=i.makeTensorInfo(I,"float32",S),M=i.makeTensorInfo(I,"float32",_),T=BL({inputs:{real:k,imag:M},backend:i}),C=uP(m,g,a,r,i),E=C.real,A=C.imag,N=[E.length],R=i.makeTensorInfo(N,"float32",E),D=i.makeTensorInfo(N,"float32",A),L=BL({inputs:{real:R,imag:D},backend:i}),F=tk(n,r),$=[F.real.length],P=i.makeTensorInfo($,"float32",F.real),O=i.makeTensorInfo($,"float32",F.imag),z=BL({inputs:{real:P,imag:O},backend:i}),B=E$({inputs:{a:z,b:L},backend:i}),U=JL({inputs:{a:T,b:B},backend:i}),W=sP({inputs:{a:T,b:B},backend:i}),V=VL({inputs:{input:U},backend:i}),G=VL({inputs:{input:W},backend:i}),H=QF({inputs:{input:U},backend:i}),j=QF({inputs:{input:W},backend:i}),q=e$({inputs:[V,G],backend:i,attrs:{axis:0}}),X=e$({inputs:[H,j],backend:i,attrs:{axis:0}}),K=i.data.get(q.dataId).values,Y=i.data.get(X.dataId).values;return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(k),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(T),i.disposeIntermediateTensorInfo(R),i.disposeIntermediateTensorInfo(D),i.disposeIntermediateTensorInfo(L),i.disposeIntermediateTensorInfo(P),i.disposeIntermediateTensorInfo(O),i.disposeIntermediateTensorInfo(z),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(W),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(H),i.disposeIntermediateTensorInfo(G),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(q),i.disposeIntermediateTensorInfo(X),{real:K,imag:Y}}const cP={kernelName:Qm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,i=pf(r.shape),s=r.shape[r.shape.length-1],a=tF({inputs:{x:r},backend:n,attrs:{shape:[i/s,s]}}),o=oP(a,!1,n),l=tF({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}};function hP(t){const{backend:e,attrs:n}=t,{shape:r,value:i,dtype:s}=n,a=s||Ef(i),o=_f(a,pf(r));return function(t,e,n){t.fill(e)}(o,i),e.makeTensorInfo(r,a,o)}const dP={kernelName:tg,backendName:"cpu",kernelFunc:hP},pP={kernelName:eg,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,i=n,s=Sf(r.dtype,pf(r.shape)),[a,o,l,u]=r.shape,c=i.data.get(r.dataId).values;for(let t=0;t<a;t++){const e=t*l*o*u;for(let t=0;t<o;t++){const n=t*(l*u);for(let t=0;t<l;t++){const r=t*u;for(let i=0;i<u;i++){const a=Math.round(l-t-1),o=e+n+r+i;let h=c[o];a>=0&&a<l&&(h=c[e+n+a*u+i]),s[o]=h}}}}return{dataId:i.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},fP=FL((t=>Math.floor(t))),mP=bL(ng,fP),gP={kernelName:ng,backendName:"cpu",kernelFunc:mP},xP=TL(((t,e)=>Math.floor(t/e))),yP=XL(rg,xP,null,"int32"),vP={kernelName:rg,backendName:"cpu",kernelFunc:yP},bP={kernelName:Qx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=r$({inputs:{x:i,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;if("NCHW"===c&&1===a.shape.length&&1!==a.shape[0]){const t=tF({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});m=JL({inputs:{a:m,b:t},backend:n}),n.disposeIntermediateTensorInfo(t)}else m=JL({inputs:{a:m,b:a},backend:n});n.disposeIntermediateTensorInfo(t)}if(p){const t=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const t=tF({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=zL(n,m,p,t,f),n.disposeIntermediateTensorInfo(t)}else m=zL(n,m,p,o,f);n.disposeIntermediateTensorInfo(t)}return m}},wP={kernelName:ty,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=v$({inputs:{x:i,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;m=JL({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=zL(n,m,p,o,f),n.disposeIntermediateTensorInfo(t)}return m}};function SP(t,e,n,r,i,s,a,o,l){const u=sb([r,s],n);for(let n=0;n<r;n++){const r=[];let c=0;for(let e=0;e<i;e++){const s=t[n*i+e];c+=s*a[e],r.push(s)}if(c<0||c>=l/s)throw new Error(`Invalid indices: ${r} does not index into ${o}`);for(let t=0;t<s;t++)u.values[n*s+t]=e.get(...e.indexToLoc(c*s+t))}return u}const _P={kernelName:ag,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:i}=e,s=pf(r.shape),a=i.shape,o=a[a.length-1],[l,u,c,h]=$I(r,i);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const d=SP(n.data.get(i.dataId).values,n.bufferSync(r),r.dtype,u,o,c,h,r.shape,s);return n.makeTensorInfo(l,r.dtype,d.values)}};function IP(t,e,n){const r=sb(n,t.dtype);for(let n=0;n<r.size;++n){const i=r.indexToLoc(n).slice(),s=i[0],a=i[2],o=e.locToIndex([s,a]);i[2]=e.values[o];const l=t.locToIndex(i);0<=l&&l<t.values.length&&(r.values[n]=t.values[l])}return r}const kP={kernelName:sg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,indices:s}=e,{axis:a,batchDims:o}=r;gL([i,s],"gatherV2");const l=bf(a,i.shape)[0],u=n.data.get(s.dataId).values,c=i.shape[l];for(let t=0;t<u.length;++t){const e=u[t];uf(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let h=o;null==o&&(h=0);const d=pf(s.shape),p=Tk(i,s,l,h),f=tF({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=tF({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],x=n.bufferSync(m),y=IP(n.bufferSync(f),x,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},MP=TL(((t,e)=>t>e?1:0)),TP=XL(og,MP,null,"bool"),CP={kernelName:og,backendName:"cpu",kernelFunc:TP},EP=TL(((t,e)=>t>=e?1:0)),AP=XL(lg,EP,null,"bool"),NP={kernelName:lg,backendName:"cpu",kernelFunc:AP},RP={kernelName:cg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,i=pf(r.shape),s=r.shape[r.shape.length-1],a=tF({inputs:{x:r},backend:n,attrs:{shape:[i/s,s]}}),o=oP(a,!0,n),l=tF({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}},DP=vL(dg,(t=>Number.isFinite(t)?1:0),"bool"),LP={kernelName:dg,backendName:"cpu",kernelFunc:DP},FP=vL(pg,(t=>Math.abs(t)===1/0?1:0),"bool"),$P={kernelName:pg,backendName:"cpu",kernelFunc:FP},PP=vL(fg,(t=>Number.isNaN(t)?1:0),"bool"),OP={kernelName:fg,backendName:"cpu",kernelFunc:PP},zP=TL(((t,e)=>t<e?1:0)),BP=XL(gg,zP,null,"bool"),UP={kernelName:gg,backendName:"cpu",kernelFunc:BP},WP=TL(((t,e)=>t<=e?1:0)),VP=XL(xg,WP,null,"bool"),GP={kernelName:xg,backendName:"cpu",kernelFunc:VP};function HP(t,e,n){const r=(e-t)/(n-1),i=$f(n,"float32");i[0]=t;for(let t=1;t<i.length;t++)i[t]=i[t-1]+r;return i}const jP={kernelName:yg,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:i,num:s}=n,a=HP(r,i,s);return e.makeTensorInfo([a.length],"float32",a)}},qP=FL((t=>Math.log(t))),XP=bL(vg,qP),KP={kernelName:vg,backendName:"cpu",kernelFunc:XP},YP=vL(bg,(t=>Math.log1p(t))),ZP={kernelName:bg,backendName:"cpu",kernelFunc:YP},JP=TL(((t,e)=>t&&e)),QP=XL(wg,JP,null,"bool"),tO={kernelName:wg,backendName:"cpu",kernelFunc:QP},eO=vL(Sg,(t=>t?0:1),"bool"),nO={kernelName:Sg,backendName:"cpu",kernelFunc:eO},rO=TL(((t,e)=>t||e)),iO=XL(_g,rO,null,"bool"),sO={kernelName:_g,backendName:"cpu",kernelFunc:iO},aO={kernelName:Ig,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{depthRadius:s,bias:a,alpha:o,beta:l}=r;gL(i,"LRN");const u=i.shape[3],c=u-1,h=n.data.get(i.dataId).values,d=pf(i.shape),p=new Float32Array(d);function f(t){const e=t%u;let n=t-e+Math.max(0,e-s);const r=t-e+Math.min(e+s,c);let i=0;for(;n<=r;n++){const t=h[n];i+=t*t}return i}for(let t=0;t<d;t++){const e=f(t),n=h[t]*Math.pow(a+o*e,-l);p[t]=n}return n.makeTensorInfo(i.shape,i.dtype,p)}},oO={kernelName:kg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,y:s,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r;gL(a,"LRNGrad");const h=pf(a.shape),d=a.shape[3],p=n.data.get(a.dataId).values,f=n.data.get(i.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(h),x=h;for(let t=0;t<x;t++){const e=t%d,n=t-e+Math.max(0,e-o),r=t-e+Math.min(d,e+o+1);let i=0;for(let t=n;t<r;t++)i+=Math.pow(f[t],2);i=u*i+l;for(let e=n;e<r;e++){let n=-2*u*c*f[e]*m[t]/i;t===e&&(n+=Math.pow(i,-c)),n*=p[t],g[e]+=n}}return n.makeTensorInfo(a.shape,i.dtype,g)}};function lO(t,e,n,r){const i=Sf(r,pf(n));for(let n=0;n<i.length;++n){const r=n*e;let s=t[r];for(let n=0;n<e;++n){const e=t[r+n];(Number.isNaN(e)||e>s)&&(s=e)}i[n]=s}return i}function uO(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reductionIndices:s,keepDims:a}=r,o=n;let l=i.shape;const u=l.length,c=bf(s,l);let h=c;const d=gS(h,u);let p=o.data.get(i.dataId).values;if(null!=d){const t=new Array(u);for(let e=0;e<t.length;e++)t[e]=l[d[e]];p=dF(p,l,i.dtype,d,t),h=yS(h.length,u),l=t}gL(i,"max"),mS("max",h,u);const[f,m]=pS(l,h),g=lO(p,pf(m),f,i.dtype),x=o.write(g,f,i.dtype);let y=f;return a&&(y=fS(f,c)),{dataId:x,shape:y,dtype:i.dtype}}const cO={kernelName:Mg,backendName:"cpu",kernelFunc:uO},hO=TL(((t,e)=>Math.max(t,e))),dO=XL(Tg,hO),pO={kernelName:Tg,backendName:"cpu",kernelFunc:dO},fO={kernelName:Cg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;gL(i,"maxPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;uf(dw(a,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=nw(i.shape,s,a,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&ff(u.inShape,u.outShape))c=_L({inputs:{x:i},backend:n});else{const t=n.data.get(i.dataId).values,e=Rf(i.shape),r=AF(t,i.shape,i.dtype,e,u,"max");c=n.makeTensorInfo(u.outShape,i.dtype,r.values)}return c}},mO={kernelName:Ag,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r;gL(i,"maxPool3d");const c=rw(i.shape,s,a,1,o,l,u),h=RF(n.data.get(i.dataId).values,i.shape,i.dtype,Rf(i.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},gO={kernelName:Ng,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;gL([i,s],"maxPool3DGrad");const c=rw(s.shape,a,o,1,l,u),h=function(t,e){const n=sb(e.outShape,"int32"),r=e.strideDepth,i=e.strideHeight,s=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let x=0;x<e.outDepth;++x){const y=x*r-d;let v=y;for(;v<0;)v+=a;const b=Math.min(e.inDepth,u+y);for(let r=0;r<e.outHeight;++r){const u=r*i-p;let d=u;for(;d<0;)d+=o;const w=Math.min(e.inHeight,c+u);for(let i=0;i<e.outWidth;++i){const p=i*s-f;let S=p;for(;S<0;)S+=l;const _=Math.min(e.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,k=-1;for(let e=v;e<b;e+=a){const n=e-y;for(let r=d;r<w;r+=o){const i=r-u;for(let s=S;s<_;s+=l){const a=s-p,o=t.get(m,e,r,s,g);o>=I&&(I=o,k=n*c*h+i*c+a)}}}n.set(k,m,x,r,i,g)}}}return n}(n.bufferSync(s),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,x=c.dilationWidth,y=c.effectiveFilterDepth,v=c.effectiveFilterHeight,b=c.effectiveFilterWidth,w=y-1-c.padInfo.front,S=b-1-c.padInfo.left,_=v-1-c.padInfo.top,I=sb(s.shape,"float32"),k=n.bufferSync(i);for(let t=0;t<c.batchSize;++t)for(let e=0;e<c.inChannels;++e)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let i=0;i<c.inWidth;++i){const s=n-w,a=r-_,o=i-S;let l=0;for(let n=0;n<y;n+=m){const r=(s+n)/d;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let i=0;i<v;i+=g){const s=(a+i)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let a=0;a<b;a+=x){const u=(o+a)/f;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const d=y*v*b-1-h.get(t,r,s,u,e)===n*v*b+i*b+a?1:0;0!==d&&(l+=k.get(t,r,s,u,e)*d)}}}I.set(l,t,n,r,i,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},xO={kernelName:Eg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s,output:a}=e,o=s;gL([s,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=nw(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=sb(d.outShape,o.dtype,NF(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,x=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterHeight,b=d.effectiveFilterWidth,w=b-1-d.padInfo.left,S=v-1-d.padInfo.top,_=sb(o.shape,"float32"),I=n.data.get(i.dataId).values,k=sb(i.shape,"float32",I);for(let t=0;t<d.batchSize;++t)for(let e=0;e<d.inChannels;++e)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){const i=n-S,s=r-w;let a=0;for(let n=0;n<v;n+=x){const r=(i+n)/m;if(!(r<0||r>=d.outHeight||Math.floor(r)!==r))for(let i=0;i<b;i+=y){const o=(s+i)/g;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const l=v*b-1-f.get(t,r,o,e)===n*b+i?1:0;0!==l&&(a+=k.get(t,r,o,e)*l)}}_.set(a,t,n,r,e)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}},yO={kernelName:Rg,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=e,l=n;gL(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=nw(r.shape,i,s,[1,1],a),[h,d]=function(t,e,n,r,i){const s=AF(t,0,n,Rf(e),i,"max"),a=NF(t,e,n,i,!0,r);return[s.values,a.values]}(u,r.shape,r.dtype,o,c),p=l.write(h,c.outShape,r.dtype),f=l.write(d,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},vO={kernelName:Dg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=bf(s,i.shape),l=pf(pS(i.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const h=jL({inputs:{x:i},backend:n,attrs:{dtype:"float32"}});u.push(h);const d=eP({inputs:{a:h,b:c},backend:n});u.push(d);const p=N$({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:a}});return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}},bO={kernelName:Lg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;gL(i,"min");const o=bf(s,i.shape);let l=o;const u=gS(l,i.shape.length);let c=i;null!=u&&(c=pF({inputs:{x:i},backend:n,attrs:{perm:u}}),l=yS(l.length,i.shape.length)),mS("min",l,c.shape.length);const[h,d]=pS(c.shape,l),p=pf(d),f=$f(pf(h),c.dtype),m=n.data.get(c.dataId).values;for(let t=0;t<f.length;++t){const e=t*p;let n=m[e];for(let t=0;t<p;++t){const r=m[e+t];(Number.isNaN(r)||r<n)&&(n=r)}f[t]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const t=tF({inputs:{x:g},backend:n,attrs:{shape:fS(h,o)}});return n.disposeIntermediateTensorInfo(g),t}return g}},wO=TL(((t,e)=>Math.min(t,e))),SO=XL(Fg,wO),_O={kernelName:Fg,backendName:"cpu",kernelFunc:SO},IO={kernelName:$g,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:s,mode:a}=r;gL(i,"mirrorPad");const o=s.map(((t,e)=>t[0]+i.shape[e]+t[1])),l=s.map((t=>t[0])),u=s.map(((t,e)=>t[0]+i.shape[e])),c="reflect"===a?0:1,h=n.data.get(i.dataId).values,d=i.shape.length,p=Rf(i.shape),f=pf(o),m=o.length,g=Rf(o),x=Sf(i.dtype,f);for(let t=0;t<f;t++){let e=Bf(t,m,g);for(let t=0;t<m;t++)e[t]<l[t]?e[t]=2*l[t]-e[t]-c:e[t]>=u[t]&&(e[t]=2*(u[t]-1)-e[t]+c);e=e.map(((t,e)=>t-l[e]));const n=zf(e,d,p);x[t]=h[n]}return{dataId:n.write(x,o,i.dtype),shape:o,dtype:i.dtype}}},kO=TL(((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})),MO=XL(Pg,kO),TO={kernelName:Pg,backendName:"cpu",kernelFunc:MO};function CO(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{dim:s}=r,a=i.shape.length;let o=s;if(-1===o&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=bf([o],i.shape),u=uO({inputs:{x:i},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=fS(u.shape,l),h=tF({inputs:{x:u},backend:n,attrs:{shape:c}}),d=sP({inputs:{a:i,b:h},backend:n}),p=q$({inputs:{x:d},backend:n}),f=N$({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=tF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=eP({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const EO={kernelName:Tx,backendName:"cpu",kernelFunc:CO},AO={kernelName:Og,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{numSamples:s,seed:a,normalized:o}=r;gL(i,"multinomial");const l=o?i:CO({inputs:{logits:i},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,s],p=$f(pf(d),"int32");for(let t=0;t<u;++t){const e=t*c,n=new Float32Array(c-1);n[0]=h[e];for(let t=1;t<n.length;++t)n[t]=n[t-1]+h[e+t];const r=ES.alea(a.toString()),i=t*s;for(let t=0;t<s;++t){const e=r();p[i+t]=n.length;for(let r=0;r<n.length;r++)if(e<n[r]){p[i+t]=r;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function NO(t,e,n){const r=ky(-1,n);return T$([],e,r,t,n)}const RO={kernelName:Bg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;gL(r,"neg");const i=n.data.get(r.dataId).values,[s,a]=NO(i,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,s)}},DO=D_,LO={kernelName:Wg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r;gL(i,"NonMaxSuppression");const u=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:h}=DO(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},FO=L_,$O={kernelName:Vg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;gL(i,"NonMaxSuppressionPadded");const c=n.data.get(i.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=FO(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},PO=F_,OO={kernelName:Gg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;gL(i,"NonMaxSuppressionWithScore");const c=n.data.get(i.dataId).values,h=n.data.get(s.dataId).values,d=a,p=o,f=l,m=u,{selectedIndices:g,selectedScores:x}=PO(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}},zO=TL(((t,e)=>t!==e?1:0)),BO=XL(Ug,zO,null,"bool"),UO={kernelName:Ug,backendName:"cpu",kernelFunc:BO},WO={kernelName:jg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{dtype:s,depth:a,onValue:o,offValue:l}=r;gL(i,"oneHot");const u=pf(i.shape),c=new Float32Array(u*a);c.fill(l);const h=n.data.get(i.dataId).values;for(let t=0;t<u;++t)h[t]>=0&&h[t]<a&&(c[t*a+h[t]]=o);return n.makeTensorInfo([...i.shape,a],s,c)}};function VO(t){const{inputs:e,backend:n}=t,{x:r}=e;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const t=VL({inputs:{input:r},backend:n}),e=VO({inputs:{x:t},backend:n}),i=QF({inputs:{input:r},backend:n}),s=VO({inputs:{x:i},backend:n}),a=BL({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),a}return hP({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const GO={kernelName:Kx,backendName:"cpu",kernelFunc:VO},HO={kernelName:Hg,backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===i.dtype){const e=VL({inputs:{input:i},backend:r}),n=t({inputs:{x:e},backend:r}),s=QF({inputs:{input:i},backend:r}),a=VO({inputs:{x:s},backend:r}),o=BL({inputs:{real:n,imag:a},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(a),o}return hP({backend:r,attrs:{shape:i.shape,value:1,dtype:i.dtype}})}};function jO(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(1===e.length)return K$({inputs:{input:e[0]},backend:n,attrs:{dim:i}});const s=e[0].shape,a=e[0].dtype;e.forEach((t=>{cf(s,t.shape,"All tensors passed to stack must have matching shapes"),uf(a===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=e$({inputs:e.map((t=>{const e=K$({inputs:{input:t},backend:n,attrs:{dim:i}});return o.push(e),e})),backend:n,attrs:{axis:i}});return o.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}const qO={kernelName:qg,backendName:"cpu",kernelFunc:jO},XO={kernelName:Xg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:s,constantValue:a}=r;gL(i,"pad");const o=s.map(((t,e)=>t[0]+i.shape[e]+t[1])),l=s.map((t=>t[0])),u=n.data.get(i.dataId).values,c=pf(i.shape),h=i.shape.length,d=Rf(i.shape),p=pf(o),f=o.length,m=Rf(o),g=Sf(i.dtype,p);0!==a&&g.fill(a);for(let t=0;t<c;t++)g[zf(Bf(t,h,d).map(((t,e)=>t+l[e])),f,m)]=u[t];return{dataId:n.write(g,o,i.dtype),shape:o,dtype:i.dtype}}},KO=TL(((t,e)=>Math.pow(t,e))),YO=XL(Kg,KO),ZO={kernelName:Kg,backendName:"cpu",kernelFunc:YO};function JO(t,e,n,r){const[i,s]=pS(t,r),a=tv(e,"int32"),o=$f(pf(i),a),l=pf(s);for(let t=0;t<o.length;++t){const e=t*l;let r=1;for(let t=0;t<l;++t)r*=n[e+t];o[t]=r}return{outVals:o,outShape:i,outDtype:a}}const QO={kernelName:Zg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;gL(i,"prod");const o=i.shape.length,l=bf(s,i.shape),u=gS(l,o);let c=l,h=i;const d=[];null!=u&&(h=pF({inputs:{x:i},backend:n,attrs:{perm:u}}),d.push(h),c=yS(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=JO(h.shape,h.dtype,p,c);let x=m;return a&&(x=fS(m,l)),d.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(x,g,f)}};function tz(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function ez(t,e,n,r,i,s,a,o){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===e[0].length)throw new Error("Split tensors must not be scalars");if(function(t,e,n){t.forEach(((t,r)=>{if(t<0||t>=n){const i=Bf(r,e.length,Rf(e)).join(",");throw new Error(`indices[${i}] = ${t} is not in [0, ${n})`)}}))}(s,a,e[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:h}=function(t,e,n,r){const i=[];let s=0;const a=e.length-1+n.length,o=new Array(a).fill(null).map((()=>[0]));!function(t,e){for(let n=0;n<t.length;++n){const r=t[n],i=n===t.length-1?e:t[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let t=1;t<r.length;++t)if(r[t-1]>r[t])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let t=0;t<e.length-1;++t){l*=e[t];const n=e[t+1];for(let e=1;e<l+1;++e)o[t].push(e*n)}for(let r=0;r<t.length;++r){let a=t[r],l=t[r]+1;for(let t=0;t<n.length;++t){const r=n[t],i=t+e.length-1;if(i>=0){const t=o[i],e=t[t.length-1]-r[a];for(let t=a;t<l;++t)o[i].push(r[t+1]+e)}a=r[a],l=r[l]}l!==a&&(i.push([a,l]),s+=l-a)}return{outSplits:o,valueSlices:i,numValues:s}}(s,a,t,l),d=function(t){const e=[];for(let n=0;n<t.length;++n){const r=_f("int32",t[n].length);e.push(r),t[n].forEach(((t,e)=>r[e]=t))}return e}(u),p=function(t,e,n,r,i){const s=e.slice();s[0]=i;const a=_f(n,pf(s)),o=t.length;return function(t,e,n,r,i,s){const a=tz(e,2)[1],o=tz(s,2)[1];let l=0;for(const e of n)for(let n=e[0];n<e[1];++n){for(let e=0;e<r;++e)i[l*o+e]=t[n*a+e];++l}}(t,e,r,0===o?0:o/e[0],a,s),[a,s]}(n,r,i,c,h);return[d,p[0],p[1]]}const nz={kernelName:Jg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:i,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:o}=r,l=i.map((t=>n.data.get(t.dataId).values)),u=i.map((t=>t.shape)),c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,[d,p,f]=ez(l,u,c,s.shape,s.dtype,h,a.shape),m=d.map((t=>n.makeTensorInfo([t.length],"int32",t))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var rz=_I;class iz{constructor(t,e,n,r,i,s,a,o,l,u){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=r,this.valuesDType=i,this.defaultValue=s,this.defaultValueShape=a,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=kI(u),this.raggedRank=MI(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===rz.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===rz.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case rz.VALUE_ROWIDS:return iz.getMaxWidthValueRowID(e);case rz.ROW_SPLITS:return iz.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${rz[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let n=0;for(let r=0;r<e-1;++r){const e=t[r+1]-t[r];e>n&&(n=e)}return n}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let n=0,r=t[0],i=0;for(let s=1;s<e;++s){const e=t[s];e!==r&&(r=e,i=Math.max(s-n,i),n=s)}return Math.max(e-n,i)}tensorShapeFromTensor(t,e,n=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return az(t,n)}calculateOutputSize(t){const e=this.valuesShape;TI(this.defaultValueShape,e);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=II(this.raggedRank,n,e);r[0]<0&&(r[0]=t);for(let t=1;t<=this.raggedRank;++t)r[t]<0&&(r[t]=this.getMaxWidth(t));return r}calculateFirstParentOutputIndex(t,e,n){const r=Math.min(t,n),i=[];let s=0;for(let t=0;t<r;++t,s+=e)i.push(s);for(let e=r;e<t;++e)i.push(-1);return uf(i.length===t,(()=>"Final length of result must be equal to firstDimension.")),i}calculateOutputIndexRowSplit(t,e,n,r){const i=t.length,s=[];for(let a=0;a<i-1;++a){const i=t[a+1]-t[a];let o=Math.min(r,i),l=e[a];-1===l&&(o=0);for(let t=0;t<o;++t)s.push(l),l+=n;for(let t=0;t<i-o;++t)s.push(-1)}if(i>0&&s.length!==t[i-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,e,n,r){const i=t.length,s=[];if(0===i)return[];let a=0,o=t[0];if(o>=e.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${e.length}`);let l=e[o];s.push(l);for(let u=1;u<i;++u){const i=t[u];if(i===o)l>=0&&(++a,a<r?l+=n:l=-1);else{if(a=0,o=i,i>=e.length)throw new Error(`Got nextValueRowId=${i} which is not less than ${e.length}`);l=e[i]}s.push(l)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,e,n,r){const i=this.getRowPartitionTensor(t),s=this.getRowPartitionTypeByDimension(t);switch(s){case rz.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,n,r);case rz.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,n,r);default:throw new Error(`Unsupported partition type: ${rz[s]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case rz.FIRST_DIM_SIZE:return t[0];case rz.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case rz.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${rz[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),e=this.calculateOutputSize(t),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let t=n.length-2;t>=0;--t)n[t]=n[t+1]*e[t+1];const r=az(e,!1),i=_f(this.valuesDType,pf(r));if(n[0]*e[0]>0){let s=this.calculateFirstParentOutputIndex(t,n[0],e[0]);for(let t=1;t<=this.raggedRank;++t)s=this.calculateOutputIndex(t-1,s,n[t],e[t]);this.setOutput(this.raggedRank,s,i,r)}return[r,i]}setOutput(t,e,n,r){if(0===n.length)return;const i=this.values,s=n;let a=r.slice();a=a.slice(t+1);const o=pf(a),l=e.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const t=this.defaultValueShape;Wb((()=>{const e=mw(u,t),n=Sw(e,a);u=n.dataSync()}))}let c=0,h=0,d=0;for(let t=0;t<=l;++t){let r=t<l?e[t]:-1;if(r!==d){if(h<d){const t=i.subarray(c*o);sz(s.subarray(h*o),t,(d-h)*o)}if(t>=l){const t=n.length;r=Math.floor(t/o)}if(r>d)if(1===this.defaultValue.length)s.subarray(d*o,r*o).fill(this.defaultValue[0]),d=r;else for(;r>d;)sz(s.slice(d*o),u,o),++d;r<0?(c=t+1,h=d):(c=t,h=d,d=h+1)}else++d}}}function sz(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function az(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function oz(t,e,n,r,i,s,a,o,l,u){return new iz(t,e,n,r,i,s,a,o,l,u).compute()}const lz={kernelName:Qg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{shape:i,values:s,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=r,u=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,d=o.map((t=>n.data.get(t.dataId).values)),p=o.map((t=>t.shape)),[f,m]=oz(u,i.shape,c,s.shape,s.dtype,h,a.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,m)}};function uz(t,e,n,r){if(t===e||t<e&&n<0||e<t&&n>1)return $f(0,r);const i=$f(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),i[0]=t;for(let t=1;t<i.length;t++)i[t]=i[t-1]+n;return i}const cz={kernelName:tx,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:i,dtype:s,step:a}=n,o=uz(r,i,a,s);return e.makeTensorInfo([o.length],s,o)}},hz=vL(nx,(t=>1/t)),dz={kernelName:nx,backendName:"cpu",kernelFunc:hz},pz={kernelName:ox,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r;gL(i,"resizeBilinear");const l=Rf(i.shape),[u,c]=o,[h,d,p,f]=i.shape,m=n.data.get(i.dataId).values,g=new Float32Array(pf([h,u,c,f])),x=[s&&u>1?d-1:d,s&&c>1?p-1:p],y=[s&&u>1?u-1:u,s&&c>1?c-1:c];let v=0;const b=x[0]/y[0],w=x[1]/y[1];for(let t=0;t<h;t++)for(let e=0;e<u;e++){let n;n=a?b*(e+.5)-.5:b*e;const r=Math.max(0,Math.floor(n)),i=n-r,s=Math.min(d-1,Math.ceil(n)),o=t*l[0]+r*l[1],u=t*l[0]+s*l[1];for(let t=0;t<c;t++){let e;e=a?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),r=e-n,s=Math.min(p-1,Math.ceil(e)),c=o+n*l[2],h=u+n*l[2],d=o+s*l[2],x=u+s*l[2];for(let t=0;t<f;t++){const e=m[c+t],n=m[h+t],s=e+(m[d+t]-e)*r,a=s+(n+(m[x+t]-n)*r-s)*i;g[v++]=a}}}return n.makeTensorInfo([h,u,c,f],"float32",g)}},fz={kernelName:lx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r;gL([s,i],"resizeBilinearGrad");const o=Rf(i.shape),[l,u,c,h]=i.shape,[,d,p]=s.shape,f=new Float32Array(l*u*c*h),m=[a&&d>1?u-1:u,a&&p>1?c-1:c],g=[a&&d>1?d-1:d,a&&p>1?p-1:p],x=m[0]/g[0],y=m[1]/g[1],v=n.data.get(s.dataId).values;let b=0;for(let t=0;t<l;t++){const e=t*o[0];for(let t=0;t<d;t++){const n=t*x,r=Math.floor(n),i=Math.min(Math.ceil(n),u-1),s=e+r*o[1],a=e+i*o[1],l=n-r,d=1-l;for(let t=0;t<p;t++){const e=t*y,n=Math.floor(e),r=Math.min(Math.ceil(e),c-1),i=e-n,u=1-i,p=s+n*o[2],m=s+r*o[2],g=a+n*o[2],x=a+r*o[2],w=d*u,S=d*i,_=l*u,I=l*i;for(let t=0;t<h;t++){const e=v[b++];f[p+t]+=e*w,f[m+t]+=e*S,f[g+t]+=e*_,f[x+t]+=e*I}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}},mz={kernelName:sx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r;gL(i,"resizeNearestNeighbor");const l=Rf(i.shape),[u,c]=o,[h,d,p,f]=i.shape,m=n.data.get(i.dataId).values,g=new Float32Array(h*u*c*f),x=[s&&u>1?d-1:d,s&&c>1?p-1:p],y=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=x[0]/y[0],b=x[1]/y[1];let w=0;for(let t=0;t<h;t++){const e=t*l[0];for(let t=0;t<u;t++){const n=a?v*(t+.5):v*t;let r=Math.min(d-1,s?Math.round(n):Math.floor(n));a&&(r=Math.max(0,r));const i=e+r*l[1];for(let t=0;t<c;t++){const e=a?b*(t+.5):b*t;let n=Math.min(p-1,s?Math.round(e):Math.floor(e));a&&(n=Math.max(0,n));const r=i+n*l[2];for(let t=0;t<f;t++){const e=m[r+t];g[w++]=e}}}}return n.makeTensorInfo([h,u,c,f],i.dtype,g)}},gz={kernelName:ax,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r;gL([s,i],"resizeNearestNeighborGrad");const o=Rf(i.shape),l=Rf(s.shape),[u,c,h,d]=i.shape,[,p,f]=s.shape,m=new Float32Array(u*c*h*d),g=n.data.get(s.dataId).values,x=[a&&p>1?c-1:c,a&&f>1?h-1:h],y=[a&&p>1?p-1:p,a&&f>1?f-1:f],v=x[0]/y[0],b=x[1]/y[1],w=1/v,S=1/b,_=2*Math.ceil(w)+2,I=2*Math.ceil(S)+2;for(let t=0;t<u;t++){const e=t*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),i=Math.floor(r-_/2);for(let r=0;r<h;r++){const s=n+r*o[2],u=Math.floor(r*S),x=Math.floor(u-I/2);for(let n=0;n<d;n++){let o=0;for(let s=0;s<_;s++){const u=s+i;if(u<0||u>=p)continue;const d=e+u*l[1],m=u*v;if(t===Math.min(c-1,a?Math.round(m):Math.floor(m)))for(let t=0;t<I;t++){const e=t+x;if(e<0||e>=f)continue;const i=d+e*l[2],s=e*b;r===Math.min(h-1,a?Math.round(s):Math.floor(s))&&(o+=g[i+n])}}m[s+n]=o}}}}return n.makeTensorInfo(i.shape,i.dtype,m)}},xz={kernelName:cx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:s}=r;gL(i,"reverse");const a=i.shape.length,o=bf(s,i.shape);if(0===a)return _L({inputs:{x:i},backend:n});const l=new Uy(i.shape,i.dtype),u=n.bufferSync(i);for(let t=0;t<l.size;t++){const e=l.indexToLoc(t),n=e.slice();o.forEach((t=>n[t]=i.shape[t]-1-n[t])),l.set(u.get(...n),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},yz={kernelName:Zx,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:i,fillValue:s,center:a}=e,o=n,l=Sf(r.dtype,pf(r.shape)),[u,c,h,d]=r.shape,[p,f]=AI(a,c,h),m=Math.sin(i),g=Math.cos(i),x=o.data.get(r.dataId).values;for(let t=0;t<u;t++){const e=t*h*c*d;for(let t=0;t<c;t++){const n=t*(h*d);for(let r=0;r<h;r++){const i=r*d;for(let a=0;a<d;a++){const o=[u,t,r,a],y=o[2],v=o[1];let b=(y-p)*g-(v-f)*m,w=(y-p)*m+(v-f)*g;b=Math.round(b+p),w=Math.round(w+f);let S=s;"number"!=typeof s&&(S=3===a?255:s[a]),b>=0&&b<h&&w>=0&&w<c&&(S=x[e+w*(h*d)+b*d+a]),l[e+n+i+a]=S}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},vz=vL(hx,(t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1})),bz={kernelName:hx,backendName:"cpu",kernelFunc:vz},wz=FL((t=>1/Math.sqrt(t))),Sz=bL(dx,wz),_z={kernelName:dx,backendName:"cpu",kernelFunc:Sz};function Iz(t,e,n,r,i,s,a,o,l,u){const c=[r/i,i],h=t.values,d=e.values;if(0===r)return sb(n,e.dtype);const p=sb(c,e.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let t=0;t<s;t++){const s=[];let l=0;for(let e=0;e<a;e++){const n=h[t*a+e];s.push(n),l+=n*o[e]}if(l<0||l>=r/i)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<i;n++)u?p.values[l*i+n]+=d[t*i+n]:p.values[l*i+n]=0===e.rank?d[0]:d[t*i+n]}return p}const kz={kernelName:px,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:i,updates:s}=e,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=zI(0,i,a),d=Iz(n.bufferSync(i),n.bufferSync(s),a,h,u,l,o,c,0,!0);return n.makeTensorInfo(a,d.dtype,d.values)}};function Mz(t,e){let n=0,r=t.length,i=0;for(;n<r;)i=Math.floor((n+r)/2),t[i]<e?n=i+1:r=i;return r}function Tz(t,e){let n=0,r=t.length,i=0;for(;n<r;)i=Math.floor((n+r)/2),t[i]<=e?n=i+1:r=i;return r}const Cz={kernelName:fx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:i,values:s}=e,{side:a}=r,o=function(t,e,n,r,i,s){const a=_f("int32",n*i);for(let o=0;o<n;++o){const n=t.slice(o*r,(o+1)*r),l=o*i;for(let t=0;t<i;++t)a[l+t]="left"===s?Mz(n,e[t+l]):Tz(n,e[t+l])}return a}(n.data.get(i.dataId).values,n.data.get(s.dataId).values,i.shape[0],i.shape[1],s.shape[1],a);return n.makeTensorInfo(s.shape,"int32",o)}},Ez={kernelName:mx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:i,e:s}=e;gL([r,i,s],"select");const a=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,u=n.data.get(s.dataId).values,c=tv(i.dtype,s.dtype),h=$f(pf(i.shape),c);let d=0;const p=0===a||a>1||1===i.shape.length?1:pf(i.shape.slice(1));for(let t=0;t<o.length;t++)for(let e=0;e<p;e++)1===o[t]?h[d++]=l[t]:h[d++]=u[t];return n.makeTensorInfo(i.shape,c,h)}},Az=BI,Nz=UI,Rz=vL(gx,(t=>t>=0?Nz*t:Az*(Math.exp(t)-1))),Dz={kernelName:gx,backendName:"cpu",kernelFunc:Rz},Lz=vL(bx,(t=>t<0?-1:t>0?1:0)),Fz={kernelName:bx,backendName:"cpu",kernelFunc:Lz},$z=vL(yx,(t=>Math.sin(t))),Pz={kernelName:yx,backendName:"cpu",kernelFunc:$z},Oz=vL(vx,(t=>Math.sinh(t))),zz={kernelName:vx,backendName:"cpu",kernelFunc:Oz},Bz=Math.log(1.1920928955078125e-7)+2,Uz=vL(Sx,(t=>{const e=t>-Bz,n=t<Bz,r=Math.exp(t);let i;return i=n?r:e?t:Math.log(1+r),i})),Wz={kernelName:Sx,backendName:"cpu",kernelFunc:Uz},Vz={kernelName:kx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,paddings:a}=r;gL([i],"spaceToBatchND");const o=pf(s),l=[[0,0]];l.push(...a);for(let t=1+s.length;t<i.shape.length;++t)l.push([0,0]);const u=XO.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),c=NI(u.shape,s,o,!1),h=RI(c.length,s.length,!1),d=DI(u.shape,s,o,!1),p=tF({inputs:{x:u},backend:n,attrs:{shape:c}}),f=pF({inputs:{x:p},backend:n,attrs:{perm:h}}),m=tF({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function Gz(t,e,n,r,i,s,a){const o=e[0],l=s[0],u=new Array(l),c=new Array(o),h=e[1];if(0===l){if(0!==o)throw new Error(pk(o));return[_f(n,0),[0,h],_f(i,0),u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let e=0;e<o;++e){const n=t[e*h];if(n<0)throw new Error(fk(e,n));if(n>=l)throw new Error(mk(e,n,l));++f[n],d=d&&n>=p,p=n}let m=!0;for(let t=0;t<l;++t){const e=0===f[t];u[t]=e,m=m&&!e,f[t]=Math.max(f[t],1),t>0&&(f[t]+=f[t-1])}if(m&&d){const e=t,n=r;for(let t=0;t<o;++t)c[t]=t;return[e,[o,h],n,u,c]}{const e=f[l-1],s=_f(n,e*h),d=_f(i,e),p=new Array(l).fill(0);for(let e=0;e<o;++e){const n=t[e*h],i=p[n],a=(0===n?0:f[n-1])+i;p[n]++;for(let n=0;n<h;++n)s[a*h+n]=t[e*h+n];d[a]=r[e],c[e]=a}for(let t=0;t<l;++t)if(0===p[t]){const e=0===t?0:f[t-1];s[e*h+0]=t;for(let t=1;t<h;++t)s[e*h+t]=0;d[e]=a}return[s,[e,h],d,u,c]}}const Hz={kernelName:Cx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:i,denseShape:s,defaultValue:a}=e;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n        ${i.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values[0],[h,d,p,f,m]=Gz(o,r.shape,r.dtype,l,i.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],i.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function jz(t,e,n,r,i){const s=pf(r),a=e[0],o=i.length,l=[];let u=1,c=-1;for(let t=0;t<o;++t){const e=i[t];if(-1===e){if(-1!==c)throw new Error(gk(c,t));c=t,l.push(1)}else{if(e<0)throw new Error(xk(t,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const t=Math.trunc(s/u);if(u*t!==s)throw new Error(vk(r,l));l[c]=t}if(pf(l)!==s)throw new Error(bk(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let t=h-2;t>=0;--t)d[t]=d[t+1]*r[t+1]}const p=[];if(o>0){p[o-1]=1;for(let t=o-2;t>=0;--t)p[t]=p[t+1]*l[t+1]}const f=_f(n,a*o);for(let e=0;e<a;++e){let n=0;for(let r=0;r<h;++r)n+=t[e*h+r]*d[r];for(let t=0;t<o;++t)f[e*o+t]=Math.trunc(n/p[t]),n%=p[t]}return[f,[a,o],l]}const qz={kernelName:Ex,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:i,newShape:s}=e;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const a=Array.from(n.data.get(i.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,h]=jz(o,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};function Xz(t,e,n,r,i,s=!1,a=0){const o=r.length,l=[e[0],t.length/e[0]],u=l[1],c=o>0?i[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=e.slice();h[0]=c;const d=_f(n,h.reduce(((t,e)=>t*e),1));if(0===o)return c>0&&d.fill(a),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=i[p];for(;;){let e=0;if(f<o){if(e=i[f],g===e){++f;continue}if(g>=e)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(_k(g,c));g>m&&d.fill(a,m*u,g*u);for(let e=p;e<f;++e){const n=r[e];if(n<0||n>=l[0])throw new Error(Ik(e,r[e],l[0]));for(let e=0;e<u;e++)d[g*u+e]+=t[n*u+e]}if(s)for(let t=0;t<u;t++)d[g*u+t]/=f-p;if(p=f,++f,m=g+1,g=e,f>o)break}return m<c&&d.fill(a,m*u,c*u),[d,h]}const Kz={kernelName:Ax,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values,[u,c]=Xz(a,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},Yz={kernelName:Nx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values,[u,c]=Xz(a,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},Zz={kernelName:Rx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:a}=e,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=zI(0,i,o),p=!1,f=n.bufferSync(i);let m;switch(s.dtype){case"bool":m=Iz(f,n.bufferSync(s),o,d,c,u,l,h,Boolean(n.data.get(a.dataId).values[0]),p);break;case"float32":case"int32":m=Iz(f,n.bufferSync(s),o,d,c,u,l,h,n.data.get(a.dataId).values[0],p);break;case"string":m=Iz(f,n.bufferSync(s),o,d,c,u,l,h,Ey(n.data.get(a.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}},Jz={kernelName:Mx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{numOrSizeSplits:s,axis:a}=r,o=bf(a,i.shape)[0],l=dk(i,s,o),u=new Array(i.shape.length).fill(0),c=i.shape.slice();return l.map((t=>{const e=[...c];e[o]=t;const r=zF({inputs:{x:i},backend:n,attrs:{begin:u,size:e}});return u[o]+=t,r}))}},Qz=FL((t=>Math.sqrt(t))),tB=vL(_x,(t=>Math.sqrt(t))),eB={kernelName:_x,backendName:"cpu",kernelFunc:tB},nB={kernelName:Lx,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e;gL(n,"square");const i=r.data.get(n.dataId).values,s=new Float32Array(i.length);for(let t=0;t<i.length;++t){const e=i[t];s[t]=e*e}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},rB=TL(((t,e)=>{const n=t-e;return n*n})),iB=XL(Dx,rB),sB={kernelName:Dx,backendName:"cpu",kernelFunc:iB},aB=vL(Yx,((t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha})),oB={kernelName:Yx,backendName:"cpu",kernelFunc:aB};function lB(t,e,n,r){const i=sb(t,e.dtype);for(let t=0;t<i.size;t++){const s=i.indexToLoc(t),a=new Array(s.length);for(let t=0;t<a.length;t++)a[t]=s[t]*n[t]+r[t];i.set(e.get(...a),...s)}return i}const uB={kernelName:Fx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;gL(i,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:x,begin:y,end:v,strides:b}=Fb(i.shape,s,a,o,l,u,c,h,d);let w;if(m)w=tF({inputs:{x:i},backend:n,attrs:{shape:f}});else if(g||x){uf(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));const t=Sb(y,v,b),e=zF({inputs:{x:i},backend:n,attrs:{begin:y,size:t}});w=tF({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else{const t=lB(p,n.bufferSync(i),b,y);w=n.makeTensorInfo(f,t.dtype,t.values)}return w}};class cB{constructor(t,e,n,r,i,s){this.separator=Cy(t),this.nGramWidths=e,this.leftPad=Cy(n),this.rightPad=Cy(r),this.padWidth=i,this.preserveShort=s}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,r,i,s){for(let a=0;a<i;++a){const o=this.getPadWidth(s),l=Math.max(0,o-a),u=Math.max(0,o-(i-(a+1))),c=s-(l+u),h=e+(l>0?0:a-o);let d=0;d+=l*this.leftPad.length;for(let e=0;e<c;++e)d+=t[h+e].length;d+=u*this.rightPad.length,d+=(l+u+c-1)*this.separator.length,n[r+a]=new Uint8Array(d);const p=n[r+a];let f=0;const m=t=>t.forEach((t=>p[f++]=t));for(let t=0;t<l;++t)m(this.leftPad),m(this.separator);for(let e=0;e<c-1;++e)m(t[h+e]),m(this.separator);if(c>0){m(t[h+c-1]);for(let t=0;t<u;++t)m(this.separator),m(this.rightPad)}else{for(let t=0;t<u-1;++t)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(t,e){const n=t.length,r=e.length;if(r>0){let t=e[0];if(0!==t)throw new Error(`First split value must be 0, got ${t}`);for(let i=1;i<r;++i){let r=e[i]>=t;if(r=r&&e[i]<=n,!r)throw new Error(`Invalid split value ${e[i]}, must be in [${t}, ${n}]`);t=e[i]}if(t!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${t}`)}const i=r-1,s=_f("int32",r);if(0===n||0===r){const t=new Array(n);for(let t=0;t<=i;++t)s[t]=0;return[t,s]}s[0]=0;for(let t=1;t<=i;++t){const n=e[t]-e[t-1];let r=0;this.nGramWidths.forEach((t=>{r+=this.getNumNGrams(n,t)})),this.preserveShort&&n>0&&0===r&&(r=1),s[t]=s[t-1]+r}const a=new Array(s[i]);for(let n=0;n<i;++n){const r=e[n];let i=s[n];if(this.nGramWidths.forEach((s=>{const o=e[n+1]-e[n],l=this.getNumNGrams(o,s);this.createNGrams(t,r,a,i,l,s),i+=l})),this.preserveShort&&i===s[n]){const s=e[n+1]-e[n];if(0===s)continue;const o=s+2*this.padWidth,l=1;this.createNGrams(t,r,a,i,l,o)}}return[a,s]}}function hB(t,e,n,r,i,s,a,o){return new cB(n,r,i,s,a,o).compute(t,e)}const dB={kernelName:$x,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=e,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=hB(d,p,i,s,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function pB(t,e,n,r){if(!t.length)return;if(0===e.length){for(let e=0;e<t.length;++e)r.push(t.subarray(e,e+1));return}if(1===e.length){const i=e[0];let s=t.indexOf(i);for(;-1!==s;){const e=t.subarray(0,s);n&&0===e.length||r.push(e),s=(t=t.subarray(s+1)).indexOf(i)}return void(n&&0===t.length||r.push(t))}let i=0;for(let s=0;s<t.length+1;s++)if(s===t.length||-1!==e.indexOf(t[s])){const e=t.subarray(i,s);n&&0===e.length||r.push(e),i=s+1}}function fB(t,e,n){const r=t.length,i=[];let s=0,a=0;const o=new Array(r);for(let l=0;l<r;++l){const r=i.length;pB(t[l],e,n,i);const u=i.length-r;o[l]=u,s+=u,a=Math.max(a,u)}const l=_f("int32",2*s),u=new Array(s),c=[r,a];let h=0;for(let t=0;t<r;++t)for(let e=0;e<o[t];++e)l[2*h]=t,l[2*h+1]=e,u[h]=i[h],++h;return[l,u,c]}const mB={kernelName:Px,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:i}=r,{input:s,delimiter:a}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values[0],[u,c,h]=fB(o,l,i),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function gB(t,e){const n=_f("int32",t.length);for(let r=0;r<t.length;++r)n[r]=Iy(t[r]).modulo(e).getLowBitsUnsigned();return n}const xB={kernelName:Ox,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:i}=r,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=gB(n.data.get(s.dataId).values,i);return n.makeTensorInfo(s.shape,"int32",a)}},yB=vL(Bx,(t=>Math.tan(t))),vB={kernelName:Bx,backendName:"cpu",kernelFunc:yB},bB=vL(Ux,(t=>Math.tanh(t)));function wB(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const r=sb(n,t.dtype);for(let e=0;e<r.values.length;++e){const n=r.indexToLoc(e),i=new Array(t.rank);for(let e=0;e<i.length;e++)i[e]=n[e]%t.shape[e];const s=t.locToIndex(i);r.values[e]=t.values[s]}return r}const SB=(t,e)=>{const n=e.value-t.value;return 0===n?t.index-e.index:n};function _B(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const i=r-n+1,s=e-n+1,a=Math.log(i),o=.5*Math.exp(2*a/3),l=.5*Math.sqrt(a*o*(i-o)/i)*Math.sign(s-i/2);_B(t,e,Math.max(n,Math.floor(e-s*o/i+l)),Math.min(r,Math.floor(e+(i-s)*o/i+l)))}const i=t[e];let s=n,a=r;for(lf(t,n,e),SB(t[r],i)>0&&lf(t,n,r);s<a;){for(lf(t,s,a),s++,a--;SB(t[s],i)<0;)s+=1;for(;SB(t[a],i)>0;)a-=1}0===SB(t[n],i)?lf(t,n,a):(a+=1,lf(t,a,r)),a<=e&&(n=a+1),e<=a&&(r=a-1)}}function IB(t,e,n,r,i){const s=e[e.length-1],[a,o]=[t.length/s,s],l=Sf(n,a*r),u=Sf("int32",a*r);for(let e=0;e<a;e++){const n=e*o,s=t.subarray(n,n+o);let a=new Array(s.length);s.forEach(((t,e)=>a[e]={value:t,index:e})),r<a.length&&(_B(a,r),a=a.slice(0,r)),i&&a.sort(SB);const c=e*r,h=l.subarray(c,c+r),d=u.subarray(c,c+r);for(let t=0;t<r;t++)h[t]=a[t].value,d[t]=a[t].index}const c=e.slice();return c[c.length-1]=r,[sb(c,n,l),sb(c,"int32",u)]}const kB={kernelName:Gx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{image:i,transforms:s}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=i.shape,[f,m]=null!=u?u:[h,d],g=[c,f,m,p],x=Rf(i.shape),y=x[0],v=x[1],b=x[2],w=Rf(g),S=w[0],_=w[1],I=w[2],k=Sf(i.dtype,pf(g));k.fill(l);const M=r.data.get(i.dataId).values,T=r.data.get(s.dataId).values;for(let t=0;t<c;++t){const e=1===s.shape[0]?T:T.subarray(8*t,8*t+8);for(let n=0;n<f;++n)for(let r=0;r<m;++r)for(let i=0;i<p;++i){let s;const u=e[6]*r+e[7]*n+1;if(0===u)continue;const c=(e[0]*r+e[1]*n+e[2])/u,p=(e[3]*r+e[4]*n+e[5])/u,f=MB(c,d,o),m=MB(p,h,o);switch(a){case"nearest":s=CB(M,h,d,y,v,b,t,m,f,i,l);break;case"bilinear":s=EB(M,h,d,y,v,b,t,m,f,i,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}k[t*S+n*_+r*I+i]=s}return r.makeTensorInfo(g,i.dtype,k)}return{dataId:r.write(k,g,i.dtype),shape:i.shape,dtype:i.dtype}}};function MB(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return af(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=e-1;n+=e*(Math.trunc(-n/t)+1)}else if(n>e-1)if(e<=1)n=0;else{const t=e-1;n-=e*Math.trunc(n/t)}return af(0,n,e-1)}(t,e);case"nearest":return function(t,e){return af(0,t,e-1)}(t,e);default:return function(t,e){return t}(t)}}function TB(t,e,n,r,i,s,a,o,l,u,c){return 0<=o&&o<e&&0<=l&&l<n?t[a*r+o*i+l*s+u]:c}function CB(t,e,n,r,i,s,a,o,l,u,c){return TB(t,e,n,r,i,s,a,Math.round(o),Math.round(l),u,c)}function EB(t,e,n,r,i,s,a,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*TB(t,e,n,r,i,s,a,h,d,u,c)+(l-d)*TB(t,e,n,r,i,s,a,h,f,u,c))+(o-h)*((f-l)*TB(t,e,n,r,i,s,a,p,d,u,c)+(l-d)*TB(t,e,n,r,i,s,a,p,f,u,c))}function AB(t,e,n,r){const i=bf(e,n)[0],s=[1,n[0],1];for(let t=0;t<i;t++)s[0]*=n[t];s[1]=n[i];for(let t=i+1;t<n.length;t++)s[2]*=n[t];const a={},o=new Int32Array(n[i]),l=new Uy(s,r,t),u=[],c=1===s[0]&&1===s[2];for(let e=0;e<n[i];e++){let n;if(c)n=t[e].toString();else{const t=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)t.push(l.get(n,e,r));n=t.join(",")}if(void 0!==a[n])o[e]=a[n];else{const t=Object.keys(a).length;a[n]=t,o[e]=t,u.push(e)}}const h=s.slice();h[1]=Object.keys(a).length;const d=new Uy(h,r);u.forEach(((t,e)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)d.set(l.get(n,t,r),n,e,r)}));const p=n.slice();return p[i]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const NB={kernelName:Xx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,segmentIds:s}=e,{numSegments:a}=r;gL(i,"unsortedSegmentSum");const o=[],l=[],u=i.shape.length-s.shape.length;let c=s;for(let t=0;t<u;++t){const e=K$({inputs:{input:c},backend:n,attrs:{dim:t+1}});c=e,l.push(e)}for(let t=0;t<a;++t){const e=ky(t,"int32"),r=n.makeTensorInfo([],"int32",e),s=$$({inputs:{a:r,b:c},backend:n}),a=jL({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),u=E$({inputs:{a,b:i},backend:n}),h=N$({inputs:{x:u},backend:n,attrs:{axis:0,keepDims:!1}});o.push(h),l.push(r),l.push(s),l.push(a),l.push(u),l.push(h)}const h=jO({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),h}},RB=[iF,aF,lF,cF,QL,hF,mF,gF,xF,yF,bF,SF,IF,TF,EF,DF,LF,FF,$F,rF,PF,UF,GF,HF,qL,XF,YF,UL,ZF,n$,i$,s$,a$,o$,l$,u$,h$,p$,f$,m$,g$,x$,y$,b$,w$,S$,_$,I$,k$,M$,D$,SL,L$,P$,H$,X$,Y$,Q$,cP,dP,pP,gP,vP,bP,wP,_P,kP,CP,NP,IL,RP,t$,LP,$P,OP,ML,UP,GP,jP,KP,ZP,tO,nO,sO,aO,oO,cO,pO,fO,mO,gO,xO,yO,vO,bO,_O,IO,TO,AO,A$,RO,LO,$O,OO,UO,WO,HO,qO,XO,ZO,AL,QO,nz,lz,cz,GL,nP,dz,RL,LL,eF,pz,fz,mz,gz,xz,yz,bz,_z,kz,Cz,Ez,Dz,OL,Fz,Pz,zz,BF,EO,Wz,Vz,Hz,qz,Kz,Yz,Zz,Jz,eB,nB,sB,oB,uB,dB,mB,xB,aP,R$,vB,{kernelName:Ux,backendName:"cpu",kernelFunc:bB},{kernelName:Wx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reps:s}=r;gL(i,"tile");const a=wB(n.bufferSync(i),s);return n.makeTensorInfo(a.shape,a.dtype,a.values)}},{kernelName:Vx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{k:s,sorted:a}=r;gL(i,"topk");const o=n.data.get(i.dataId).values,[l,u]=IB(o,i.shape,i.dtype,s,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},kB,fF,{kernelName:jx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:i}=n,{x:s}=e;gL(s,"unique");const a=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=AB(a,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:qx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:i}=e;let{axis:s}=r;s<0&&(s+=i.shape.length);const a=i.shape.length,o=i.shape[s],l=new Array(a-1);let u=0;for(let t=0;t<a;t++)t!==s&&(l[u++]=i.shape[t]);const c=new Array(a).fill(0),h=i.shape.slice();h[s]=1;const d=new Array(o);for(let t=0;t<d.length;t++){c[s]=t;const e=zF({inputs:{x:i},backend:n,attrs:{begin:c,size:h}});d[t]=tF({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}},NB,GO];for(const t of RB)ly(t);const DB={},LB={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function FB(t,e){if(!(t in DB)||null!=e){const n=function(t,e){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==e?function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t):e;return n.addEventListener("webglcontextlost",(e=>{e.preventDefault(),delete DB[t]}),!1),Hf().getBool("SOFTWARE_WEBGL_ENABLED")&&(LB.failIfMajorPerformanceCaveat=!1),1===t?n.getContext("webgl",LB)||n.getContext("experimental-webgl",LB):n.getContext("webgl2",LB)}(t,e);if(null===n)return console.log("Could not get context for WebGL version",t),null;DB[t]=n}const n=DB[t];return null==n||n.isContextLost()?(delete DB[t],FB(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),DB[t])}var $B,PB,OB;function zB(t,e){return[e,t]}function BB(t){const e=pf(t);return gf(Math.ceil(e/4))}function UB(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function WB(t,e){const n=t;let r,i,s,a,o,l,u,c,h,d;return 2===Hf().getNumber("WEBGL_VERSION")?(r=n.R32F,i=n.R16F,s=n.RGBA16F,a=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=t.RGBA,i=t.RGBA,s=t.RGBA,a=n.RGBA,o=t.RGBA,u=4,c=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function VB(t,e){const n=e();return Hf().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}($B||($B={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(PB||(PB={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(OB||(OB={}));const GB=5.96e-8,HB=65504;function jB(t){return!!(Hf().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||GB<Math.abs(t)&&Math.abs(t)<HB)}function qB(t,e){return nU(t,(()=>t.getExtension(e)),'Extension "'+e+'" not supported on this browser.')}const XB=/ERROR: [0-9]+:([0-9]+):/g;function KB(t,e){const n=XB.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const r=+n[1],i=t.split("\n"),s=i.length.toString().length+2,a=i.map(((t,e)=>xf((e+1).toString(),s)+t));let o=0;for(let t=0;t<a.length;t++)o=Math.max(a[t].length,o);const l=a.slice(0,r-1),u=a.slice(r-1,r),c=a.slice(r);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${xf(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function YB(t,e){if(VB(t,(()=>t.validateProgram(e))),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function ZB(t,e,n,r,i,s,a){const o=t.getAttribLocation(e,n);return-1!==o&&(VB(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,r))),VB(t,(()=>t.vertexAttribPointer(o,i,t.FLOAT,!1,s,a))),VB(t,(()=>t.enableVertexAttribArray(o))),!0)}function JB(t,e,n,r){VB(t,(()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),VB(t,(()=>t.activeTexture(t.TEXTURE0+n))),VB(t,(()=>t.bindTexture(t.TEXTURE_2D,e)))}(t,e,r))),VB(t,(()=>t.uniform1i(n,r)))}function QB(t,e,n){VB(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n))),VB(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)))}function tU(t,e){VB(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e))),VB(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function eU(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function nU(t,e,n){const r=VB(t,(()=>e()));if(null==r)throw new Error(n);return r}function rU(t,e=2){return pf(t.slice(0,t.length-e))}function iU(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function sU(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[rU(t),...iU(t)]),e}function aU(t){return t%2==0}function oU(t,e){if(ff(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(aU(n)&&aU(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&aU(t[0])&&aU(e[0])}let lU,uU;function cU(t,e){return null!=t.getExtension(e)}function hU(t){try{if(null!=FB(t))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function dU(t){const e=WB(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),i}function pU(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&uf("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the WebGL backend.`))}))}const fU=Hf();function mU(){let t,e,n,r,i,s,a,o,l,u;return 2===Hf().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",i="texture",s="outputColor",a="out vec4 outputColor;",o=Hf().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",i="texture2D",s="gl_FragColor",a="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:i,output:s,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function gU(t,e,n="index"){const r=Rf(e);return r.map(((e,i)=>`int ${t[i]} = ${n} / ${e}; ${i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${e}`:`index -= ${t[i]} * ${e}`};`)).join("")}function xU(t,e,n="index"){const r=Rf(e);return r.map(((e,i)=>`int ${t[i]} = ${n} / outShapeStrides[${i}]; ${i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * outShapeStrides[${i}]`:`index -= ${t[i]} * outShapeStrides[${i}]`};`)).join("")}function yU(t){const e=Rf(t).map((t=>t.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}fU.registerFlag("HAS_WEBGL",(()=>fU.getNumber("WEBGL_VERSION")>0)),fU.registerFlag("WEBGL_VERSION",(()=>hU(2)?2:hU(1)?1:0)),fU.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),fU.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===fU.get("WEBGL_VERSION"))),fU.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),fU.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),fU.registerFlag("WEBGL_PACK",(()=>fU.getBool("HAS_WEBGL"))),fU.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_PACK_CLIP",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_PACK_REDUCE",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_LAZILY_UNPACK",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_CONV_IM2COL",(()=>fU.getBool("WEBGL_PACK"))),fU.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(t){if(null==lU){const e=FB(t);lU=e.getParameter(e.MAX_TEXTURE_SIZE)}return lU}(fU.getNumber("WEBGL_VERSION")))),fU.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(t){if(null==uU){const e=FB(t);uU=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,uU)}(fU.getNumber("WEBGL_VERSION")))),fU.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=fU.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=FB(t);return e=cU(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:cU(n,"EXT_disjoint_timer_query")?1:0,e}(t)})),fU.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>fU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!pv())),fU.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(t){if(0===t)return!1;const e=FB(t);if(1===t){if(!cU(e,"OES_texture_float"))return!1}else if(!cU(e,"EXT_color_buffer_float"))return!1;return dU(e)}(fU.getNumber("WEBGL_VERSION")))),fU.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!fU.getBool("WEBGL_FORCE_F16_TEXTURES")&&fU.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),fU.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>function(t){if(0===t)return!1;const e=FB(t);if(1!==t){if(cU(e,"EXT_color_buffer_float"))return dU(e);const t="EXT_color_buffer_half_float";if(cU(e,t)){const n=e.getExtension(t);return function(t,e){const n=WB(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),s}(e,n)}return!1}return!!cU(e,"OES_texture_float")&&!!cU(e,"WEBGL_color_buffer_float")&&dU(e)}(fU.getNumber("WEBGL_VERSION")))),fU.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(t=fU.getNumber("WEBGL_VERSION"))&&null!=FB(t).fenceSync;var t})),fU.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>fU.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),fU.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)})),fU.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>pv()?1:-1),(t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)})),fU.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),fU.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),fU.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),fU.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),fU.registerFlag("WEBGL_EXP_CONV",(()=>!1)),fU.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>fU.getBool("IS_TEST"))),fU.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),fU.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),fU.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1));const vU="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:bU}=i;function wU(t,e,n){const r=[];if(t.forEach((t=>{const e=pf(t.shapeInfo.logicalShape);if(t.shapeInfo.isUniform?r.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(r.push(`uniform sampler2D ${t.name};`),r.push(`uniform int offset${t.name};`)),n.enableShapeUniforms){const{uniformShape:e}=NU(n.packedInputs,t.shapeInfo.logicalShape,t.shapeInfo.texShape);switch(e.length){case 1:r.push(`uniform int ${t.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${t.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${t.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${t.name}Shape;`)}r.push(`uniform ivec2 ${t.name}TexShape;`)}})),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((t=>{r.push(`uniform ${t.type} ${t.name}${t.arrayIndex?`[${t.arrayIndex}]`:""};`)}));const i=r.join("\n"),s=t.map((t=>function(t,e,n=!1,r){let i="";i+=n?_U(t,r):SU(t,r);const s=t.shapeInfo.logicalShape,a=e.logicalShape;return s.length<=a.length&&(i+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=bU(t.shapeInfo.logicalShape,e.logicalShape),l=AU(a),u=a-s;let c;const h=["x","y","z","w","u","v"];c=0===s?"":a<2&&o.length>=1?"coords = 0;":o.map((t=>`coords.${h[t+u]} = 0;`)).join("\n");let d="";d=a<2&&s>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>`coords.${h[e+u]}`)).join(", ");let p="return outputValue;";const f=1===pf(t.shapeInfo.logicalShape),m=1===pf(e.logicalShape);if(1!==s||f||m){if(f&&!m)p=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const t=s-2,e=s-1;o.indexOf(t)>-1&&o.indexOf(e)>-1?p="return vec4(outputValue.x);":o.indexOf(t)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(e)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",s=e.texShape,a=t.shapeInfo.texShape,o=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===l&&null==t.shapeInfo.flatOffset&&ff(a,s))return`\n      float ${i}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=AU(l),c=bU(t.shapeInfo.logicalShape,e.logicalShape),h=l-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((t=>`coords.${p[t+h]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>`coords.${p[e+h]}`)).join(", "),`\n    float ${i}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(t,e)),i}(t,e,n.packedInputs,n.enableShapeUniforms))).join("\n"),a=e.texShape,o=mU(),l=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,h=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${IU}\n    ${kU}\n    ${MU}\n  `}(o);return e.isPacked?(u=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,e,n);case 2:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(ff(t,e))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const i=Math.ceil(t[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e,n);case 3:return function(t,e,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(t[2]/2),s=i*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e,n);default:return function(t,e,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(t[t.length-1]/2),s=i*Math.ceil(t[t.length-2]/2);let a=s,o="",l="b, r, c";for(let e=2;e<t.length-1;e++)a*=t[t.length-e-1],o=`\n      int b${e} = index / ${a};\n      index -= b${e} * ${a};\n    `+o,l=`b${e}, `+l;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec${t.length}(${l});\n    }\n  `}(t,e,n)}}(e.logicalShape,a,n.enableShapeUniforms),c=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(o)):(u=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){return 1===e[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${e[1]}.0);\n      }\n    `:1===e[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${e[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return resTexRC.x * ${e[1]} + resTexRC.y;\n    }\n  `}(0,e,n);case 2:return function(t,e,n){return ff(t,e)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e,n);case 3:return function(t,e,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${xU(["r","c","d"],t)}\n    return ivec3(r, c, d);\n  }\n`;const r=gU(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(t,e,n);case 4:return function(t,e,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${xU(["r","c","d","d2"],t)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=gU(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e,n);case 5:return function(t,e){const n=gU(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=gU(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(e.logicalShape,a,n.enableShapeUniforms),c=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(h+=TU),[h,l,c,i,u,s,n.userCode].join("\n")}function SU(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[i,s]=t.shapeInfo.texShape;if(1===i&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const a=CU(n);if(e)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=t.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t,e);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${EU(t)}\n      }\n    `;const i=t.shapeInfo.texShape,s=i[0],a=i[1];if(1===a&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=CU(n);return 1===a?e?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?e?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:e?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${a}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(null!=s&&ff(n,s)){if(e)return`\n      float ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const t=s[0];return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${t}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:a,keptDims:o}=wf(n),l=a;if(l.length<n.length){const n=["row","col"];return`\n      ${SU(RU(t,l),e)}\n      float ${i}(int row, int col) {\n        return ${i}(${DU(n,o)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${EU(t)}\n      }\n    `;const u=s[0],c=s[1],h=CU(r);return 1===c?e?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?e?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:e?`\n      float ${i}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],a=n[2],{newShape:o,keptDims:l}=wf(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${SU(RU(t,u),e)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${DU(n,l)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${a}, 1)));\n        ${EU(t)}\n      }\n    `;const c=t.shapeInfo.texShape,h=c[0],d=c[1],p=t.shapeInfo.flatOffset;if(d===s&&null==p)return e?`\n      float ${i}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===a&&null==p)return e?`\n      float ${i}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=CU(r);return e?`\n    float ${i}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${a} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(t,e);case 4:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],a=n[2]*s,o=n[1]*a,{newShape:l,keptDims:u}=wf(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${SU(RU(t,l),e)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${DU(n,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${a}, ${s}, 1)));\n        ${EU(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return e?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==c)return e?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const x=CU(r);return e?`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${x});\n      return sampleTexture(${r}, uv);\n    }\n  `}(t,e);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[4],s=e[3]*i,a=e[2]*s,o=e[1]*a,{newShape:l,keptDims:u}=wf(e);if(l.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${SU(RU(t,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${DU(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${a}, ${s}, ${i})) +\n          depth3;\n        ${EU(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${s}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===i&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} + depth * ${s} +\n          depth2 * ${i} + depth3 + ${CU(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:i,keptDims:s}=wf(e);if(i.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${SU(RU(t,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${DU(e,s)});\n      }\n    `}const a=e[5],o=e[4]*a,l=e[3]*o,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${EU(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===a&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${a} + depth4 + ${CU(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function _U(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${mU().texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape,s=mU();if(e)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${a[0]}, ${a[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,a=s[0],o=s[1],l=mU();if(null!=s&&ff(n,s))return e?`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(e)return`\n    vec4 ${i}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${i}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=["b","row","col"];return`\n        ${_U(RU(t,n.slice(1)),e)}\n        vec4 ${i}(int b, int row, int col) {\n          return ${i}(${DU(s,r)});\n        }\n      `}const o=mU();if(e)return`\n    vec4 ${i}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=a[0],u=a[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${i}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(t,e);default:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=mU();if(e)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${n}, uv);\n    }\n  `;const s=t.shapeInfo.logicalShape,a=s.length,o=t.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(s[a-1]/2);let d=h*Math.ceil(s[a-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let t=2;t<a-1;t++)p=`int b${t}, `+p,d*=s[a-t-1],f=`b${t} * ${d} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(t,e)}}const IU="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",kU="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",MU="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",TU="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function CU(t){return`offset${t}`}function EU(t){const e=t.name,n=pf(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function AU(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function NU(t,e,n){const{newShape:r,keptDims:i}=wf(e),s=e.length,a=t&&3===s&&1===e[0],o=a?e.slice(1):r,l=!t&&s>1&&!ff(e,n)&&r.length<s||a;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:i}}function RU(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function DU(t,e){return e.map((e=>t[e])).join(", ")}function LU(t,e,n){const r={},i={},s={},a=[];let o,l,u,c=null,h=null;h=t.getUniformLocation(n,"NAN",!1),1===Hf().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(n,"INFINITY",!1));const d=!1;for(let a=0;a<e.variableNames.length;a++){const o=e.variableNames[a];r[o]=t.getUniformLocation(n,o,d),r[`offset${o}`]=t.getUniformLocation(n,`offset${o}`,d),e.enableShapeUniforms&&(i[`${o}Shape`]=t.getUniformLocation(n,`${o}Shape`,d),s[`${o}TexShape`]=t.getUniformLocation(n,`${o}TexShape`,d))}return e.enableShapeUniforms&&(o=t.getUniformLocation(n,"outShape",d),u=t.getUniformLocation(n,"outShapeStrides",d),l=t.getUniformLocation(n,"outTexShape",d)),e.customUniforms&&e.customUniforms.forEach(((e,r)=>{a[r]=t.getUniformLocation(n,e.name,d)})),{uniformLocations:r,customUniformLocations:a,infLoc:c,nanLoc:h,inShapesLocations:i,inTexShapesLocations:s,outShapeLocation:o,outShapeStridesLocation:u,outTexShapeLocation:l}}function FU(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach(((t,n)=>{const r=t.logicalShape,i=e[n],s=i.shape;if(!ff(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,o=i.isUniform?null:i.texData.texShape;if(!ff(a,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${o} must match`)}))}function $U(t){return Hf().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class PU{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=$B.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=mU();this.outputShape=t,this.enableShapeUniforms=$U(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?xU(["r","c","d"],t):gU(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class OU{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=$B.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=mU();this.outputShape=t,this.enableShapeUniforms=$U(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?xU(["r","c","d"],t):gU(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class zU{constructor(t){this.variableNames=["A"],this.outTexUsage=PB.DOWNLOAD;const e=mU();this.outputShape=t,this.userCode=`\n      ${vU}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class BU{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=PB.DOWNLOAD;const e=mU();this.outputShape=t,this.userCode=`\n      ${vU}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class UU{constructor(t,e=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=mU();this.outputShape=t,this.enableShapeUniforms=$U(this.outputShape.length);let r="result";e&&(r="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":yU(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}}class WU{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=mU();this.outputShape=t,this.enableShapeUniforms=$U(this.outputShape.length);let r="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let e=0;e<=1;e++)for(let i=0;i<=1;i++){const s=2*e+i;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${i};\n          if (localCoords[1] + ${e} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${e};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":yU(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${i};\n        }\n    `}}function VU(t,e,n,r,i,s){!function(t,e){const n=Hf().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const a=function(t){return nU(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}(t),o=t.TEXTURE_2D;return VB(t,(()=>t.bindTexture(o,a))),VB(t,(()=>t.texParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE))),VB(t,(()=>t.texParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE))),VB(t,(()=>t.texParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST))),VB(t,(()=>t.texParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST))),1===Hf().getNumber("WEBGL_VERSION")?VB(t,(()=>t.texImage2D(o,0,r,e,n,0,i,s,null))):VB(t,(()=>t.texStorage2D(o,1,r,e,n))),VB(t,(()=>t.bindTexture(t.TEXTURE_2D,null))),{texture:a,texShape:[n,e]}}function GU(t){return t.internalFormatFloat}function HU(t){return t.internalFormatHalfFloat}function jU(t){return t.downloadTextureFormat}function qU(t){return t.internalFormatPackedFloat}function XU(t){return t.internalFormatPackedHalfFloat}class KU{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=Hf().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){DB[t]=e}(e,t)):this.gl=FB(e);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Hf().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=qB(this.gl,t),cU(this.gl,e))this.textureHalfFloatExtension=qB(this.gl,e);else if(Hf().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),cU(this.gl,r))this.colorBufferHalfFloatExtension=qB(this.gl,r);else if(Hf().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",cU(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!cU(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(t){return function(t,e){const n=nU(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return VB(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),VB(t,(()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=nU(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return VB(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n))),VB(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return nU(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=WB(this.gl,this.textureHalfFloatExtension)}get debug(){return Hf().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;VB(t,(()=>t.finish())),VB(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null))),VB(t,(()=>t.deleteFramebuffer(this.framebuffer))),VB(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null))),VB(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null))),VB(t,(()=>t.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=zB(e,n);return VU(t,i,s,GU(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=zB(e,n);return VU(t,i,s,HU(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=zB(e,n);return VU(t,i,s,jU(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){VB(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),n.data instanceof Uint8Array?2===Hf().getNumber("WEBGL_VERSION")?VB(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data))):VB(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data))):2===Hf().getNumber("WEBGL_VERSION")?VB(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n))):VB(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n))),VB(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,i,s){let a,o,l;VB(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),i instanceof Uint8Array?(a=new Uint8Array(n*r*4),o=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*r*4),o=t.FLOAT,l=s.internalFormatPackedFloat),a.set(i),2===Hf().getNumber("WEBGL_VERSION")?VB(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,o,a))):VB(t,(()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,o,a))),VB(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=UB(e,n);return VU(t,i,s,XU(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[i,s]=UB(e,n);return VU(t,i,s,qU(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(tU(this.gl,this.framebuffer),this.outputTexture=null),VB(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n,r){const[i,s]=zB(e,n),a=new Uint8Array(e*n*4);return VB(t,(()=>t.readPixels(0,0,i,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,a))),new Float32Array(a.buffer)}(this.gl,e,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,e,n,r,i,s){return function(t,e,n,r,i,s,a,o){const l=t,u=new Float32Array(function(t,e){const[n,r]=UB(t,e);return n*r*4}(s,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,i,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const i=t.createBuffer();VB(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,i)));const s=16*e*n;return VB(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ))),VB(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0))),VB(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null))),i}(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Hf().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(i,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=i}else Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n){const r=new Float32Array(e*n*4);return VB(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r))),r}(this.gl,e,n)))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function(t){const e=mU();return function(t,e){const n=nU(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(VB(t,(()=>t.shaderSource(n,e))),VB(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const n=function(t){return nU(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}(e);return VB(e,(()=>e.attachShader(n,this.vertexShader))),VB(e,(()=>e.attachShader(n,t))),function(t,e){if(VB(t,(()=>t.linkProgram(e))),!Hf().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,n),this.debug&&YB(e,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=function(t,e,n){return VB(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),ZB(t,e,"clipSpacePos",n,3,20,0)&&ZB(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),n}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&VB(this.gl,(()=>this.gl.deleteProgram(t)))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&YB(this.gl,this.program),VB(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return nU(t,(()=>t.getUniformLocation(e,n)),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),VB(this.gl,(()=>this.gl.getAttribLocation(t,e)))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),JB(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,i]=UB(e,n);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&YB(this.gl,this.program),eU(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),VB(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),VB(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=qB(this.gl,2===Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await yf((()=>this.disposed||this.isQueryAvailable(t,Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(t,Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Hf().platform&&(n=Hf().platform.setTimeoutCustom.bind(Hf().platform)),yf((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),QB(this.gl,t,this.framebuffer),this.debug&&eU(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(QB(this.gl,this.outputTexture,this.framebuffer),this.debug&&eU(this.gl)):tU(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;QB(r,t,this.framebuffer),this.debug&&eU(r),this.outputTexture=t,VB(r,(()=>r.viewport(0,0,e,n))),VB(r,(()=>r.scissor(0,0,e,n)))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),VB(this.gl,(()=>this.gl.scissor(t,e,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:YU,bincountImpl:ZU,bincountReduceImpl:JU,castImpl:QU,ceilImpl:tW,concatImpl:eW,equalImpl:nW,expImpl:rW,expm1Impl:iW,floorImpl:sW,gatherNdImpl:aW,gatherV2Impl:oW,greaterImpl:lW,greaterEqualImpl:uW,lessImpl:cW,lessEqualImpl:hW,linSpaceImpl:dW,logImpl:pW,maxImpl:fW,maximumImpl:mW,minimumImpl:gW,multiplyImpl:xW,negImpl:yW,notEqualImpl:vW,prodImpl:bW,raggedGatherImpl:wW,raggedTensorToTensorImpl:SW,rangeImpl:_W,rsqrtImpl:IW,scatterImpl:kW,sigmoidImpl:MW,simpleAbsImpl:TW,sliceImpl:CW,sparseFillEmptyRowsImpl:EW,sparseReshapeImpl:AW,sparseSegmentReductionImpl:NW,sqrtImpl:RW,stridedSliceImpl:DW,stringNGramsImpl:LW,stringSplitImpl:FW,stringToHashBucketFastImpl:$W,subImpl:PW,tileImpl:OW,topKImpl:zW,transposeImpl:BW,uniqueImpl:UW}=s;function WW(t,e){return["x","y","z","w","u","v"].slice(0,e).map((e=>`${t}.${e}`))}function VW(t,e){return 1===e?[t]:WW(t,e)}class GW{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=$U(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const t=VW("rc",this.rank),e=AU(this.rank),n=this.getOutOfBoundsCondition(t),r=this.getSetup(t),i=this.getOutput(t);this.userCode=`\n        void main() {\n          ${e} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let i=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let e=2;e<this.rank;e++)i=`${t[t.length-1-e]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class HW{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=$U(this.outputShape.length);let n="";for(let t=0;t<4;t++){let e="thisRC = rc;";t%2==1&&(e+="thisRC.z += 1;"),t>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${t>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${t>0?"}":""}\n      `}var r,i;this.userCode=`\n      ${r=e,i=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${i?function(t,e,n="index"){const r=function(t,e){const n=t.length,r=t.map((t=>`${e}[${t}]`)),i=new Array(n-1);i[n-2]=r[n-1];for(let t=n-3;t>=0;--t)i[t]=`(${i[t+1]} * ${r[t+1]})`;return i}(t.map(((t,e)=>e)),e);return r.map(((e,i)=>`int ${t[i]} = ${n} / ${r[i]}; ${i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${r[i]}`:`index -= ${t[i]} * ${r[i]}`};`)).join("")}(["r","c","d"],"inputShape"):gU(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":yU(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class jW{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const r=XW(e,n),i=KW(t,r,n);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const s=qW(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const t=this.freeTextures[i].shift();return this.usedTextures[i].push(t),t}let a;return r===OB.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===OB.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===OB.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===OB.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===OB.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),a}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const i=XW(n,r),s=KW(e,i,r);s in this.freeTextures||(this.freeTextures[s]=[]);const a=qW(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Hf().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[s].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[s],u=l.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));for(const t in this.usedTextures)this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function qW(t,e,n,r,i){const s=function(t,e){switch(t){case OB.PACKED_2X2_FLOAT32:return qU(e);case OB.PACKED_2X2_FLOAT16:return XU(e);case OB.UNPACKED_FLOAT32:return GU(e);case OB.UNPACKED_FLOAT16:return HU(e);case OB.PACKED_4X1_UNSIGNED_BYTE:return jU(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,r);let a;if(i){const[e,n]=UB(t[0],t[1]);a=e*n}else{const[e,n]=zB(t[0],t[1]);a=e*n}const o=function(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}(n,s);return a*o}function XW(t,e){if(t===PB.UPLOAD)return OB.PACKED_2X2_FLOAT32;if(t===PB.RENDER||null==t)return function(t){return Hf().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?OB.PACKED_2X2_FLOAT32:OB.UNPACKED_FLOAT32:t?OB.PACKED_2X2_FLOAT16:OB.UNPACKED_FLOAT16}(e);if(t===PB.DOWNLOAD||t===PB.PIXELS)return OB.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function KW(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class YW{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=$U(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const ZW="if (isnan(x)) return x;",JW="return x;",QW="return abs(x);",tV="return (x >= 0.0) ? x : (exp(x) - 1.0);",eV=ZW+"\n  return (x < 0.0) ? 0.0 : x;\n",nV=ZW+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",rV="return x;",iV="return 1.0 / (1.0 + exp(-1.0 * x));",sV="return x;",aV="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",oV="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",lV="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",uV="return 1.0 / (1.0 + exp(-1.0 * x));";class cV{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=$U(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class hV{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=$U(this.outputShape.length);const e=t.length,n=VW("rc",e),r=AU(e),i=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),s=n.slice(-2),a=e<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const dV=Ak,pV={},fV=Hf().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class mV extends nf{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Hf().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(null!=t){if(t instanceof KU)e=t;else{const n=FB(Hf().getNumber("WEBGL_VERSION"),t);e=new KU(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const t=FB(Hf().getNumber("WEBGL_VERSION"));e=new KU(t),this.binaryCache=((n=Hf().getNumber("WEBGL_VERSION"))in pV||(pV[n]={}),pV[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new jW(this.gpgpu),this.numMBBeforeWarning=null==Hf().global.screen?1024:Hf().global.screen.height*Hf().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new ef(this,Bb())}nextDataId(){return mV.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if((Hf().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Hf().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:PB.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,e,n,r,i){if(Hf().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:PB.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:i,slice:s,shape:a,isPacked:o}=e;if(null!=s){let e;e=o?new cV(a,rV):new YW(a,rV);const n=this.runWebGLProgram(e,[{dataId:t,shape:a,dtype:r}],r),i=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;return l&&(u=Ty()),c="complex64"===r?XI(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):this.getValuesFromTexture(t),l&&(this.downloadWaitMs+=Ty()-u),this.convertAndCacheOnCPU(t,c)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise((t=>e.push(t)))}const e=this.texData.get(t),{values:n,shape:r,slice:i,dtype:s,complexTensorInfos:a,isPacked:o}=e;if(null!=i){let e;e=o?new cV(r,rV):new YW(r,rV);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:s}],s),i=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(t);if(Hf().getBool("DEBUG")&&!Hf().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Hf().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&Hf().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(t);const e=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(e.texture.texture,...BB(r))}if(this.pendingRead.set(t,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const t=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]);u=XI(t[0],t[1])}else if(null==c)u=this.getValuesFromTexture(t);else{const t=pf(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,t)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const t=this.gpgpu.gl;VB(t,(()=>t.deleteBuffer(c)))}const h=this.convertAndCacheOnCPU(t,u),d=this.pendingRead.get(t);return this.pendingRead.delete(t),d.forEach((t=>t(h))),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Bb().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t,e={}){const n=this.texData.get(t),{values:r,shape:i,slice:s,dtype:a,isPacked:o,texture:l}=n;if("complex64"===a)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new cV(i,rV):new YW(i,rV);const r=this.runWebGLProgram(n,[{dataId:t,shape:i,dtype:a}],a),s=this.readToGPU(r,e);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(t,e.customTexShape),c=Bb().makeTensorFromTensorInfo(u),h=this.texData.get(u.dataId);return Object.assign({tensorRef:c},h.texture)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>Ey(t)));return sb(t.shape,t.dtype,n)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return sb(t.shape,t.dtype,e)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!jB(n)){if(Hf().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),i=pf(e);if(Hf().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...BB(e)).subarray(0,i);return this.disposeIntermediateTensorInfo(n),s}const s=Hf().getBool("WEBGL_PACK")&&!0===r,a=s?sU(e):e,o=s?new BU(a):new zU(a),l=this.runWebGLProgram(o,[{shape:a,dtype:n,dataId:t}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const i=df(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),s=df(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(i);a.kernelMs=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}(t),a.getExtraProfileInfo=()=>t.map(((t,e)=>({name:s[e],ms:t}))).map((t=>`${t.name}: ${t.ms}`)).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ty(),endMs:null}}endTimer(t){return Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Ty(),t)}async getQueryTime(t){if(Hf().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:i,isPacked:s,slice:a}=this.texData.get(t),o=a&&a.origDataId||t,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,i,s)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=fV){return Hf().getBool("WEBGL_CPU_FORWARD")&&t.every((t=>null==this.texData.get(t.dataId).texture&&pf(t.shape)<e))}getGPGPUContext(){return this.gpgpu}where(t){ey("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return dV(t.shape,e)}packedUnaryOp(t,e,n){const r=new cV(t.shape,e),i=this.compileAndRun(r,[t],n);return Bb().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=TW(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Hf().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,QW,t.dtype);const e=new YW(t.shape,QW),n=this.compileAndRun(e,[t]);return Bb().makeTensorFromTensorInfo(n)}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&Tf(n[0])){const i=n.map((t=>Cy(t)));r=this.write(i,t,e)}else r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){return Bb().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,n),this)}unpackTensor(t){const e=new hV(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new GW(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[rU(t.shape),...iU(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},i=[rU(e),...iU(e)],s=new HW(i,n),a=[n],o=this.runWebGLProgram(s,[r],t.dtype,a,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}decode(t,e){const n=this.texData.get(t),{isPacked:r,shape:i,dtype:s}=n;null!=e&&uf(pf(i)<=e[0]*e[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."));const a=sU(i);let o;o=r?new OU(a):new PU(a);const l=[null!=e?e:BB(a)];return{dtype:s,shape:i,dataId:this.runWebGLProgram(o,[{shape:a,dtype:s,dataId:t}],s,l,!0,e).dataId}}runWebGLProgram(t,e,n,r,i=!1,s){const a=this.makeTensorInfo(t.outputShape,n),o=this.texData.get(a.dataId);if(t.packedOutput&&(o.isPacked=!0),t.outPackingScheme===$B.DENSE){const e=null!=s?s:BB(t.outputShape);o.texShape=e.map((t=>2*t))}if(null!=t.outTexUsage&&(o.usage=t.outTexUsage),0===pf(a.shape))return o.values=Sf(a.dtype,0),a;const l=[],u=e.map((e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&pf(e.shape)<=Hf().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}if(this.uploadToGPU(e.dataId),!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!oU(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),l.push(e),n=this.texData.get(e.dataId),t.shape=r}return{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(a.dataId);const c={shape:a.shape,texData:o,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach((e=>{const i=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!e.isUniform){const s=e.texData.texShape,{useSqueezeShape:a,uniformShape:o,keptDims:l}=NU(t.packedInputs,e.shape,s);let u="",c="",h="";if(1===o.length&&t.packedInputs){const t=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${t[0]>1}_${t[1]>1}`}else if(2!==o.length||t.packedInputs){if(o.length>2&&!t.packedInputs){const t=Rf(o);h=`${t[0]===s[1]}_${t[t.length-1]===s[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const d=e.shape.length,p=2===o.length&&ff(e.shape,s),f=1===pf(e.shape),m=mb(e.shape,n.shape),g=!t.packedInputs&&d===n.shape.length&&ff(s,n.texData.texShape),x=t.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${d}_${g}_${a?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${h}_${x}_${i}`}else{const t=e.isUniform?"uniform":e.texData.texShape;r+=`${e.shape}_${t}_${i}`}}));const i=t.userCode;let s=t.constructor.name;return s+="_"+r+"_"+i+`${Hf().getNumber("WEBGL_VERSION")}`,s}(t,u,c),d=this.getAndSaveBinary(h,(()=>function(t,e,n,r){const i=n.map(((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}})),s=i.map((t=>t.shapeInfo)),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=wU(i,a,e),l=function(t,e){const n=nU(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(VB(t,(()=>t.shaderSource(n,e))),VB(t,(()=>t.compileShader(n))),Hf().get("ENGINE_COMPILE_ONLY"))return n;if(!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw KB(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t.gl,o),u=t.createProgram(l);return Hf().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:a,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:a},LU(t,e,u))}(this.gpgpu,t,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),Hf().get("ENGINE_COMPILE_ONLY")||function(t,e,n,r,i){e.program.enableShapeUniforms||(FU(e.inShapeInfos,n),FU([e.outShapeInfo],[r]));const s=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,a[0],a[1]):t.setOutputMatrixTexture(s.texture,a[0],a[1]),t.setProgram(e.webGLProgram),1===Hf().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach(((n,r)=>{const i=e.program.variableNames[r],s=e.uniformLocations[i],a=e.uniformLocations[`offset${i}`],o=e.inShapesLocations[`${i}Shape`],l=e.inTexShapesLocations[`${i}TexShape`];if(o){const{uniformShape:r}=NU(e.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:t.gl.uniform1iv(o,new Int32Array(r));break;case 2:t.gl.uniform2iv(o,new Int32Array(r));break;case 3:t.gl.uniform3iv(o,new Int32Array(r));break;case 4:t.gl.uniform4iv(o,new Int32Array(r))}}if(l&&t.gl.uniform2i(l,n.texData.texShape[0],n.texData.texShape[1]),null!=s)if(n.isUniform)if(pf(n.shape)<2)t.gl.uniform1f(s,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(s,e)}else null!=n.texData.slice&&null!=a&&t.gl.uniform1i(a,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture.texture,s,r)}));const o=e.outShapeLocation;if(o)switch(r.shape.length){case 1:t.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(o,new Int32Array(r.shape))}if(e.outShapeStridesLocation){const n=Rf(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(n));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(n));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(n))}}e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&i&&e.program.customUniforms.forEach(((n,r)=>{const s=e.customUniformLocations[r],a=i[r];if("float"===n.type)t.gl.uniform1fv(s,a);else if("vec2"===n.type)t.gl.uniform2fv(s,a);else if("vec3"===n.type)t.gl.uniform3fv(s,a);else if("vec4"===n.type)t.gl.uniform4fv(s,a);else if("int"===n.type)t.gl.uniform1iv(s,a);else if("ivec2"===n.type)t.gl.uniform2iv(s,a);else if("ivec3"===n.type)t.gl.uniform3iv(s,a);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);t.gl.uniform4iv(s,a)}})),t.executeProgram()}(this.gpgpu,d,u,c,r),l.forEach((t=>this.disposeIntermediateTensorInfo(t))),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));const m=Hf().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const t=Ty();t-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Hf().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===i){const t=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),t}return a}compileAndRun(t,e,n,r,i=!1){return n=n||e[0].dtype,this.runWebGLProgram(t,e,n,r,i)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Hf().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Wb((()=>{if(!Hf().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Hf().getBool("DEBUG");Hf().set("DEBUG",!1);const e=this.abs(Xb(1e-8)).dataSync()[0];if(Hf().set("DEBUG",t),e>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:i,texture:s,usage:a,isPacked:o}=e;if(null!=s)return;const l=null!=this.activeTimers;let u;l&&(u=Ty());let c=e.texShape;if(null==c&&(c=function(t,e=!1){let n=Hf().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Hf().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&Hf().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n*=2,r*=2,1===(t=t.map(((e,n)=>n>=t.length-2?of(t[n]):t[n]))).length&&(t=[2,t[0]])),2!==t.length){const e=wf(t);t=e.newShape}let i=pf(t),s=null;t.length<=1&&i<=n?s=[1,i]:2===t.length&&t[0]<=n&&t[1]<=n?s=t:3===t.length&&t[0]*t[1]<=n&&t[2]<=n?s=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=n&&t[1]*t[2]<=n?s=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n?s=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(s=[t[0],t[1]*t[2]*t[3]]);const a=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(null==s||a)if(e){const e=rU(t);let n=2,r=2;t.length&&([n,r]=iU(t)),i=e*(n/2)*(r/2),s=gf(i).map((t=>2*t))}else s=gf(i);return s}(n,o),e.texShape=c),null!=i){const t=sU(n);let s,a=c[1],h=c[0];const d=i instanceof Uint8Array||i instanceof Uint8ClampedArray;!o&&d||([a,h]=UB(c[0],c[1])),s=o?new WU(t,d):new UU(t,d);const p=d?[h,a]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=d?PB.PIXELS:PB.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),a,h,i);const g=[[h,a]],x=!0,y=this.runWebGLProgram(s,[f],r,g,x),v=this.texData.get(y.dataId);e.texShape=v.texShape,e.isPacked=v.isPacked,e.usage=v.usage,Hf().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(e.texture=v.texture,e.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=Ty()-u)}else{const t=this.acquireTexture(c,a,r,o);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*Mf(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}for(const[,e]of Object.entries(this.binaryCache)){const n=new Promise((t=>{try{this.checkCompletion_(e),t(!0)}catch(t){throw t}}));t.push(n)}return Promise.all(t)}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await bI(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(!1===this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw KB(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,t]of Object.entries(this.binaryCache)){const{uniformLocations:e,customUniformLocations:n,infLoc:r,nanLoc:i,inShapesLocations:s,inTexShapesLocations:a,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:u}=LU(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=e,t.customUniformLocations=n,t.infLoc=r,t.nanLoc=i,t.inShapesLocations=s,t.inTexShapesLocations=a,t.outShapeLocation=o,t.outShapeStridesLocation=l,t.outTexShapeLocation=u}}}mV.nextDataId=0,fv()&&Hb("webgl",(()=>new mV),2);const gV="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class xV{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=xb(e,n),this.enableShapeUniforms=$U(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const yV="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class vV{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=xb(e,n);const i=this.outputShape.length;this.enableShapeUniforms=$U(i);let s="";if(r)if(0===i||1===pf(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${AU(i)} coords = getOutputCoords();\n        `,1===i)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=VW("coords",i);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${t[i-2]} + 1) >= outShape[${i} - 2];\n            bool nextColOutOfBounds =\n              (${t[i-1]} + 1) >= outShape[${i} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${t[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${t[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function bV(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const wV={kernelName:ug,backendName:"webgl",kernelFunc:bV};function SV(t){const{inputs:e,backend:n}=t,{real:r,imag:i}=e,s=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(s.dataId),o=bV({inputs:{x:r},backend:n}),l=bV({inputs:{x:i},backend:n});return a.complexTensorInfos={real:o,imag:l},s}const _V={kernelName:wm,backendName:"webgl",kernelFunc:SV},IV="return (a < 0.) ? b * a : a;",kV="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",MV={kernelName:mg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{alpha:s}=r,a=n.makeTensorInfo([],"float32",ky(s,"float32")),o=Hf().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vV(kV,i.shape,a.shape):new xV(IV,i.shape,a.shape),l=n.runWebGLProgram(o,[i,a],"float32");return n.disposeIntermediateTensorInfo(a),l}},TV="return (a < 0.) ? b * a : a;",CV="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",EV={kernelName:Yg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r,alpha:i}=e,s=Hf().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vV(CV,r.shape,i.shape):new xV(TV,r.shape,i.shape);return n.runWebGLProgram(s,[r,i],"float32")}},AV="if (isnan(x)) return x;";function NV({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:i,backend:s})=>{const{x:a}=i,o=s,l=r||a.dtype;if(o.shouldExecuteOnCPU([a])&&null!=n){const t=o.texData.get(a.dataId),e=n(t.values,l);return o.makeTensorInfo(a.shape,l,e)}let u;return u=Hf().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=e?new cV(a.shape,e):new YW(a.shape,t),o.runWebGLProgram(u,[a],l)}}function RV({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:s}){return({inputs:a,backend:o})=>{const{a:l,b:u}=a,c=o;if(r&&"complex64"===l.dtype){const e=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[r,i]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,i={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},a=new xV(t,l.shape,u.shape);return c.runWebGLProgram(a,[i,s],tv(n.dtype,r.dtype))})),s=SV({inputs:{real:r,imag:i},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(i),s}const h=s||tv(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=i){const t=c.texData.get(l.dataId).values,e=c.texData.get(u.dataId).values,n="string"===l.dtype?Ck(t):t,r="string"===l.dtype?Ck(e):e,[s,a]=i(l.shape,u.shape,n,r,h),o=c.makeTensorInfo(a,h);return c.texData.get(o.dataId).values=s,o}let d;return d=Hf().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=e?new vV(e,l.shape,u.shape,n):new xV(t,l.shape,u.shape),c.runWebGLProgram(d,[l,u],h)}}function DV(t,e=!1){if("linear"===t)return e?sV:JW;if("relu"===t)return e?oV:eV;if("elu"===t)return e?aV:tV;if("relu6"===t)return e?lV:nV;if("prelu"===t)return e?CV:TV;if("leakyrelu"===t)return e?kV:IV;if("sigmoid"===t)return e?uV:iV;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class LV{constructor(t,e,n,r=!1,i=!1,s=!1,a=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=$U(this.outputShape.length);const u=r?t[1]:t[2],c=Math.ceil(u/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=i?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";a&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,g="result = activation(result);");const x=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";t[0]<e[0]?y=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(v=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${y};\n          int batchB = ${v};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${x}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const FV={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class $V{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=xb(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const PV="return a * b;";function OV(t){const{inputs:e,backend:n}=t,{a:r,b:i}=e,s=tv(r.dtype,i.dtype);if("complex64"===r.dtype){const t=n.texData.get(r.dataId),e=n.texData.get(i.dataId),s=new $V(FV.REAL,r.shape,i.shape),a=new $V(FV.IMAG,r.shape,i.shape),o=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:i.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:i.shape}],l=n.runWebGLProgram(s,o,"float32"),u=n.runWebGLProgram(a,o,"float32"),c=SV({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,i])){const t=n.texData.get(r.dataId),e=n.texData.get(i.dataId),[a,o]=xW(r.shape,i.shape,t.values,e.values,s),l=n.makeTensorInfo(o,s);return n.texData.get(l.dataId).values=a,l}let a;return a=Hf().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vV(PV,r.shape,i.shape):new xV(PV,r.shape,i.shape),n.runWebGLProgram(a,[r,i],s)}const zV={kernelName:zg,backendName:"webgl",kernelFunc:OV};function BV(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{shape:s}=r,a=n,o=pf(i.shape),l=vf(s,o),u=pf(l);uf(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=a.texData.get(i.dataId);return!c.isPacked||oU(i.shape,l)||null!==c.texture&&oU(c.shape,l)?(a.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype}):function(t,e,n){const r=[rU(t.shape),...iU(t.shape)],i={dtype:t.dtype,shape:r,dataId:t.dataId},s=[rU(e),...iU(e)],a=new HW(s,r),o=[r],l=n.runWebGLProgram(a,[i],t.dtype,o,!0);return{dataId:l.dataId,shape:e,dtype:l.dtype}}(i,l,a)}const UV={kernelName:ix,backendName:"webgl",kernelFunc:BV};class WV{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:i,outSize:s}=t;this.outputShape=[r,s];const a=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=e){const t=1/e;l=`sumValue += dot(values * ${mf(t)?t.toPrecision(2):t}, ones);`}let u="";i%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class VV{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:i,outSize:s}=t;this.outputShape=[r,s];let a="0.0",o="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",o="min"):"max"===e&&(a="-1.0 / 1e-20",o="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";i%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function GV(t,e,n,r){const i=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],r=EI(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}(t.shape);let s=t;for(let a=0;a<i.length;a++){const{inSize:o,windowSize:l,outSize:u}=i[a];let c,h;c="mean"===n?0===a?new WV({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},o):new WV({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u}):new VV({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},n),h=s,s=r.runWebGLProgram(c,[s],e),h.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(h)}return s}class HV{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];this.outputShape=n,this.rank=n.length;const r=AU(this.rank),i=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let e=0;e<t.length;e++)r[t[e]]=n[e];return r.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class jV{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=AU(this.rank),i=WW("rc",this.rank),s=new Array(this.rank);for(let t=0;t<e.length;t++)s[e[t]]=i[t];const a=`vec2(${s.slice(-2).join()})`,o=`++${i[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function qV(t,e,n){const r=Hf().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jV(t.shape,e):new HV(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}function XV(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r;return function(t,e,n,r){const i=e,s=t.shape.length,a=bf(i,t.shape);let o=a;const l=gS(o,s),u=null!=l;let c=t;u&&(c=qV(t,l,r),o=yS(o.length,s)),mS("sum",o,s);const[h,d]=pS(c.shape,o);let p=h;n&&(p=fS(h,a));const f=pf(d),m=BV({inputs:{x:c},attrs:{shape:[pf(t.shape)/f,f]},backend:r}),g=GV(m,ev(t.dtype),"sum",r),x=BV({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),x}(i,s,a,n)}const KV={kernelName:Ix,backendName:"webgl",kernelFunc:XV};function YV(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{perm:s}=r,a=n,o=i.shape.length,l=new Array(o);for(let t=0;t<l.length;t++)l[t]=i.shape[s[t]];let u;if(a.shouldExecuteOnCPU([i])){const t=a.texData.get(i.dataId).values,e=BW(t,i.shape,i.dtype,s,l);u=a.makeTensorInfo(l,i.dtype),a.texData.get(u.dataId).values=e}else u=qV(i,s,a);return u}const ZV={kernelName:Hx,backendName:"webgl",kernelFunc:YV},JV=1e3;function QV({a:t,b:e,transposeA:n,transposeB:r,backend:i,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,h=n?t.shape[u-2]:t.shape[u-1],d=r?e.shape[c-1]:e.shape[c-2],p=n?t.shape[u-1]:t.shape[u-2],f=r?e.shape[c-2]:e.shape[c-1],m=t.shape.slice(0,-2),g=e.shape.slice(0,-2),x=pf(m),y=pf(g),v=xb(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);uf(h===d,(()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`));const b=n?[x,h,p]:[x,p,h],w=r?[y,f,d]:[y,d,f],S=BV({inputs:{x:t},backend:i,attrs:{shape:b}}),_=BV({inputs:{x:e},backend:i,attrs:{shape:w}}),I=[S,_],k=Math.max(x,y),M=n?S.shape[1]:S.shape[2],T=null!=s,C=null!=a,E="leakyrelu"===l,A=null!=l?DV(l,!0):null;let N;if((1===p||1===f)&&M>JV&&!1===(T||C||E||null!=A)){let t=S,e=_;n&&(t=YV({inputs:{x:S},backend:i,attrs:{perm:[0,2,1]}}),I.push(t)),r&&(e=YV({inputs:{x:_},backend:i,attrs:{perm:[0,2,1]}}),I.push(e));const s=1===f;let a=t;1!==f&&(a=BV({inputs:{x:t},backend:i,attrs:{shape:[k,M,1]}}),I.push(a));const o=1===f?2:1;let l=e;s&&(l=BV({inputs:{x:e},backend:i,attrs:{shape:[k,1,M]}}),I.push(l));const u=OV({inputs:{a,b:l},backend:i});N=XV({inputs:{x:u},backend:i,attrs:{axis:o,keepDims:!0}}),I.push(u)}else{const l=tv(t.dtype,e.dtype),u=new LV(b,w,[k,p,f],n,r,T,A,C,E),c=[S,_];if(null!=s&&c.push(s),C&&c.push(a),E){const t=i.makeTensorInfo([],"float32",ky(o,"float32"));c.push(t),I.push(t)}N=i.runWebGLProgram(u,c,l)}const R=BV({inputs:{x:N},backend:i,attrs:{shape:v}});I.push(N);for(const t of I)i.disposeIntermediateTensorInfo(t);return R}const tG={kernelName:Jx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:i,b:s,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return QV({a:i,b:s,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},eG="return abs(x);",nG={kernelName:Yf,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const t=n.texData.get(r.dataId),e=TW(t.values);return n.makeTensorInfo(r.shape,r.dtype,e)}let i;return i=Hf().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new cV(r.shape,eG):new YW(r.shape,eG),n.runWebGLProgram(i,[r],r.dtype)}},rG=NV({opSnippet:ZW+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),iG={kernelName:Zf,backendName:"webgl",kernelFunc:rG},sG=NV({opSnippet:ZW+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),aG={kernelName:Jf,backendName:"webgl",kernelFunc:sG},oG="return a + b;",lG=RV({opSnippet:oG,packedOpSnippet:oG,supportsComplex:!0,cpuKernelImpl:YU}),uG={kernelName:Qf,backendName:"webgl",kernelFunc:lG};class cG{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`float v${t} = get${t}AtOutCoords();`)}));const r=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class hG{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)}));const r=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const dG={kernelName:tm,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,i=n;if(1===i.length)return bV({inputs:{x:i[0]},backend:r});if(i.length>Hf().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(i.length/2),n=t({inputs:i.slice(0,e),backend:r}),s=t({inputs:i.slice(e),backend:r});return t({inputs:[n,s],backend:r})}const s=i.map((t=>t.dtype)).reduce(((t,e)=>tv(t,e))),a=i.map((t=>t.shape)),o=Hf().getBool("WEBGL_PACK")?new hG(i[0].shape,a):new cG(i[0].shape,a);return r.runWebGLProgram(o,i,s)}},pG={kernelName:em,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,l=bf(s,i.shape);let u=l;const c=gS(u,o);let h=i;null!=c&&(h=YV({inputs:{x:i},backend:n,attrs:{perm:c}}),u=yS(u.length,o)),mS("all",u,o);const[d,p]=pS(h.shape,u),f=BV({inputs:{x:h},backend:n,attrs:{shape:[-1,pf(p)]}}),m=GV(f,f.dtype,"all",n);let g;return g=BV(a?{inputs:{x:m},backend:n,attrs:{shape:fS(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},fG={kernelName:nm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,l=bf(s,i.shape);let u=l;const c=gS(u,o);let h=i;null!=c&&(h=YV({inputs:{x:i},backend:n,attrs:{perm:c}}),u=yS(u.length,o)),mS("any",u,o);const[d,p]=pS(h.shape,u),f=BV({inputs:{x:h},backend:n,attrs:{shape:[-1,pf(p)]}}),m=GV(f,f.dtype,"any",n);let g;return g=BV(a?{inputs:{x:m},backend:n,attrs:{shape:fS(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class mG{constructor(t,e,n){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:s}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[i,s];const a="max"===e?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${a} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class gG{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,uf(t.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const i=t[t.length-1],s=Math.ceil(i/e);this.outputShape=t.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,o=a.length,l=AU(o),u=VW("coords",o);let c,h;if(1===s){h=o+1;const t=AU(h);c=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[o-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[o-2]};`}else h=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((t=>"int "+t)),m=VW("sourceLocR",h-1).concat("inIdx.r"),g=VW("sourceLocG",h-1).concat("inIdx.g"),x=VW("sourceLocB",h-1).concat("inIdx.b"),y=VW("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",b=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${x.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,S=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${S}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${a[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${a[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${b}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function xG(t,e,n,r=null){let i=e.shape[0],s=e.shape[1];null!=r&&(i=r.shape[0],s=r.shape[1]);const a=EI(s),o={windowSize:a,inSize:s,batchSize:i,outSize:Math.ceil(s/a)},l=new mG(o,n,null==r),u=[e];null!=r&&u.push(r);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=xG(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}function yG(t,e,n,r=null){const i=null!=r?r.shape:e.shape,s=EI(i[i.length-1]),a=new gG(i,s,n,null==r),o=null==r?[e]:[e,r],l=t.runWebGLProgram(a,o,"int32");if(l.shape.length===e.shape.length){const r=yG(t,e,n,l);return t.disposeIntermediateTensorInfo(l),r}return l}function vG(t,e,n,r){const i=[n];if(mS("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,e.shape.length),!Hf().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],s=t.texData.get(e.dataId);let a=e;null!==s&&s.isPacked&&(a=t.unpackTensor(e),n.push(a));const[o,l]=pS(a.shape,i),u=pf(l),c=BV({inputs:{x:a},backend:t,attrs:{shape:[-1,u]}});n.push(c);const h=xG(t,c,r);n.push(h);const d=BV({inputs:{x:h},backend:t,attrs:{shape:o}});return n.forEach((e=>t.disposeIntermediateTensorInfo(e))),d}return yG(t,e,r)}const bG={kernelName:rm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r;let a=bf(s,i.shape);const o=gS(a,i.shape.length);let l=i;const u=[];null!=o&&(l=YV({inputs:{x:i},backend:n,attrs:{perm:o}}),u.push(l),a=yS(a.length,l.shape.length)),mS("argMax",[a[0]],l.shape.length);const c=vG(n,l,a[0],"max");return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),c}},wG={kernelName:im,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r;let a=bf(s,i.shape);const o=gS(a,i.shape.length);let l=i;const u=[];null!=o&&(l=YV({inputs:{x:i},backend:n,attrs:{perm:o}}),u.push(l),a=yS(a.length,l.shape.length)),mS("argMin",[a[0]],l.shape.length);const c=vG(n,l,a[0],"min");return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),c}},SG=NV({opSnippet:ZW+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),_G={kernelName:sm,backendName:"webgl",kernelFunc:SG},IG=NV({opSnippet:ZW+"return log(x + sqrt(x * x + 1.0));"}),kG={kernelName:am,backendName:"webgl",kernelFunc:IG},MG=NV({opSnippet:ZW+"\n  return atan(x);\n"}),TG={kernelName:om,backendName:"webgl",kernelFunc:MG},CG=RV({opSnippet:gV+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+yV+"\n  return result;\n"}),EG={kernelName:um,backendName:"webgl",kernelFunc:CG},AG=NV({opSnippet:ZW+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),NG={kernelName:lm,backendName:"webgl",kernelFunc:AG};class RG{constructor(t,e,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,a=t.strideHeight,o=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e,m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,g=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let x="0.0";if(f||(x="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${e} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?i?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(y="avgValue / count");const v=4*Math.floor(s/4),b=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${y});\n      }\n    `}}class DG{constructor(t,e,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const s=t.filterWidth,a=t.strideDepth,o=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;const y="avg"===e;let v="0.0";if(y||(v="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${e} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(b="avgValue / count");const w=4*Math.floor(s/4),S=s%4,_=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${x});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${_}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${2===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${3===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${_}\n            }\n          }\n          setOutput(${b});\n        }\n      }\n    `}}const LG={kernelName:cm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;pU(i,"avgPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;uf(dw(a,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=nw(i.shape,s,a,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&ff(u.inShape,u.outShape))return bV({inputs:{x:i},backend:n});const c=new RG(u,"avg",!1);return n.runWebGLProgram(c,[i],"float32")}},FG={kernelName:dm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=rw(i.shape,s,a,[1,1,1],o,l,u),h=new DG(c,"avg",!1);return n.runWebGLProgram(h,[i],"float32")}};class $G{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,i=t.strideWidth,s=t.dilationHeight,a=t.dilationWidth,o=t.effectiveFilterHeight,l=t.effectiveFilterWidth,u=o-1-t.padInfo.top,c=l-1-t.padInfo.left,h=1/(e*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${a}) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class PG{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,i=t.strideDepth,s=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=c-1-t.padInfo.front,f=h-1-t.padInfo.top,m=d-1-t.padInfo.left,g=1/(e*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${i}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const OG={kernelName:pm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,a=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=rw(a.shape,o,l,[1,1,1],u,c),d=new PG(h);return n.runWebGLProgram(d,[i],a.dtype)}},zG={kernelName:hm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,a=s;pU([i,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=nw(a.shape,o,l,1,u),h=new $G(c);return n.runWebGLProgram(h,[i],a.dtype)}},BG={kernelName:fm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:i,b:s}=e,{transposeA:a,transposeB:o}=r;return QV({a:i,b:s,transposeA:a,transposeB:o,backend:n})}};class UG{constructor(t,e,n,r,i,s){this.outputShape=[],this.variableNames=["x","mean","variance"],xb(t,e),xb(t,n);let a="0.0";null!=r&&(xb(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="1.0";null!=i&&(xb(t,i),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class WG{constructor(t,e,n,r,i,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],xb(t,e),xb(t,n);let a="vec4(0.0)";null!=r&&(xb(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=i&&(xb(t,i),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const VG={kernelName:ig,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:i,variance:s,offset:a,scale:o}=t;uf(i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),uf(null==a||i.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),uf(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[r,i,s];let c=null;null!=a&&(c=a.shape,u.push(a));let h=null;null!=o&&(h=o.shape,u.push(o));const d=Hf().getBool("WEBGL_PACK_NORMALIZATION")?new WG(r.shape,i.shape,s.shape,c,h,l):new UG(r.shape,i.shape,s.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)}};class GG{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=AU(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(t){if(1===t)return"sourceLoc";if(t<=6)return HG.slice(0,t).map((t=>"sourceLoc."+t)).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map(((t,e)=>`sourceLoc.${HG[e]} = start[${e}] + coords.${HG[e]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const HG=["x","y","z","w","u","v"];class jG{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=AU(this.rank),n=VW("coords",this.rank),r=VW("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${i})`,a=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map(((t,e)=>`start[${e}]`)).join()});`:t.map(((t,e)=>`${r[e]} = ${n[e]} + start[${e}];`)).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${a}\n        ${o}\n        setOutput(result);\n      }\n    `}}function qG(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,size:a}=r,[o,l]=Lb(i,s,a);if(bb(i,o,l),0===pf(l))return n.makeTensorInfo(l,i.dtype,[]);if(n.shouldExecuteOnCPU([i])||"string"===i.dtype){const t=n.texData.get(i.dataId),e=CW(t.values,o,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,e)}const{isPacked:u}=n.texData.get(i.dataId),c=Rb(i.shape,o,l);if(u||!c){const t=Hf().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jG(l):new GG(l),e=[o];return n.runWebGLProgram(t,[i],i.dtype,e)}return n.uploadToGPU(i.dataId),function(t,e,n,r){const i=r.texData.get(t.dataId),s=r.makeTensorInfo(n,t.dtype),a=r.texData.get(s.dataId);Object.assign(a,i),a.refCount=1,a.shape=n,a.dtype=t.dtype;let o=Db(e,Rf(t.shape));i.slice&&(o+=i.slice.flatOffset),a.slice={flatOffset:o,origDataId:i.slice&&i.slice.origDataId||t.dataId};const l=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,l+1),s}(i,o,l,n)}const XG={kernelName:xx,backendName:"webgl",kernelFunc:qG},KG={kernelName:mm,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,crops:a}=r;uf(i.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((t,e)=>t*e)),l=NI(i.shape,s,o),u=RI(l.length,s.length),c=DI(i.shape,s,o),h=LI(a,s.length),d=FI(c,a,s.length),p=[],f=BV({inputs:{x:i},backend:n,attrs:{shape:l}}),m=YV({inputs:{x:f},backend:n,attrs:{perm:u}}),g=BV({inputs:{x:m},backend:n,attrs:{shape:c}}),x=qG({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach((t=>n.disposeIntermediateTensorInfo(t))),x}},YG={kernelName:gm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:a}=r,o=n.readSync(i.dataId),l=n.readSync(s.dataId),u=ZU(o,l,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,u)}},ZG={kernelName:xm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:i}=e,s=n.readSync(r.dataId),a=n.readSync(i.dataId),o=xb(Array.from(s),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},JG=RV({opSnippet:"return float(a != b);",cpuKernelImpl:vW,dtype:"bool"}),QG={kernelName:Ug,backendName:"webgl",kernelFunc:JG};function tH(t){const{inputs:e,backend:n}=t,{input:r}=e;return bV({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const eH={kernelName:ex,backendName:"webgl",kernelFunc:tH},nH={kernelName:ym,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{dtype:a}=i;if("complex64"===a){if("complex64"===s.dtype)return bV({inputs:{x:s},backend:r});const e=IS(s.shape),n=t({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),i=SV({inputs:{real:n,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(n),i}if("complex64"===s.dtype){const e=tH({inputs:{input:s},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:a}});return r.disposeIntermediateTensorInfo(e),n}if(!If(s.dtype,a)){const t=bV({inputs:{x:s},backend:r});return{dataId:t.dataId,shape:t.shape,dtype:a}}if(r.shouldExecuteOnCPU([s])){const t=r.texData.get(s.dataId).values,[e,n,i]=QU(t,s.shape,s.dtype,a);return r.makeTensorInfo(e,n,i)}if("int32"===a)return function(t,e){const n=new YW(t.shape,"return float(int(x));"),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===a){const t=r.makeTensorInfo([],"bool",Sf("bool",1)),e=JG({inputs:{a:s,b:t},backend:r});return r.disposeIntermediateTensorInfo(t),e}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}},rH="return ceil(x);",iH=NV({opSnippet:rH,packedOpSnippet:rH,cpuKernelImpl:tW}),sH={kernelName:vm,backendName:"webgl",kernelFunc:iH};class aH{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class oH{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const lH={kernelName:bm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{clipValueMin:s,clipValueMax:a}=r;let o;o=Hf().getBool("WEBGL_PACK_CLIP")?new oH(i.shape):new aH(i.shape);const l=[[s],[a]];return n.runWebGLProgram(o,[i],i.dtype,l)}};class uH{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function cH(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const hH={kernelName:Sm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,i=n.texData.get(r.dataId),s=new uH(r.shape),a=[cH(r,i.complexTensorInfos.real),cH(r,i.complexTensorInfos.imag)];return n.runWebGLProgram(s,a,a[0].dtype)}};class dH{constructor(t){this.outputShape=[],this.outputShape=SI(t,1),this.variableNames=t.map(((t,e)=>`T${e}`));const e=new Array(t.length-1);e[0]=t[0][1];for(let n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let t=1;t<e.length;t++){const r=e[t-1];n.push(`else if (yC < ${e[t]}) setOutput(getT${t}(yR, yC-${r}));`)}const r=e.length,i=e[e.length-1];n.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class pH{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=SI(t,e);const n=this.outputShape,r=n.length,i=AU(r),s=VW("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(((t,e)=>`T${e}`));const o=new Array(t.length-1);o[0]=t[0][e];for(let n=1;n<o.length;n++)o[n]=o[n-1]+t[n][e];const l=a[e],u=a.slice(-2),c=a.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let t=1;t<o.length;t++){const e=o[t-1];h+=`\n        if (${l} < ${o[t]}  && ${l} >= ${o[t-1]}) {\n          return getChannel(\n            getT${t}(${fH(a,l,e)}),\n            vec2(${fH(u,l,e)}));\n        }`}const d=o.length,p=o[o.length-1];h+=`\n        return getChannel(\n          getT${d}(${fH(a,l,p)}),\n          vec2(${fH(u,l,p)}));`,this.userCode=`\n      float getValue(${a.map((t=>"int "+t))}) {\n        ${h}\n      }\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function fH(t,e,n){const r=t.indexOf(e);return t.map(((t,e)=>e===r?`${t} - ${n}`:t)).join()}function mH(t){const{inputs:e,backend:n}=t,{input:r}=e;return bV({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const gH={kernelName:hg,backendName:"webgl",kernelFunc:mH};function xH(t,e,n){const r=t[0].dtype;if("complex64"===r){const r=t.map((t=>tH({inputs:{input:t},backend:n}))),i=t.map((t=>mH({inputs:{input:t},backend:n}))),s=xH(r,e,n),a=xH(i,e,n),o=SV({inputs:{real:s,imag:a},backend:n});return r.forEach((t=>n.disposeIntermediateTensorInfo(t))),i.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),o}let i=n.shouldExecuteOnCPU(t);if("string"===r&&(i=!0),i){const i=t.map((t=>{const r=pf(t.shape.slice(e));return BV({inputs:{x:t},backend:n,attrs:{shape:[-1,r]}})})),s=i.map((t=>({vals:n.readSync(t.dataId),shape:t.shape}))),a=SI(i.map((t=>t.shape)),1),o=1===i[0].shape[0],l=eW(s,a,r,o),u=SI(t.map((t=>t.shape)),e),c=n.makeTensorInfo(u,r,l);return i.forEach((t=>n.disposeIntermediateTensorInfo(t))),c}const s=Hf().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(t.length>s){const r=[];for(let i=0;i<t.length;i+=s){const a=t.slice(i,i+s);r.push(xH(a,e,n))}const i=xH(r,e,n);for(const t of r)n.disposeIntermediateTensorInfo(t);return i}if(Hf().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const i=new pH(t.map((t=>t.shape)),e);return n.runWebGLProgram(i,t,r)}const{tensors2D:a,outShape:o}=function(t,e,n){const r=SI(t.map((t=>t.shape)),e);return{tensors2D:t.map((t=>BV({inputs:{x:t},attrs:{shape:[-1,pf(t.shape.slice(e))]},backend:n}))),outShape:r}}(t,e,n),l=new dH(a.map((t=>t.shape))),u=n.runWebGLProgram(l,a,r);a.forEach((t=>n.disposeIntermediateTensorInfo(t)));const c=BV({inputs:{x:u},attrs:{shape:o},backend:n});return n.disposeIntermediateTensorInfo(u),c}function yH(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r,s=bf(i,e[0].shape)[0];wI(e.map((t=>t.shape)),s);const a=SI(e.map((t=>t.shape)),s);if(0===pf(a))return n.makeTensorInfo(a,e[0].dtype,[]);const o=e.filter((t=>pf(t.shape)>0));return 1===o.length?bV({inputs:{x:o[0]},backend:n}):xH(o,s,n)}const vH={kernelName:_m,backendName:"webgl",kernelFunc:yH};class bH{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,a=t.padInfo.left,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,m="channelsLast"===t.dataFormat,g=m?1:2,x=m?2:3,y=m?3:1;let v="",b="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${x}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${b}\n        setOutput(result);\n      }\n    `}}class wH{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,s=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${s}, ${a});\n      const ivec3 pads = ivec3(${e}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SH{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=$U(this.outputShape.length);const s=t.padInfo.left,a=t.strideWidth,o=t.dilationWidth,l=t.filterHeight,u=t.filterWidth,c=u;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let t=0;t<u;t++)h+=`\n           vec4 xTexelC${2*t};\n           int xTexelC${2*t}Ready;\n           vec4 xTexelC${2*t+1};\n           int xTexelC${2*t+1}Ready;\n           vec4 xC${t};`;h+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let t=0;t<u;t++)h+=`\n           xTexelC${2*t} = vec4(0.0);\n           xTexelC${2*t}Ready = 0;\n           xTexelC${2*t+1} = vec4(0.0);\n           xTexelC${2*t+1}Ready = 0;\n           xC${t} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let e=0;e<(c+1)/2;e++){const n=2*e;if(h+=`\n           xC = xCCorner + ${n*o};\n           `,1===a){if(n<u&&(s%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,h+=1===o&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<u)){const t=s%2==0?of(o):o;o%2==0&&s%2==1||o%2!=0&&s%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,h+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):h+=1===t?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${t};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<u&&(s%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<u&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<u&&(h+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<u&&(h+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<u&&(h+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:i?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class _H{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=$U(this.outputShape.length);const{dataFormat:n}=e,r=mU(),i="channelsLast"===n,s=i?1:2,a=i?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let l="";for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${t};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*t+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*t+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function IH(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&1===n&&t[0]>1?[t[0],1]:null}function kH({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){const l=t.shape,u=r.texData.get(t.dataId),c=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,p="channelsLast"===n.dataFormat;let f;const m=[];if(null!=s){const t=IH(s.shape,p);null!=t&&(s=BV({inputs:{x:s},backend:r,attrs:{shape:t}}),m.push(s))}if(null!=i){const t=IH(i.shape,p);null!=t&&(i=BV({inputs:{x:i},backend:r,attrs:{shape:t}}),m.push(i))}if((1!==h&&1!==d||!(c>JV))&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&ff(u.shape.slice(-3),l.slice(-3))){const c=l[0]*l[1]*(l[2]+1),h={dataId:t.dataId,shape:[1,c,n.inChannels],dtype:t.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,uf(oU(u.shape,h.shape),(()=>`packed reshape ${u.shape} to ${h.shape} isn't free`));const p=BV({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(p);const g=QV({a:h,b:p,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a}),x=r.texData.get(g.dataId);uf(x.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=d,x.shape=n.outShape,f=bV({inputs:{x:g},backend:r}),f.shape=n.outShape,m.push(g)}else{const l=n.outHeight*n.outWidth,u=BV({inputs:{x:t},backend:r,attrs:{shape:p?[n.batchSize,l,n.inChannels]:[n.batchSize,n.inChannels,l]}}),c=BV({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),h=QV({a:p?u:c,b:p?c:u,transposeA:!p,transposeB:!1,backend:r,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a});f=BV({inputs:{x:h},backend:r,attrs:{shape:n.outShape}}),m.push(u),m.push(c),m.push(h)}for(const t of m)r.disposeIntermediateTensorInfo(t);return f}function MH({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=l*u*c,g=d*h,x=[n.batchSize,m,g],y=[];if(null!=s){const t=IH(s.shape,f);null!=t&&(s=BV({inputs:{x:s},backend:r,attrs:{shape:t}}),y.push(s))}if(null!=i){const t=IH(i.shape,f);null!=t&&(i=BV({inputs:{x:i},backend:r,attrs:{shape:t}}),y.push(i))}const v=BV({inputs:{x:e},backend:r,attrs:{shape:[1,m,pf(e.shape)/m]}});y.push(v);const b=new _H(x,n),w=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],S=r.runWebGLProgram(b,[t],"float32",w),_=BV({inputs:{x:S},backend:r,attrs:{shape:x}});y.push(S),y.push(_);const I=null!=i,k=null!=s,M="leakyrelu"===o,T=o?DV(o,!0):null,C=new LV(f?_.shape:v.shape,f?v.shape:_.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],!0,!1,I,T,k,M),E=f?[_,v]:[v,_];if(i&&E.push(i),k&&E.push(s),M){const t=r.makeTensorInfo([],"float32",ky(a,"float32"));E.push(t),y.push(t)}const A=r.runWebGLProgram(C,E,"float32"),N=BV({inputs:{x:A},backend:r,attrs:{shape:n.outShape}});y.push(A);for(const t of y)r.disposeIntermediateTensorInfo(t);return N}const TH={kernelName:Im,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=pw(l),d=iw(i.shape,s.shape,a,u,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&Hf().getBool("WEBGL_EXP_CONV")){const t=new SH(d),e=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(t,[i,s],"float32",e)}else if(Hf().getBool("WEBGL_CONV_IM2COL"))p=MH({x:i,filter:s,convInfo:d,backend:n});else{const t=new bH(d);p=n.runWebGLProgram(t,[i,s],"float32")}else p=kH({x:i,filter:s,convInfo:d,backend:n});const f=BV({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class CH{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,s="channelsLast"===t.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${i};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class EH{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,i=t.strideWidth,s="channelsLast"===t.dataFormat,a=e-1-t.padInfo.top,o=n-1-t.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class AH{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,i=t.padInfo.front,s=t.padInfo.top,a=t.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${e} - ${i};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${a};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class NH{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,i=t.strideDepth,s=t.strideHeight,a=t.strideWidth,o=e-1-t.padInfo.front,l=n-1-t.padInfo.top,u=r-1-t.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${i}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const RH={kernelName:km,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=pw(l),d=iw(i.shape,c,a,1,o,u,!1,h),p=new CH(d);return n.runWebGLProgram(p,[i,s],"float32")}},DH={kernelName:Mm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=pw(u),d=iw(a,s.shape,o,1,l,c,!1,h),p=new EH(d);return n.runWebGLProgram(p,[i,s],"float32")}},LH={kernelName:Tm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l}=r,u=sw(i.shape,s.shape,a,l,o),c=new wH(u);return n.runWebGLProgram(c,[i,s],"float32")}},FH={kernelName:Cm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,pad:o,filterShape:l}=r,u=sw(i.shape,l,a,1,o),c=new AH(u);return n.runWebGLProgram(c,[i,s],"float32")}},$H={kernelName:Em,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{pad:a,strides:o,inputShape:l}=r,u=sw(l,s.shape,o,1,a),c=new NH(u);return n.runWebGLProgram(c,[i,s],"float32")}},PH=NV({opSnippet:AV+"\n  return cos(x);\n"}),OH={kernelName:Am,backendName:"webgl",kernelFunc:PH},zH=NV({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),BH={kernelName:Nm,backendName:"webgl",kernelFunc:zH};class UH{constructor(t,e,n,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,a,o,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===r?1:0,[p,f]=[a-1+".0",o-1+".0"],[m,g,x]=c>1?[""+(a-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,v,b]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${b};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const WH={kernelName:Lm,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{image:i,boxes:s,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=r,c=new UH(i.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[i,s,a],"float32")}};var VH;!function(t){t.Prod="*",t.Sum="+"}(VH||(VH={}));class GH{constructor(t,e,n,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,s=this.op===VH.Prod?"1.0":"0.0",a=n?s:`getX(${HH(i,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${AU(i)} coords = getOutputCoords();\n        int end = ${jH(i,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${jH(i,"coords",this.op)} = idx;\n          val ${this.op}= getX(${HH(i,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function HH(t,e,n){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function jH(t,e,n){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function qH(t,e,n,r,i,s){const a=e.shape.length,o=gS([r],a);let l=e;null!=o&&(l=YV({inputs:{x:e},backend:n,attrs:{perm:o}}));const u=yS(1,a)[0];if(u!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const c=l.shape[u];let h=bV({inputs:{x:l},backend:n});for(let e=0;e<=Math.ceil(Math.log2(c))-1;e++){const r=new GH(t,l.shape,!1,s),i=[[e]],a=h;h=n.runWebGLProgram(r,[h],h.dtype,i),n.disposeIntermediateTensorInfo(a)}if(i){const e=new GH(t,l.shape,i,s),r=h;h=n.runWebGLProgram(e,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const t=YV({inputs:{x:h},backend:n,attrs:{perm:xS(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),t}return h}const XH={kernelName:Rm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;return qH(VH.Prod,i,n,s,a,o)}},KH={kernelName:Dm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;return qH(VH.Sum,i,n,s,a,o)}},YH={kernelName:Fm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:a,binaryOutput:o}=r;if(1===i.shape.length){const t=n.readSync(i.dataId),e=n.readSync(s.dataId),r=ZU(t,e,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,r)}if(2===i.shape.length){const t=n.bufferSync(i),e=n.bufferSync(s),r=JU(t,e,a,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}};class ZH{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const JH={kernelName:$m,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockSize:s,dataFormat:a}=r,o=i.shape[0],l=("NHWC"===a?i.shape[1]:i.shape[2])*s,u=("NHWC"===a?i.shape[2]:i.shape[3])*s,c=("NHWC"===a?i.shape[3]:i.shape[1])/(s*s),h=new ZH("NHWC"===a?[o,l,u,c]:[o,c,l,u],s,a);return n.runWebGLProgram(h,[i],i.dtype)}};class QH{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=$U(this.outputShape.length);const s=t.filterHeight,a=t.filterWidth,o=t.outChannels/t.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class tj{constructor(t,e=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=$U(this.outputShape.length);const s=t.outChannels/t.inChannels,a=t.padInfo.left,o=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,h=c;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let t=0;t<c;t++)d+=`\n          vec4 xTexelC${2*t};\n          int xTexelC${2*t}Ready;\n          vec4 xTexelC${2*t+1};\n          int xTexelC${2*t+1}Ready;\n          vec4 xC${t};`;d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let t=0;t<c;t++)d+=`\n          xTexelC${2*t} = vec4(0.0);\n          xTexelC${2*t}Ready = 0;\n          xTexelC${2*t+1} = vec4(0.0);\n          xTexelC${2*t+1}Ready = 0;\n          xC${t} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let t=0;t<(h+1)/2;t++){const e=2*t;if(d+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(a%2==1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,d+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=a%2==0?of(l):l;l%2==0&&a%2==1||l%2!=0&&a%2!=1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,d+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):d+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(a%2==1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(d+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(d+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const ej={kernelName:Pm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),uf(dw(a,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`));const h=iw(i.shape,s.shape,a,c,o,u,!0);let d;d=Hf().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new tj(h):new QH(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[i,s],"float32",p)}};class nj{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${i};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rj{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,i=t.strideWidth,s=e-1-t.padInfo.top,a=n-1-t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const ij={kernelName:Om,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,h=iw(i.shape,c,a,o,l,u,!0),d=new nj(h);return n.runWebGLProgram(d,[i,s],"float32")}},sj={kernelName:zm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,h=iw(c,s.shape,a,o,l,u,!0),d=new rj(h);return n.runWebGLProgram(d,[i,s],"float32")}};class aj{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const oj={kernelName:Bm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,i=[...r.shape,...r.shape],s=pf(r.shape),a=BV({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new aj(s),l=n.runWebGLProgram(o,[a],a.dtype),u=BV({inputs:{x:l},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}};class lj{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:r,strideHeight:i,strideWidth:s,filterHeight:a,filterWidth:o,dilationHeight:l,dilationWidth:u}=t,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${s});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const uj={kernelName:Um,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:a,pad:o,dilations:l}=r,u=ew(i.shape,s.shape,a,o,"NHWC",l);let c;const h=new lj(u);c=n.runWebGLProgram(h,[i,s],"float32");const d=BV({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}},cj={kernelName:Hm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:i}=r,s=e,{allDims:a,summedDims:o,idDims:l}=ak(i,s.length);lk(a.length,l,s);const{path:u,steps:c}=uk(o,l),h=c.length;let d=null,p=a.length;const f=[];for(let t=0;t<h;++t){for(const e of c[t]){const{permutationIndices:t,expandDims:r}=ok(p,l[e]);let i;ck(t)?i=s[e]:(i=YV({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(i));const a=i.shape.slice();for(let t=0;t<r.length;++t)a.splice(r[t],0,1);ff(i.shape,a)||(i=BV({inputs:{x:i},backend:n,attrs:{shape:a}}),f.push(i)),null===d?d=i:(d=OV({inputs:{a:i,b:d},backend:n}),f.push(d))}t<h-1&&(u[t]>=0&&(d=XV({inputs:{x:d},backend:n,attrs:{axis:u[t]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const t of f)t!==d&&n.disposeIntermediateTensorInfo(t);return d}},hj=NV({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),dj={kernelName:jm,backendName:"webgl",kernelFunc:hj},pj={kernelName:qm,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:r,y:i}=e,s=Hf().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new vV("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,i.shape):new xV("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,i.shape);return n.runWebGLProgram(s,[r,i],r.dtype)}},fj=RV({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:nW}),mj={kernelName:Km,backendName:"webgl",kernelFunc:fj},gj=NV({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${WI};\n  float a1 = ${VI};\n  float a2 = ${GI};\n  float a3 = ${HI};\n  float a4 = ${jI};\n  float a5 = ${qI};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),xj={kernelName:Xm,backendName:"webgl",kernelFunc:gj},yj=NV({opSnippet:AV+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:rW,dtype:"float32"}),vj={kernelName:Ym,backendName:"webgl",kernelFunc:yj};function bj(t){const{inputs:e,attrs:n,backend:r}=t,{dim:i}=n,{input:s}=e,a=s.shape.length,o=s.shape.slice();let l=i;return i<0&&(uf(-(a+1)<=i,(()=>`Axis must be in the interval [${-(a+1)}, ${a}]`)),l=a+i+1),o.splice(l,0,1),BV({inputs:{x:s},backend:r,attrs:{shape:o}})}const wj={kernelName:Zm,backendName:"webgl",kernelFunc:bj},Sj="return exp(x) - 1.0;",_j=NV({opSnippet:Sj,packedOpSnippet:Sj,cpuKernelImpl:iW}),Ij={kernelName:Jm,backendName:"webgl",kernelFunc:_j};class kj{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Mj(t,e,n){const r=n.texData.get(t.dataId),i=pf(t.shape),s=t.shape[t.shape.length-1],a=BV({inputs:{x:t},backend:n,attrs:{shape:[i/s,s]}}),o=a.shape,l=new kj("real",o,e),u=new kj("imag",o,e),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(l,c,"float32"),d=n.runWebGLProgram(u,c,"float32"),p=SV({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=BV({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(p),f}const Tj={kernelName:Qm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return Mj(r,!1,n)}};class Cj{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Ej(t){const{backend:e,attrs:n}=t,{shape:r,value:i}=n;let{dtype:s}=n;if(s=s||Ef(i),"string"===s){const t=_f(s,pf(r));return t.fill(i),e.makeTensorInfo(r,s,t)}{const t=new Cj(r,i),n=[[i]];return e.runWebGLProgram(t,[],s,n)}}const Aj={kernelName:tg,backendName:"webgl",kernelFunc:Ej};class Nj{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Rj={kernelName:eg,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,i=new Nj(n.shape);return r.runWebGLProgram(i,[n],n.dtype)}},Dj="return floor(x);",Lj=NV({opSnippet:Dj,packedOpSnippet:Dj,cpuKernelImpl:sW}),Fj={kernelName:ng,backendName:"webgl",kernelFunc:Lj},$j=RV({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Pj={kernelName:rg,backendName:"webgl",kernelFunc:$j};class Oj{constructor(t){this.variableNames=["A"];const e=mU(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class zj{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=mU(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const Bj={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:i}=e;const{numChannels:s}=r,a="undefined"!=typeof HTMLVideoElement&&i instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&i instanceof HTMLImageElement,[l,u]=a?[i.videoWidth,i.videoHeight]:[i.width,i.height],c=[u,l],h=[u,l,s];if(o||a){const t=Hf().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Uj&&t===Wj||(Wj=t,Uj=document.createElement("canvas").getContext("2d",{willReadFrequently:Wj})),Uj.canvas.width=l,Uj.canvas.height=u,Uj.drawImage(i,0,0,l,u),i=Uj.canvas}const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=PB.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),i);const p=Hf().getBool("WEBGL_PACK")?new zj(h):new Oj(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let Uj,Wj=Hf().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Vj={kernelName:Qx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=pw(c),g=iw(i.shape,s.shape,l,h,u,d,!1,m);let x;const y=[],v=null!=a,b=null!=o,w="leakyrelu"===p,S=()=>{const t=[i,s],e=(t,e)=>{if("NCHW"===e&&1===t.shape.length&&1!==t.shape[0]){const e=BV({inputs:{x:t},backend:n,attrs:{shape:[t.shape[0],1,1]}});return y.push(e),e}return t};if(v&&t.push(e(a,c)),b&&t.push(e(o,c)),w){const e=n.makeTensorInfo([],"float32",ky(f,"float32"));t.push(e),y.push(e)}return t};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&Hf().getBool("WEBGL_EXP_CONV")){const t=p?DV(p,!0):null,e=new SH(g,v,t,b,w),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],i=S();x=n.runWebGLProgram(e,i,"float32",r)}else if(Hf().getBool("WEBGL_CONV_IM2COL"))x=MH({x:i,filter:s,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const t=p?DV(p,!1):null,e=new bH(g,v,t,b,w),r=S();x=n.runWebGLProgram(e,r,"float32")}else x=kH({x:i,filter:s,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const _=BV({inputs:{x},backend:n,attrs:{shape:g.outShape}});return y.push(x),y.forEach((t=>n.disposeIntermediateTensorInfo(t))),_}},Gj={kernelName:ty,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),uf(dw(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=iw(i.shape,s.shape,l,m,u,h,!0),x=Hf().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=d?DV(d,x):null,v=[i,s],b=null!=a,w=null!=o,S="leakyrelu"===d;if(b&&v.push(a),w&&v.push(o),S){const t=n.makeTensorInfo([],"float32",ky(p,"float32"));v.push(t),f.push(t)}let _;_=x?new tj(g,b,y,w,S):new QH(g,b,y,w,S);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],k=n.runWebGLProgram(_,v,"float32",I);return f.forEach((t=>n.disposeIntermediateTensorInfo(t))),k}};class Hj{constructor(t,e,n,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const i=AU(n.length);let s="\n    int index;";for(let t=0;t<this.sliceDim;t++)s+=`\n          index = round(getIndices(coords[0], ${t}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[t]};\n          flattenIndex += index * ${this.strides[t]};`;this.userCode=`\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const jj={kernelName:ag,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:i}=e,s=i.shape,a=s[s.length-1],o=pf(r.shape),[l,u,c,h]=$I(r,i),d=BV({inputs:{x:i},backend:n,attrs:{shape:[u,a]}}),p=BV({inputs:{x:r},backend:n,attrs:{shape:[pf(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const t=n.readSync(i.dataId),e=n.bufferSync(r),s=aW(t,e,r.dtype,u,a,c,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new Hj(a,h,[u,c],r.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=BV({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class qj{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=AU(this.rank),r=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let e=0;e<t.length;e++)2===e?r.push("index"):r.push(`${n[e]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function Xj(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,indices:s}=e,{axis:a,batchDims:o}=r,l=bf(a,i.shape)[0];if(Hf().get("DEBUG")){const t=n.readSync(s.dataId),e=i.shape[l];for(let n=0;n<t.length;++n){const r=t[n];uf(r<=e-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${e-1}]`))}}const u=Tk(i,s,l,o),c=pf(s.shape),h=[],d=BV({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=BV({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([i,s])||"string"===i.dtype){const t=n.bufferSync(p),e=n.bufferSync(d),r=oW(e,t,f);return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new qj(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const x=BV({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),x}const Kj={kernelName:sg,backendName:"webgl",kernelFunc:Xj},Yj=RV({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:lW,dtype:"bool"}),Zj={kernelName:og,backendName:"webgl",kernelFunc:Yj},Jj=RV({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:uW}),Qj={kernelName:lg,backendName:"webgl",kernelFunc:Jj},tq={kernelName:cg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return Mj(r,!0,n)}},eq=NV({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),nq={kernelName:dg,backendName:"webgl",kernelFunc:eq},rq=NV({opSnippet:"return float(isinf(x));",dtype:"bool"}),iq={kernelName:pg,backendName:"webgl",kernelFunc:rq},sq=NV({opSnippet:"return float(isnan(x));",dtype:"bool"}),aq={kernelName:fg,backendName:"webgl",kernelFunc:sq},oq=RV({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:cW,dtype:"bool"}),lq={kernelName:gg,backendName:"webgl",kernelFunc:oq},uq=RV({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:hW,dtype:"bool"}),cq={kernelName:xg,backendName:"webgl",kernelFunc:uq},hq={kernelName:yg,backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:i,num:s}=n,a=dW(r,i,s);return e.makeTensorInfo([a.length],"float32",a)}},dq=NV({opSnippet:AV+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:pW}),pq={kernelName:vg,backendName:"webgl",kernelFunc:dq},fq=NV({opSnippet:AV+"\n  return log(1.0 + x);\n"}),mq={kernelName:bg,backendName:"webgl",kernelFunc:fq},gq=RV({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),xq={kernelName:wg,backendName:"webgl",kernelFunc:gq},yq=NV({opSnippet:"return float(!(x >= 1.0));"}),vq={kernelName:Sg,backendName:"webgl",kernelFunc:yq},bq=RV({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),wq={kernelName:_g,backendName:"webgl",kernelFunc:bq};class Sq{constructor(t,e,n,r,i){this.variableNames=["x"],this.outputShape=[];const s=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;o=.5===i?`inversesqrt(${l})`:1===i?`1.0/(${l})`:`exp(log(${l}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class _q{constructor(t,e,n,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;o=.5===i?`inversesqrt(${l})`:1===i?`1.0/(${l})`:`exp(log(${l}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const Iq={kernelName:Ig,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{depthRadius:s,bias:a,alpha:o,beta:l}=r,u=Hf().getBool("WEBGL_PACK_NORMALIZATION")?new _q(i.shape,s,a,o,l):new Sq(i.shape,s,a,o,l);return n.runWebGLProgram(u,[i],i.dtype)}};class kq{constructor(t,e,n,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${i})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Mq={kernelName:kg,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i,y:s,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r,h=new kq(i.shape,o,l,u,c);return n.runWebGLProgram(h,[i,s,a],i.dtype)}};function Tq(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reductionIndices:s,keepDims:a}=r,o=i.shape.length,l=bf(s,i.shape);let u=l;const c=gS(u,o),h=null!=c,d=n.shouldExecuteOnCPU([i]);let p=i;if(h){if(d){const t=n.texData.get(p.dataId).values,e=new Array(o);for(let t=0;t<e.length;t++)e[t]=i.shape[c[t]];const r=BW(t,i.shape,i.dtype,c,e);p=n.makeTensorInfo(e,i.dtype),n.texData.get(p.dataId).values=r}else p=qV(i,c,n);u=yS(u.length,o)}mS("max",u,o);const[f,m]=pS(p.shape,u);let g,x=f;if(a&&(x=fS(f,l)),d){const t=n.texData.get(p.dataId).values,e=fW(t,pf(m),x,i.dtype);g=n.makeTensorInfo(x,i.dtype),n.texData.get(g.dataId).values=e}else g=function(t,e,n,r){const i=pf(e),s=BV({inputs:{x:t},attrs:{shape:[pf(t.shape)/i,i]},backend:r}),a=GV(s,t.dtype,"max",r),o=BV({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(a),o}(p,m,x,n);return h&&n.disposeIntermediateTensorInfo(p),g}const Cq={kernelName:Mg,backendName:"webgl",kernelFunc:Tq},Eq=RV({opSnippet:gV+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+yV+"\n  return result;\n",cpuKernelImpl:mW}),Aq={kernelName:Tg,backendName:"webgl",kernelFunc:Eq},Nq={kernelName:Cg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;pU(i,"maxPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;uf(dw(a,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=nw(i.shape,s,a,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&ff(u.inShape,u.outShape))return bV({inputs:{x:i},backend:n});const c=new RG(u,"max",!1);return n.runWebGLProgram(c,[i],i.dtype)}},Rq={kernelName:Ag,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:a,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=rw(i.shape,s,a,[1,1,1],o,u,l),h=new DG(c,"max",!1);return n.runWebGLProgram(h,[i],i.dtype)}};class Dq{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,i=t.effectiveFilterHeight,s=t.effectiveFilterWidth,a=i-1-t.padInfo.top,o=s-1-t.padInfo.left,l=i*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Lq{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,s=t.dilationHeight,a=t.dilationWidth,o=t.effectiveFilterDepth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=o-1-t.padInfo.front,h=l-1-t.padInfo.top,d=u-1-t.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${e}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${a}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Fq={kernelName:Ng,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,a=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=rw(a.shape,o,l,[1,1,1],u,c),d=new DG(h,"max",!0),p=n.runWebGLProgram(d,[a],a.dtype),f=new Lq(h),m=n.runWebGLProgram(f,[i,p],a.dtype);return n.disposeIntermediateTensorInfo(p),m}},$q={kernelName:Eg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s,output:a}=e,o=s;pU([s,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=nw(o.shape,l,u,1,c,h),p=new RG(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new Dq(d),g=n.runWebGLProgram(m,[i,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},Pq={kernelName:Rg,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=e,l=n;uf(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const u=[1,1];uf(dw(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));const c=nw(r.shape,i,s,u,a),[h,d]=function(t,e,n,r){let i=new RG(n,"max",!1);const s=r.runWebGLProgram(i,[t],"float32");return i=new RG(n,"max",!0,!0,e),[s,r.runWebGLProgram(i,[t],"float32")]}(r,o,c,l);return[h,d]}},Oq={kernelName:Dg,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:i,axis:s}=e,a=n,o=r.shape.length,l=bf(s,r.shape);let u=l;const c=gS(u,o),h=null!=c,d=a.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const t=a.texData.get(f.dataId).values,e=new Array(o);for(let t=0;t<e.length;t++)e[t]=r.shape[c[t]];const n=BW(t,r.shape,r.dtype,c,e);f=a.makeTensorInfo(e,r.dtype),a.texData.get(f.dataId).values=n}else f=qV(r,c,a);p.push(f),u=yS(u.length,o)}mS("sum",u,o);const[m,g]=pS(f.shape,u);let x=m;i&&(x=fS(m,l));const y=function(t,e,n,r){const i=pf(e),s=BV({inputs:{x:t},attrs:{shape:[pf(t.shape)/i,i]},backend:r}),a=GV(s,"float32","mean",r),o=BV({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(a),o}(f,g,x,a);for(const t of p)a.disposeIntermediateTensorInfo(t);return y}},zq={kernelName:Lg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,l=bf(s,i.shape);let u=l;const c=gS(u,o);let h=i;null!=c&&(h=YV({inputs:{x:i},backend:n,attrs:{perm:c}}),u=yS(u.length,i.shape.length)),mS("min",u,o);const[d,p]=pS(h.shape,u),f=BV({inputs:{x:h},backend:n,attrs:{shape:[-1,pf(p)]}}),m=GV(f,f.dtype,"min",n);let g;return g=BV(a?{inputs:{x:m},backend:n,attrs:{shape:fS(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},Bq=RV({opSnippet:gV+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+yV+"\n  return result;\n",cpuKernelImpl:gW}),Uq={kernelName:Fg,backendName:"webgl",kernelFunc:Bq};class Wq{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,i=AU(r),s=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${i} start = ${i}(${s});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Vq{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,i=AU(r),s=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),o=VW("rc",r),l=VW("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const t=`\n        ${i} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${i} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const t=`\n        ${i} source = rc;\n        ${i} lt = ${i}(lessThan(source, start));\n        ${i} gte = ${i}(greaterThanEqual(source, end));\n        ${i} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${i} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${t}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${i} start = ${i}(${s});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const Gq={kernelName:$g,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:i,mode:s}=n,a=Hf().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vq(r.shape,i,s):new Wq(r.shape,i,s);return e.runWebGLProgram(a,[r],r.dtype)}},Hq=RV({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+yV+"\n  return result;\n"}),jq={kernelName:Pg,backendName:"webgl",kernelFunc:Hq};class qq{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const Xq=RV({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Kq={kernelName:Gm,backendName:"webgl",kernelFunc:Xq},Yq="return a - b;",Zq=RV({opSnippet:Yq,packedOpSnippet:Yq,supportsComplex:!0,cpuKernelImpl:PW}),Jq={kernelName:zx,backendName:"webgl",kernelFunc:Zq};function Qq(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{dim:s}=r,a=bf([s],i.shape),o=Tq({inputs:{x:i},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=fS(o.shape,a),u=BV({inputs:{x:o},backend:n,attrs:{shape:l}}),c=Zq({inputs:{a:i,b:u},backend:n}),h=yj({inputs:{x:c},backend:n}),d=XV({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:!1}}),p=BV({inputs:{x:d},backend:n,attrs:{shape:l}}),f=Xq({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const tX={kernelName:Tx,backendName:"webgl",kernelFunc:Qq},eX={kernelName:Og,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{numSamples:s,seed:a,normalized:o}=r,l=o?i:Qq({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new qq(u,c,s),d=[[a]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}},nX=ZW+"\n  return -x;\n",rX={kernelName:Bg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const t=n.texData.get(r.dataId),[e,i]=yW(t.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,e)}let i;return i=Hf().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new cV(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new YW(r.shape,nX),n.runWebGLProgram(i,[r],r.dtype)}},iX=D_,sX={kernelName:Wg,backendName:"webgl",kernelFunc:function(t){ey("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(i.dataId),c=n.readSync(s.dataId),{selectedIndices:h}=iX(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},aX=L_,oX={kernelName:Vg,backendName:"webgl",kernelFunc:function(t){ey("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(i.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=aX(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},lX=F_,uX={kernelName:Gg,backendName:"webgl",kernelFunc:function(t){ey("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(i.dataId),h=n.readSync(s.dataId),d=a,p=o,f=l,m=u,{selectedIndices:g,selectedScores:x}=lX(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};class cX{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const hX={kernelName:jg,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{dtype:s,depth:a,onValue:o,offValue:l}=r,u=pf(i.shape),c=new cX(u,a,o,l),h=BV({inputs:{x:i},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],s);n.disposeIntermediateTensorInfo(h);const p=BV({inputs:{x:d},backend:n,attrs:{shape:[...i.shape,a]}});return n.disposeIntermediateTensorInfo(d),p}};function dX(t){const{inputs:e,backend:n}=t,{x:r}=e;if("complex64"===r.dtype){const t=tH({inputs:{input:r},backend:n}),e=dX({inputs:{x:t},backend:n}),i=mH({inputs:{input:r},backend:n}),s=dX({inputs:{x:i},backend:n}),a=SV({inputs:{real:e,imag:s},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),a}return Ej({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const pX={kernelName:Kx,backendName:"webgl",kernelFunc:dX},fX={kernelName:Hg,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){const e=tH({inputs:{input:i},backend:r}),n=t({inputs:{x:e},backend:r}),s=mH({inputs:{input:i},backend:r}),a=dX({inputs:{x:s},backend:r}),o=SV({inputs:{real:n,imag:a},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(a),o}return Ej({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}},mX={kernelName:qg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(1===e.length)return bj({inputs:{input:e[0]},backend:n,attrs:{dim:i}});const s=e[0].shape,a=e[0].dtype;e.forEach((t=>{cf(s,t.shape,"All tensors passed to stack must have matching shapes"),uf(a===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=yH({inputs:e.map((t=>{const e=bj({inputs:{input:t},backend:n,attrs:{dim:i}});return o.push(e),e})),backend:n,attrs:{axis:i}});return o.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}};class gX{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,i=AU(r),s=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${i} start = ${i}(${s});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class xX{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,i=AU(r),s=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),o=VW("rc",r),l=VW("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${i} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let t=0,e=1===r?2:4;t<e;t++)p+=`\n        ${h[t]}\n        if (${d}) {\n          result[${t}] = float(value);\n        } else {\n          ${i} source = rc - start;\n          result[${t}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${s});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const yX=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:s,constantValue:a}=r;if(0===pf(i.shape)){const t=s.map(((t,e)=>t[0]+i.shape[e]+t[1]));return Ej({backend:n,attrs:{shape:t,value:a,dtype:i.dtype}})}const o=Hf().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xX(i.shape,s,a):new gX(i.shape,s,a),l=[[a]];return n.runWebGLProgram(o,[i],i.dtype,l)},vX={kernelName:Xg,backendName:"webgl",kernelFunc:yX},bX=RV({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+yV+"\n  return result;\n"}),wX={kernelName:Kg,backendName:"webgl",kernelFunc:bX},SX={kernelName:Zg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,l=[],u=bf(s,i.shape);let c=u;const h=gS(c,o);let d,p=i;if(null!=h&&(p=YV({inputs:{x:i},backend:n,attrs:{perm:h}}),c=yS(c.length,o),l.push(p)),mS("prod",c,o),n.shouldExecuteOnCPU([p])){const t=n.texData.get(p.dataId).values,{outVals:e,outShape:r,outDtype:i}=bW(p.shape,p.dtype,t,c);d=n.makeTensorInfo(r,i,e)}else{const[t,e]=pS(p.shape,c),r=pf(e),s=BV({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),a=GV(s,ev(i.dtype),"prod",n);d=BV({inputs:{x:a},backend:n,attrs:{shape:t}}),l.push(s),l.push(a)}if(a){l.push(d);const t=fS(d.shape,u);d=BV({inputs:{x:d},backend:n,attrs:{shape:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),d}},_X={kernelName:Jg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:i,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:o}=r,l=i.map((t=>n.readSync(t.dataId))),u=i.map((t=>t.shape)),c=n.readSync(s.dataId),h=n.readSync(a.dataId),[d,p,f]=wW(l,u,c,s.shape,s.dtype,h,a.shape,o),m=d.map((t=>n.makeTensorInfo([t.length],"int32",t))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}},IX={kernelName:Qg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{shape:i,values:s,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=r,u=n.readSync(i.dataId),c=n.readSync(s.dataId),h=n.readSync(a.dataId),d=o.map((t=>n.readSync(t.dataId))),p=o.map((t=>t.shape)),[f,m]=SW(u,i.shape,c,s.shape,s.dtype,h,a.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,m)}},kX=t=>{const{backend:e,attrs:n}=t,{start:r,stop:i,step:s,dtype:a}=n,o=_W(r,i,s,a);return e.makeTensorInfo([o.length],a,o)},MX={kernelName:tx,backendName:"webgl",kernelFunc:kX},TX=NV({opSnippet:"return 1.0 / x;"}),CX={kernelName:nx,backendName:"webgl",kernelFunc:TX},EX=NV({opSnippet:ZW+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),AX={kernelName:rx,backendName:"webgl",kernelFunc:EX},NX=NV({opSnippet:ZW+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),RX={kernelName:ux,backendName:"webgl",kernelFunc:NX};class DX{constructor(t,e,n,r,i){this.variableNames=["A"],this.outputShape=[];const[s,a,o,l]=t;this.outputShape=[s,e,n,l];const u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class LX{constructor(t,e,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,a,o,l]=t;this.outputShape=[s,e,n,l];const u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const FX={kernelName:ox,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,u]=o,c=Hf().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new LX(i.shape,l,u,s,a):new DX(i.shape,l,u,s,a);return n.runWebGLProgram(c,[i],"float32")}};class $X{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,s,a]=t,o=[n&&s>1?r-1:r,n&&a>1?i-1:i],l=[n&&s>1?s-1:s,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const PX={kernelName:lx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r,o=new $X(s.shape,i.shape,a);return n.runWebGLProgram(o,[s],s.dtype)}};class OX{constructor(t,e,n,r,i){this.variableNames=["A"],this.outputShape=[];const[s,a,o,l]=t;this.outputShape=[s,e,n,l];const u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class zX{constructor(t,e,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,a,o,l]=t;this.outputShape=[s,e,n,l];const u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const BX={kernelName:sx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,u]=o,c=Hf().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new zX(i.shape,l,u,s,a):new OX(i.shape,l,u,s,a);return n.runWebGLProgram(c,[i],i.dtype)}};class UX{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,s,a]=t,o=[n&&s>1?r-1:r,n&&a>1?i-1:i],l=[n&&s>1?s-1:s,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const WX={kernelName:ax,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:a}=r,o=new UX(s.shape,i.shape,a);return n.runWebGLProgram(o,[s],s.dtype)}};class VX{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const r=t.map(((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),i=AU(n);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class GX{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const r=VW("rc",n),i=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=AU(n);function o(n){const r=t.map(((r,i)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${r[n]} - 1`:`${r[n]}`}(i,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return o(t)}(r.slice())};\n          if(${i}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",o(t)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",o(t)}(r.slice())};\n            if(${i}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",o(t)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const HX={kernelName:cx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:s}=r,a=i.shape.length,o=bf(s,i.shape);if(0===a)return bV({inputs:{x:i},backend:n});const l=Hf().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GX(i.shape,o):new VX(i.shape,o);return n.runWebGLProgram(l,[i],i.dtype)}};class jX{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=t[1],r=t[2];this.outputShape=t;let i="";i="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const qX={kernelName:Zx,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:i,fillValue:s,center:a}=e,o=n,l=new jX(r.shape,s),[u,c]=AI(a,r.shape[1],r.shape[2]),h=[[u,c,Math.sin(i),Math.cos(i)]];return o.runWebGLProgram(l,[r],r.dtype,h)}},XX=NV({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),KX={kernelName:hx,backendName:"webgl",kernelFunc:XX},YX=NV({opSnippet:"return inversesqrt(x);",cpuKernelImpl:IW}),ZX={kernelName:dx,backendName:"webgl",kernelFunc:YX};class JX{constructor(t,e,n,r,i,s,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const o=AU(i.length),l=AU(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d=`getUpdates(${h})`,p=e>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${i});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${p};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const QX={kernelName:px,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:i,updates:s}=e,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=zI(0,i,a),d=[h/u,u];if(0===h)return n.makeTensorInfo(a,i.dtype);const p=BV({inputs:{x:i},backend:n,attrs:{shape:[l,o]}}),f=BV({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new JX(l,o,p.shape.length,f.shape.length,c,d),x=n.runWebGLProgram(g,[f,p,m],f.dtype),y=BV({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(m),y}};class tK{constructor(t,e,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,s=2===Hf().getNumber("WEBGL_VERSION")?"while (left < right) {":i,a="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${a} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const eK={kernelName:fx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:i,values:s}=e,{side:a}=r,o=new tK(i.shape[0],i.shape[1],s.shape[1],a),l=[[i.shape[1]]];return n.runWebGLProgram(o,[i,s],"int32",l)}};class nK{constructor(t,e,n){let r,i;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)i="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let r=0;r<e.length;r++)a.push(`${n[r]}`),r<t&&s.push(`${n[r]}`);r=s.join(),i=a.join()}const s=AU(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}const rK={kernelName:mx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:i,e:s}=e,a=new nK(r.shape.length,i.shape,i.shape.length);return n.runWebGLProgram(a,[r,i,s],tv(i.dtype,s.dtype))}},iK=NV({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${BI};\n  float scale = ${UI};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),sK={kernelName:gx,backendName:"webgl",kernelFunc:iK},aK=NV({opSnippet:AV+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:MW}),oK={kernelName:wx,backendName:"webgl",kernelFunc:aK},lK=NV({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),uK={kernelName:bx,backendName:"webgl",kernelFunc:lK},cK=NV({opSnippet:AV+"\n  return sin(x);\n"}),hK={kernelName:yx,backendName:"webgl",kernelFunc:cK},dK=NV({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),pK={kernelName:vx,backendName:"webgl",kernelFunc:dK},fK=NV({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),mK={kernelName:Sx,backendName:"webgl",kernelFunc:fK},gK={kernelName:kx,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,paddings:a}=r;uf(i.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((t,e)=>t*e)),l=[[0,0]];l.push(...a);for(let t=1+s.length;t<i.shape.length;++t)l.push([0,0]);const u=[],c=yX({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),h=NI(c.shape,s,o,!1),d=RI(h.length,s.length,!1),p=DI(c.shape,s,o,!1),f=BV({inputs:{x:c},backend:n,attrs:{shape:h}}),m=YV({inputs:{x:f},backend:n,attrs:{perm:d}}),g=BV({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((t=>n.disposeIntermediateTensorInfo(t))),g}},xK={kernelName:Cx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:i,denseShape:s,defaultValue:a}=e;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n         ${i.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.readSync(r.dataId),l=n.readSync(i.dataId),u=n.readSync(s.dataId),c=n.readSync(a.dataId)[0],[h,d,p,f,m]=EW(o,r.shape,r.dtype,l,i.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],i.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},yK={kernelName:Ex,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:i,newShape:s}=e;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const a=Array.from(n.readSync(i.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,h]=AW(o,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}},vK={kernelName:Ax,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const a=n.readSync(r.dataId),o=n.readSync(i.dataId),l=n.readSync(s.dataId),[u,c]=NW(a,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},bK={kernelName:Nx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const a=n.readSync(r.dataId),o=n.readSync(i.dataId),l=n.readSync(s.dataId),[u,c]=NW(a,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},wK={kernelName:Rx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:a}=e,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=zI(0,i,o);if("string"===s.dtype){const t=n.bufferSync(i),e=n.bufferSync(s),r=Ey(n.readSync(a.dataId)[0]),p=kW(t,e,o,d,c,u,l,h,r,!1);return n.makeTensorInfo(o,p.dtype,p.values)}const p=new JX(u,l,i.shape.length,s.shape.length,h,[d,1],!1),f=n.runWebGLProgram(p,[s,i,a],s.dtype),m=BV({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),m}},SK={kernelName:Mx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{numOrSizeSplits:s,axis:a}=r,o=bf(a,i.shape)[0],l=dk(i,s,o),u=i.shape.length,c=new Array(u).fill(0),h=i.shape.slice();return l.map((t=>{const e=[...h];e[o]=t;const r=qG({inputs:{x:i},backend:n,attrs:{begin:c,size:e}});return c[o]+=t,r}))}},_K="return sqrt(x);",IK=NV({opSnippet:_K,packedOpSnippet:_K,cpuKernelImpl:RW}),kK={kernelName:_x,backendName:"webgl",kernelFunc:IK},MK={kernelName:Lx,backendName:"webgl",kernelFunc:NV({opSnippet:"return x * x;"})},TK="return (a - b) * (a - b);",CK=RV({opSnippet:TK,packedOpSnippet:TK}),EK={kernelName:Dx,backendName:"webgl",kernelFunc:CK},AK={kernelName:Yx,backendName:"webgl",kernelFunc:function({inputs:t,attrs:e,backend:n}){const{x:r}=t,i=ZW+`\n    return x > 0.0 ? 1.0 : float(${e.alpha});\n  `,s=new YW(r.shape,i);return n.runWebGLProgram(s,[r],r.dtype)}};class NK{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,i=AU(n.length),s=AU(n.length);let a="";if(1===r)a="coords * strides + begin";else{let t=0;a=n.map(((e,r)=>(t++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${t-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${e});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const RK={kernelName:Fx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:x,begin:y,end:v,strides:b}=Fb(i.shape,s,a,o,l,u,c,h,d);let w;if(m)w=BV({inputs:{x:i},backend:n,attrs:{shape:f}});else if(g||x){uf(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));const t=Sb(y,v,b),e=qG({inputs:{x:i},backend:n,attrs:{begin:y,size:t}});w=BV({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else if(n.shouldExecuteOnCPU([i])){const t=n.readSync(i.dataId),e=sb(i.shape,i.dtype,t),r=DW(p,e,b,y);w=n.makeTensorInfo(f,i.dtype,r.values)}else{const t=new NK(y,b,p);w=n.runWebGLProgram(t,[i],i.dtype)}const S=BV({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),S}},DK={kernelName:$x,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=LW(d,p,i,s,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},LK={kernelName:Px,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:i}=r,{input:s,delimiter:a}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.readSync(s.dataId),l=n.readSync(a.dataId)[0],[u,c,h]=FW(o,l,i),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},FK={kernelName:Ox,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:i}=r,{input:s}=e;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=n.readSync(s.dataId),o=$W(a,i);return n.makeTensorInfo(s.shape,"int32",o)}},$K=NV({opSnippet:"return tan(x);"}),PK={kernelName:Bx,backendName:"webgl",kernelFunc:$K},OK=NV({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),zK={kernelName:Ux,backendName:"webgl",kernelFunc:OK};class BK{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[r]*e[r];this.outputShape=n,this.rank=n.length;const r=AU(this.rank),i=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let e=0;e<t.length;e++)r.push(`imod(${n[e]}, ${t[e]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function UK(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reps:s}=r;if("string"===i.dtype||i.shape.length>5){const t=n.readSync(i.dataId),e="string"===i.dtype?t.map((t=>Ey(t))):t,r=sb(i.shape,i.dtype,e),a=OW(r,s);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const a=new BK(i.shape,s);return n.runWebGLProgram(a,[i],i.dtype)}const WK={kernelName:Wx,backendName:"webgl",kernelFunc:UK};class VK{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class GK{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function HK(t,e){null!==e&&t.disposeIntermediateTensorInfo(e)}function jK(t){let e=1;for(;e<t;)e*=2;return e}const qK={kernelName:Vx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{k:s,sorted:a}=r,o=Hf().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Hf().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=i.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([i])||c<o||s>l){const t=n.readSync(i.dataId),[e,r]=zW(t,u,i.dtype,s,a);return[n.makeTensorInfo(e.shape,e.dtype,e.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,i.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[i,Ej({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(i.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(i):i,f=pf(u)/c,m=BV({inputs:{x:p},attrs:{shape:[f,c]},backend:n});d&&HK(n,p);const g=jK(s),x=jK(c);let y=null;const v=()=>null===y?[m,m]:[m,y],b=(t,e,r)=>{const i=v(),s=new VK(r),a=[[c],[null===y?1:0],[Number.NEGATIVE_INFINITY],[t],[e]],o=y;y=n.runWebGLProgram(s,i,"int32",a),HK(n,o)};for(let t=1;t<g;t*=2){const e=2*t;for(let n=t;n>=1;n/=2)b(e,n,[f,x])}for(let t=x;t>g;t/=2){const e=v(),r=new GK([f,t/2]),i=[[c],[null===y?1:0],[g]],s=y;y=n.runWebGLProgram(r,e,"int32",i),HK(n,s);const a=g/2,o=2*a;for(let t=a;t>=1;t/=2)b(o,t,y.shape)}let w=y;y=qG({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,s]}}),HK(n,w);let S=Xj({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});HK(n,m);const _=u.slice(0,-1);_.push(s),w=y,y=BV({inputs:{x:y},attrs:{shape:_},backend:n}),HK(n,w);const I=S;return S=BV({inputs:{x:S},attrs:{shape:_},backend:n}),HK(n,I),[S,y]}};class XK{constructor(t,e,n,r,i,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const a="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${i});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${i});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const KK={kernelName:Gx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:i,transforms:s}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=i.shape,[f,m]=null!=u?u:[h,d],g=new XK(h,d,a,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[i,s],"float32")}},YK={kernelName:jx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:i}=n,{x:s}=e;pU(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=UW(a,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},ZK={kernelName:qx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:i}=e;let{axis:s}=r;s<0&&(s+=i.shape.length);const a=i,o=a.shape.length,l=i.shape[s],u=new Array(o-1);let c=0;for(let t=0;t<o;t++)t!==s&&(u[c++]=a.shape[t]);const h=[],d=new Array(o).fill(0),p=a.shape.slice();p[s]=1;const f=new Array(l);for(let t=0;t<f.length;t++){d[s]=t;const e=qG({inputs:{x:a},backend:n,attrs:{begin:d,size:p}}),r=BV({inputs:{x:e},backend:n,attrs:{shape:u}});f[t]=r,h.push(e)}return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),f}};class JK{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,i=t.inSize,s=t.numSegments,a=s*Math.ceil(i/n);this.outputShape=[r,a];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";i%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let h="";i%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const QK=[tG,nG,iG,aG,uG,dG,pG,fG,bG,wG,_G,kG,TG,EG,NG,LG,FG,OG,zG,BG,VG,KG,YG,ZG,nH,sH,lH,_V,hH,vH,TH,RH,DH,LH,FH,$H,OH,BH,WH,XH,KH,YH,JH,ej,ij,sj,oj,uj,cj,dj,pj,mj,xj,vj,wj,Ij,Tj,Aj,Rj,Fj,Pj,Bj,Vj,Gj,jj,Kj,Zj,Qj,wV,tq,gH,nq,iq,aq,MV,lq,cq,hq,pq,mq,xq,vq,wq,Iq,Mq,Cq,Aq,Nq,Rq,Fq,$q,Pq,Oq,zq,Uq,Gq,jq,eX,zV,rX,sX,oX,uX,QG,hX,fX,mX,vX,wX,EV,SX,_X,IX,MX,eH,Kq,CX,AX,RX,UV,FX,PX,BX,WX,HX,qX,KX,ZX,QX,eK,rK,sK,oK,uK,hK,pK,XG,tX,mK,gK,xK,yK,vK,bK,wK,SK,kK,MK,EK,AK,RK,DK,LK,FK,Jq,KV,PK,zK,WK,qK,KK,ZV,YK,ZK,{kernelName:Xx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,segmentIds:s}=e,{numSegments:a}=r,o=i.shape.length,l=[];let u=0;const c=gS([u],o);let h=i;null!=c&&(h=YV({inputs:{x:i},backend:n,attrs:{perm:c}}),l.push(h),u=yS(1,o)[0]);const d=Mk(h.shape,u,a),p=pf([h.shape[u]]),f=BV({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=ev(i.dtype),g=(t,e,r,i,s)=>{const a=t.shape[0],o=t.shape[1],u=kk(o,s),c=new JK({windowSize:u,inSize:o,batchSize:a,numSegments:s},e),h=n.compileAndRun(c,[t,r],i);if(l.push(h),h.shape[1]===s)return h;const d=kX({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=UK({inputs:{x:d},backend:n,attrs:{reps:[o/u]}});return l.push(d),l.push(p),g(h,e,p,i,s)},x=BV({inputs:{x:g(f,"unsortedSegmentSum",s,m,a)},backend:n,attrs:{shape:d}});let y=x;if(null!=c){l.push(x);const t=xS(c);y=YV({inputs:{x:y},backend:n,attrs:{perm:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),y}},pX];for(const t of QK)ly(t);const tY=(t,e,n,r=0)=>{const i=((t,e,n,r=0)=>({x:t[0][0]*e+t[0][1]*n+t[0][3],y:t[1][0]*e+t[1][1]*n+t[1][3],z:t[2][0]*e+t[2][1]*n+t[2][3]}))(t,e,n,r),{x:s,y:a,z:o}=i;return{x:s/o,y:a/o}},eY=(t,e,n,r,i,s,a,o)=>({variableNames:["features","markerPixels","markerProperties","targetPixels"],outputShape:[o,i*i],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int featureIndex = coords[0];\n\t    int searchOffsetIndex = coords[1];\n\n\t    int markerWidth = int(getMarkerProperties(0));\n\t    int markerHeight = int(getMarkerProperties(1));\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int searchOffsetX = imod(searchOffsetIndex, ${i}) * ${r};\n\t    int searchOffsetY = searchOffsetIndex / ${i} * ${r};\n\n\t    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);\n\t    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);\n\n\t    int sx = sCenterX + searchOffsetX - ${n};\n\t    int sy = sCenterY + searchOffsetY - ${n};\n\n\t    if (sx < ${t} || sx >= (${a} - ${t}) || sy < ${t} || sy >= (${s} - ${t})) {\n\t      setOutput(-2.);\n\t    } \n\t    else {\n\t      float sumPoint = 0.;\n\t      float sumPointSquare = 0.;\n\t      float sumTemplate = 0.;\n\t      float sumTemplateSquare = 0.;\n\t      float sumPointTemplate = 0.;\n\n\t      for (int templateOffsetY = 0; templateOffsetY < ${e}; templateOffsetY++) {\n\t\tfor (int templateOffsetX = 0; templateOffsetX < ${e}; templateOffsetX++) {\n\t\t  int fx2 = sCenterX + templateOffsetX - ${t};\n\t\t  int fy2 = sCenterY + templateOffsetY - ${t};\n\n\t\t  int sx2 = sx + templateOffsetX - ${t};\n\t\t  int sy2 = sy + templateOffsetY - ${t};\n\n\t\t  int markerPixelIndex = fy2 * markerWidth + fx2;\n\t\t  float markerPixel = getMarkerPixels(markerPixelIndex);\n\t\t  float targetPixel = getTargetPixels(sy2, sx2);\n\n\t\t  sumTemplate += markerPixel;\n\t\t  sumTemplateSquare += markerPixel * markerPixel;\n\t\t  sumPoint += targetPixel;\n\t\t  sumPointSquare += targetPixel * targetPixel;\n\t\t  sumPointTemplate += targetPixel * markerPixel;\n\t\t}\n\t      }\n\n\t      // Normalized cross-correlation\n\t      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)\n\t      float count = float(${e} * ${e});\n\t      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);\n\t      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);\n\n\t      if (pointVariance < 0.0000001) {\n\t\tsetOutput(-3.);\n\t      } else if (templateVariance < 0.0000001) {\n\t\t//setOutput(sumTemplate);\n\t\tsetOutput(-4.);\n\t      } else {\n\t\tsumPointTemplate -= sumPoint / count * sumTemplate;\n\t\tfloat sim = sumPointTemplate / pointVariance / templateVariance;  \n\t\tsetOutput(sim);\n\t      }\n\t    }\n\t  }\n\t`}),nY=(t,e,n,r)=>({variableNames:["featurePoints","markerProperties","maxIndex"],outputShape:[r,2],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int featureIndex = coords[0];\n\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    int searchLocationIndex = maxIndex / ${n*n};\n\t    int searchOffsetIndex = imod(maxIndex, ${n*n});\n\n\t    if (coords[1] == 0) {\n\t      int searchOffsetX = imod(searchOffsetIndex, ${n}) * ${e};\n\t      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - ${t}) / markerScale);\n\t    }\n\t    else if (coords[1] == 1) {\n\t      int searchOffsetY = searchOffsetIndex / ${n} * ${e};\n\t      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - ${t}) / markerScale);\n\t    }\n\t  }\n\t`}),rY=t=>({variableNames:["sims","maxIndex"],outputShape:[t],userCode:"\n\t  void main() {\n\t    int featureIndex = getOutputCoords();\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    setOutput(getSims(featureIndex, maxIndex));\n\t  }\n\t"}),iY=(t,e)=>({variableNames:["p"],outputShape:[t,e],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float sum = getP(coords[0], coords[1]-2);\n\t    sum += getP(coords[0], coords[1]-1) * 4.;\n\t    sum += getP(coords[0], coords[1]) * 6.;\n\t    sum += getP(coords[0], coords[1]+1) * 4.;\n\t    sum += getP(coords[0], coords[1]+2);\n\t    setOutput(sum);\n\t  }\n\t"}),sY=(t,e)=>({variableNames:["p"],outputShape:[t,e],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float sum = getP(coords[0]-2, coords[1]);\n\t    sum += getP(coords[0]-1, coords[1]) * 4.;\n\t    sum += getP(coords[0], coords[1]) * 6.;\n\t    sum += getP(coords[0]+1, coords[1]) * 4.;\n\t    sum += getP(coords[0]+2, coords[1]);\n\t    sum /= 256.;\n\t    setOutput(sum);\n\t  }\n\t"}),aY=[{sigma:.55,points:[[-1,0],[-.5,-.866025],[.5,-.866025],[1,-0],[.5,.866025],[-.5,.866025]]},{sigma:.475,points:[[0,.930969],[-.806243,.465485],[-.806243,-.465485],[-0,-.930969],[.806243,-.465485],[.806243,.465485]]},{sigma:.4,points:[[.847306,-0],[.423653,.733789],[-.423653,.733789],[-.847306,0],[-.423653,-.733789],[.423653,-.733789]]},{sigma:.325,points:[[-0,-.741094],[.641806,-.370547],[.641806,.370547],[0,.741094],[-.641806,.370547],[-.641806,-.370547]]},{sigma:.25,points:[[-.595502,0],[-.297751,-.51572],[.297751,-.51572],[.595502,-0],[.297751,.51572],[-.297751,.51572]]},{sigma:.175,points:[[0,.362783],[-.314179,.181391],[-.314179,-.181391],[-0,-.362783],[.314179,-.181391],[.314179,.181391]]},{sigma:.1,points:[[0,0]]}],oY=[];for(let t=0;t<aY.length;t++){const e=aY[t].sigma;for(let n=0;n<aY[t].points.length;n++){const r=aY[t].points[n];oY.push([e,r[0],r[1]])}}const lY=oY,uY=(lY.length-1)*lY.length/2,cY=1/(2*Math.PI),hY=t=>{const e=[];for(let n=1;n<t.length;n++)e.push("image"+n);return e},dY=t=>{let e="float getPixel(int octave, int y, int x) {";for(let n=1;n<t.length;n++)e+=`\n\t  if (octave == ${n}) {\n\t    return getImage${n}(y, x);\n\t  }\n\t`;return e+="}",e},pY=(t,e,n,r)=>{const i=hY(t),s=dY(t);return{variableNames:[...i,"extrema","radial"],outputShape:[e.shape[0],n.shape[0],2],userCode:`\n\t  ${s}\n\n\t  void main() {\n\t    ivec3 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int radialIndex = coords[1];\n\t    int propertyIndex = coords[2];\n\n\t    int radialY = int(getRadial(radialIndex, 0));\n\t    int radialX = int(getRadial(radialIndex, 1));\n\t    float radialW = getRadial(radialIndex, 2);\n\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    int y = int(getExtrema(featureIndex, 2));\n\t    int x = int(getExtrema(featureIndex, 3));\n\n\t    int xp = x + radialX;\n\t    int yp = y + radialY;\n\n\t    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);\n\t    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);\n\n\t    if (propertyIndex == 0) {\n\t      // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0\n\t      \n\t      float angle = atan(dy, dx) + ${Math.PI};\n\t      float fbin = angle * 36. * ${r};\n\t      setOutput(fbin);\n\t      return;\n\t    }\n\n\t    if (propertyIndex == 1) {\n\t      float mag = sqrt(dx * dx + dy * dy);\n\t      float magnitude = radialW * mag;\n\t      setOutput(magnitude);\n\t      return;\n\t    }\n\t  }\n\n\t`}},fY=(t,e)=>({variableNames:["fbinMag"],outputShape:[t.shape[0],36],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int binIndex = coords[1];\n\n\t    float sum = 0.;\n\t    for (int i = 0; i < ${e.shape[0]}; i++) {\n\t      float fbin = getFbinMag(featureIndex, i, 0);\n\t      int bin = int(floor(fbin - 0.5));\n\t      int b1 = imod(bin + 36, 36);\n\t      int b2 = imod(bin + 1 + 36, 36);\n\n\t      if (b1 == binIndex || b2 == binIndex) {\n\t\tfloat magnitude = getFbinMag(featureIndex, i, 1);\n\t\tfloat w2 = fbin - float(bin) - 0.5;\n\t\tfloat w1 = w2 * -1. + 1.;\n\n\t\tif (b1 == binIndex) {\n\t\t  sum += w1 * magnitude;\n\t\t}\n\t\tif (b2 == binIndex) {\n\t\t  sum += w2 * magnitude;\n\t\t}\n\t      }\n\t    }\n\t    setOutput(sum);\n\t  }\n\t`}),mY=t=>null==t,gY=t=>{if("object"!=typeof t||null===t)return t;const e=Array.isArray(t)?[]:{};for(const n in t){const r=t[n];e[n]=gY(r)}return e},xY=class{debugMode;width;height;numOctaves;tensorCaches;kernelCaches;constructor(t,e,n=!1){this.width=t,this.height=e,this.debugMode=n;let r=0;for(;t>=8&&e>=8&&(t/=2,e/=2,r++,5!==r););this.numOctaves=r,this.tensorCaches={},this.kernelCaches={}}detectImageData(t){const e=new Uint8ClampedArray(4*t.length);for(const[n,r]of t.entries())e[4*n]=r,e[4*n+1]=r,e[4*n+2]=r,e[4*n+3]=255;const n=new ImageData(e,this.width,this.height);return this.detect(n)}_buildPyramidImage(t){const e=[];for(let n=0;n<this.numOctaves;n++){let r;r=0===n?this._applyFilter(t):this._downsampleBilinear(e[n-1][e[n-1].length-1]);const i=this._applyFilter(r);e.push([r,i])}return e}_buildDogPyramid(t){const e=[];for(let n=0;n<this.numOctaves;n++){const r=this._differenceImageBinomial(t[n][0],t[n][1]);e.push(r)}return e}_getExtremas(t){const e=[];for(let n=1;n<this.numOctaves-1;n++){const r=this._buildExtremas(t[n-1],t[n],t[n+1]);e.push(r)}return e}_getFeaturePoints(t,e,n){const r=[];for(const[i,s]of t.entries()){if(0==s[0])continue;const t=[];for(let n=0;n<e[i].length;n+=4){const r=e[i][n]*256**3+65536*e[i][n+1]+256*e[i][n+2]+e[i][n+3];t.push(r)}const a=s[1],o=s[2],l=s[3]*Math.pow(2,a)+Math.pow(2,a-1)-.5,u=o*Math.pow(2,a)+Math.pow(2,a-1)-.5,c=Math.pow(2,a);r.push({maxima:s[0]>0,x:l,y:u,scale:c,angle:n[i],descriptors:t})}return r}detect(t){let e={};const n=this._buildPyramidImage(t),r=this._buildDogPyramid(n),i=this._getExtremas(r),s=this._applyPrune(i),a=this._computeLocalization(s,r),o=this._computeOrientationHistograms(a,n),l=this._smoothHistograms(o),u=this._computeExtremaAngles(l),c=this._computeExtremaFreak(n,a,u),h=this._computeFreakDescriptors(c),d=a.arraySync(),p=u.arraySync(),f=h.arraySync();return this.debugMode&&(e={pyramidImages:n.map((t=>t.map((t=>t.arraySync())))),dogPyramidImages:r.map((t=>t?.arraySync()??null)),extremasResults:i.map((t=>t.arraySync())),extremaAngles:u.arraySync(),prunedExtremas:s,localizedExtremas:a.arraySync()}),n.forEach((t=>t.forEach((t=>t?.dispose())))),r.forEach((t=>t?.dispose())),i.forEach((t=>t.dispose())),a.dispose(),o.dispose(),l.dispose(),u.dispose(),c.dispose(),h.dispose(),{featurePoints:this._getFeaturePoints(d,f,p),debugExtra:e}}_compileAndRun(t,e){const n=jb().compileAndRun(t,e);return Bb().makeTensorFromTensorInfo(n)}_applyPrune(t){if(!this.kernelCaches.applyPrune){const e=t.map((t=>{return e=t.shape[0],n=t.shape[1],{variableNames:["extrema"],outputShape:[Math.floor(e/2),Math.floor(n/2)],userCode:"\n\t    void main() {\n\t      ivec2 coords = getOutputCoords();\n\t      int y = coords[0] * 2;\n\t      int x = coords[1] * 2;\n\n\t      float location = 0.0;\n\t      float values = getExtrema(y, x);\n\n\t      if (getExtrema(y+1, x) != 0.0) {\n\t        location = 1.0;\n\t\tvalues = getExtrema(y+1, x);\n\t      }\n\t      else if (getExtrema(y, x+1) != 0.0) {\n\t        location = 2.0;\n\t\tvalues = getExtrema(y, x+1);\n\t      }\n\t      else if (getExtrema(y+1, x+1) != 0.0) {\n\t        location = 3.0;\n\t\tvalues = getExtrema(y+1, x+1);\n\t      }\n\n\t      if (values < 0.0) {\n\t        setOutput(location * -1000.0 + values);\n\t      } else {\n\t        setOutput(location * 1000.0 + values);\n\t      }\n\t    }\n\t  "};var e,n}));this.kernelCaches.applyPrune={reductionKernels:e}}const e=[],n=[];for(let t=0;t<100;t++){n.push([]),e.push([]);for(let r=0;r<5;r++)n[t].push([0,0,0,0]),e[t].push(0)}Wb((()=>{const{reductionKernels:r}=this.kernelCaches.applyPrune;for(let i=0;i<t.length;i++){const s=r[i],a=this._compileAndRun(s,[t[i]]),o=i+1,l=a.arraySync(),u=a.shape[0],c=a.shape[1],h=2*c/10,d=2*u/10;for(let t=0;t<u;t++)for(let r=0;r<c;r++){const i=l[t][r];if(0===i)continue;const s=i%1e3,a=Math.floor(Math.abs(i)/1e3),u=2*r+(2===a||3===a?1:0),c=2*t+(1===a||3===a?1:0),p=Math.floor(u/h),f=10*Math.floor(c/d)+p,m=Math.abs(s);let g=5;for(;g>=1&&m>=e[f][g-1];)g--;if(!(g>=5)){for(let t=4;t>=g+1;t--)e[f][t]=e[f][t-1],n[f][t]=gY(n[f][t-1]);e[f][g]=m,n[f][g][0]=s,n[f][g][1]=o,n[f][g][2]=c,n[f][g][3]=u}}}}));const r=[];for(let t=0;t<100;t++)for(let e=0;e<5;e++)r.push(n[t][e]);return r}_applyFilter(t){const e=t.shape[0],n=t.shape[1],r="w"+n;return this.kernelCaches.applyFilter||(this.kernelCaches.applyFilter={}),this.kernelCaches.applyFilter[r]||(this.kernelCaches.applyFilter[r]=((t,e)=>[iY(t,e),sY(t,e)])(e,n)),Wb((()=>{const[e,n]=this.kernelCaches.applyFilter[r],i=this._compileAndRun(e,[t]);return this._compileAndRun(n,[i])}))}_buildExtremas(t,e,n){const r=e.shape[0],i=e.shape[1],s="w"+i;return this.kernelCaches.buildExtremas||(this.kernelCaches.buildExtremas={}),this.kernelCaches.buildExtremas[s]||(this.kernelCaches.buildExtremas[s]=((t,e)=>({variableNames:["image0","image1","image2"],outputShape:[t,e],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int y = coords[0];\n\t    int x = coords[1];\n\n\t    float value = getImage1(y, x);\n\n\t    // Step 1: find local maxima/minima\n\t    if (value * value < 9.) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    if (y < 7 || y > ${t-1-7}) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    if (x < 7 || x > ${e-1-7}) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    bool isMax = true;\n\t    bool isMin = true;\n\t    for (int dy = -1; dy <= 1; dy++) {\n\t      for (int dx = -1; dx <= 1; dx++) {\n\t        float value0 = getImage0(y+dy, x+dx);\n\t        float value1 = getImage1(y+dy, x+dx);\n\t        float value2 = getImage2(y+dy, x+dx);\n\n\t\tif (value < value0 || value < value1 || value < value2) {\n\t\t  isMax = false;\n\t\t}\n\t\tif (value > value0 || value > value1 || value > value2) {\n\t\t  isMin = false;\n\t\t}\n\t      }\n\t    }\n\n\t    if (!isMax && !isMin) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    // compute edge score and reject based on threshold\n\t    float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);\n\t    float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);\n\t    float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));\n\n\t    float det = (dxx * dyy) - (dxy * dxy);\n\n\t    if (abs(det) < 0.0001) { // determinant undefined. no solution\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    float edgeScore = (dxx + dyy) * (dxx + dyy) / det;\n\n\t    if (abs(edgeScore) >= 6.25 ) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    setOutput(getImage1(y,x));\n\t  }\n\t`}))(r,i)),Wb((()=>{const r=this.kernelCaches.buildExtremas[s];return t=this._downsampleBilinear(t),n=this._upsampleBilinear(n,e),this._compileAndRun(r,[t,e,n])}))}_computeLocalization(t,e){return this.kernelCaches.computeLocalization||(this.kernelCaches.computeLocalization=((t,e)=>{const n=hY(t),r=dY(t);return[{variableNames:[...n,"extrema"],outputShape:[e.length,3,3],userCode:`\n\t  ${r}\n\n\t  void main() {\n\t    ivec3 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    float score = getExtrema(featureIndex, 0);\n\t    if (score == 0.0) {\n\t      return;\n\t    }\n\n\t    int dy = coords[1]-1;\n\t    int dx = coords[2]-1;\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    int y = int(getExtrema(featureIndex, 2));\n\t    int x = int(getExtrema(featureIndex, 3));\n\t    setOutput(getPixel(octave, y+dy, x+dx));\n\t  }\n\t`}]})(e,t)),Wb((()=>{const n=this.kernelCaches.computeLocalization[0],r=kv(t,[t.length,t[0].length],"int32"),i=this._compileAndRun(n,[...e.slice(1),r]).arraySync(),s=[];for(let t=0;t<i.length;t++){s.push([]);for(let e=0;e<i[t].length;e++)s[t].push([])}const a=[];for(const e of t)a.push([e[0],e[1],e[2],e[3]]);for(const[t,e]of a.entries()){if(0===e[0])continue;const n=i[t],r=.5*(n[1][2]-n[1][0]),s=.5*(n[2][1]-n[0][1]),a=n[1][2]+n[1][0]-2*n[1][1],o=n[2][1]+n[0][1]-2*n[1][1],l=.25*(n[0][0]+n[2][2]-n[0][2]-n[2][0]),u=a*o-l**2,c=(o*-r+-l*-s)/u,h=(-l*-r+a*-s)/u,d=e[2]+h,p=e[3]+c;Math.abs(u)<1e-4||(e[2]=d,e[3]=p)}return kv(a,[a.length,a[0].length],"float32")}))}_computeOrientationHistograms(t,e){const n=[];for(let t=1;t<e.length;t++)n.push(e[t][1]);this.tensorCaches.orientationHistograms||Wb((()=>{const t=Math.ceil(4.5),e=[];for(let n=-t;n<=t;n++)for(let r=-t;r<=t;r++){const t=Math.sqrt(r**2+n**2);if(t>4.5)continue;const i=Math.exp(-.05555555555555555*t**2);e.push([r,n,i])}this.tensorCaches.orientationHistograms={radialPropertiesT:Gb(kv(e,[e.length,3]))}}));const{radialPropertiesT:r}=this.tensorCaches.orientationHistograms;return this.kernelCaches.computeOrientationHistograms||(this.kernelCaches.computeOrientationHistograms=((t,e,n,r)=>[pY(t,e,n,r),fY(e,n)])(e,t,r,cY)),Wb((()=>{const[e,i]=this.kernelCaches.computeOrientationHistograms,s=this._compileAndRun(e,[...n,t,r]);return this._compileAndRun(i,[s])}))}_computeExtremaAngles(t){return this.kernelCaches.computeExtremaAngles||(this.kernelCaches.computeExtremaAngles=(t=>({variableNames:["histogram"],outputShape:[t.shape[0]],userCode:`\n\t  void main() {\n\t    int featureIndex = getOutputCoords();\n\n\t    int maxIndex = 0;\n\t    for (int i = 1; i < 36; i++) {\n\t      if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {\n\t\tmaxIndex = i;\n\t      }\n\t    }\n\n\t    int prev = imod(maxIndex - 1 + 36, 36);\n\t    int next = imod(maxIndex + 1, 36);\n\n\t    /**\n\t     * Fit a quatratic to 3 points. The system of equations is:\n\t     *\n\t     * y0 = A*x0^2 + B*x0 + C\n\t     * y1 = A*x1^2 + B*x1 + C\n\t     * y2 = A*x2^2 + B*x2 + C\n\t     *\n\t     * This system of equations is solved for A,B,C.\n\t     */\n\t    float p10 = float(maxIndex - 1);\n\t    float p11 = getHistogram(featureIndex, prev); \n\t    float p20 = float(maxIndex);\n\t    float p21 = getHistogram(featureIndex, maxIndex); \n\t    float p30 = float(maxIndex + 1);\n\t    float p31 = getHistogram(featureIndex, next); \n\n\t    float d1 = (p30-p20)*(p30-p10);\n\t    float d2 = (p10-p20)*(p30-p10);\n\t    float d3 = p10-p20;\n\n\t    // If any of the denominators are zero then, just use maxIndex.\n            float fbin = float(maxIndex);\n\t    if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {\n\t      float a = p10*p10;\n\t      float b = p20*p20;\n\n\t      // Solve for the coefficients A,B,C\n\t      float A = ((p31-p21)/d1)-((p11-p21)/d2);\n\t      float B = ((p11-p21)+(A*(b-a)))/d3;\n\t      float C = p11-(A*a)-(B*p10);\n\t      fbin = -B / (2. * A);\n\t    }\n\n\t    float an = 2.0 *${Math.PI} * (fbin + 0.5) / 36. - ${Math.PI};\n\t    setOutput(an);\n\t  }\n\t`}))(t)),Wb((()=>{const e=this.kernelCaches.computeExtremaAngles;return this._compileAndRun(e,[t])}))}_computeExtremaFreak(t,e,n){this.tensorCaches._computeExtremaFreak||Wb((()=>{const t=kv(lY);this.tensorCaches._computeExtremaFreak={freakPointsT:Gb(t)}}));const{freakPointsT:r}=this.tensorCaches._computeExtremaFreak,i=[];for(let e=1;e<t.length;e++)i.push(t[e][1]);return this.kernelCaches._computeExtremaFreak||(this.kernelCaches._computeExtremaFreak=((t,e)=>{const n=hY(t),r=dY(t);return[{variableNames:[...n,"extrema","angles","freakPoints"],outputShape:[e.shape[0],lY.length],userCode:`\n\t  ${r}\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int freakIndex = coords[1];\n\n\t    float freakSigma = getFreakPoints(freakIndex, 0);\n\t    float freakX = getFreakPoints(freakIndex, 1);\n\t    float freakY = getFreakPoints(freakIndex, 2);\n\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    float inputY = getExtrema(featureIndex, 2);\n\t    float inputX = getExtrema(featureIndex, 3);\n\t    float inputAngle = getAngles(featureIndex);\n            float cos = 7. * cos(inputAngle);\n            float sin = 7. * sin(inputAngle);\n\n\t    float yp = inputY + freakX * sin + freakY * cos;\n\t    float xp = inputX + freakX * cos + freakY * -sin;\n\n\t    int x0 = int(floor(xp));\n\t    int x1 = x0 + 1;\n\t    int y0 = int(floor(yp));\n\t    int y1 = y0 + 1;\n\n\t    float f1 = getPixel(octave, y0, x0);\n\t    float f2 = getPixel(octave, y0, x1);\n\t    float f3 = getPixel(octave, y1, x0);\n\t    float f4 = getPixel(octave, y1, x1);\n\n\t    float x1f = float(x1);\n\t    float y1f = float(y1);\n\t    float x0f = float(x0);\n\t    float y0f = float(y0);\n\n\t    // ratio for interpolation between four neighbouring points\n\t    float value = (x1f - xp) * (y1f - yp) * f1\n\t\t\t+ (xp - x0f) * (y1f - yp) * f2\n\t\t\t+ (x1f - xp) * (yp - y0f) * f3\n\t\t\t+ (xp - x0f) * (yp - y0f) * f4;\n\n\t    setOutput(value);\n\t  }\n\t`}]})(t,e)),Wb((()=>{const[t]=this.kernelCaches._computeExtremaFreak;return this._compileAndRun(t,[...i,e,n,r])}))}_computeFreakDescriptors(t){if(!this.tensorCaches.computeFreakDescriptors){const e=[],n=[];for(let r=0;r<t.shape[1];r++)for(let i=r+1;i<t.shape[1];i++)e.push(r),n.push(i);const r=kv(e,[e.length]).cast("int32"),i=kv(n,[n.length]).cast("int32");this.tensorCaches.computeFreakDescriptors={positionT:Gb(KS([r,i],1))}}const{positionT:e}=this.tensorCaches.computeFreakDescriptors,n=Math.ceil(uY/8);return this.kernelCaches.computeFreakDescriptors||(this.kernelCaches.computeFreakDescriptors=((t,e,n)=>[{variableNames:["freak","p"],outputShape:[t.shape[0],e],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int descIndex = coords[1] * 8;\n\n\t    int sum = 0;\n\t    for (int i = 0; i < 8; i++) {\n\t      if (descIndex + i >= ${n}) {\n\t\tcontinue;\n\t      }\n\n\t      int p1 = int(getP(descIndex + i, 0));\n\t      int p2 = int(getP(descIndex + i, 1));\n\n\t      float v1 = getFreak(featureIndex, p1);\n\t      float v2 = getFreak(featureIndex, p2);\n\n\t      if (v1 < v2 + 0.01) {\n\t        sum += int(pow(2.0, float(7 - i)));\n\t      }\n\t    }\n\t    setOutput(float(sum));\n\t  }\n\t`}])(t,n,uY)),Wb((()=>{const[n]=this.kernelCaches.computeFreakDescriptors;return this._runWebGLProgram(n,[t,e],"int32")}))}_differenceImageBinomial(t,e){return Wb((()=>t.sub(e)))}_upsampleBilinear(t,e){const n="w"+t.shape[1];return this.kernelCaches.upsampleBilinear||(this.kernelCaches.upsampleBilinear={}),this.kernelCaches.upsampleBilinear[n]||(this.kernelCaches.upsampleBilinear[n]=(r=e.shape[0],i=e.shape[1],{variableNames:["p"],outputShape:[r,i],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int j = coords[0];\n\t    int i = coords[1];\n\n\t    float sj = 0.5 * float(j) - 0.25; \n\t    float si = 0.5 * float(i) - 0.25;\n\n\t    float sj0 = floor(sj);\n\t    float sj1 = ceil(sj);\n\t    float si0 = floor(si);\n\t    float si1 = ceil(si);\n\n\t    int sj0I = int(sj0);\n\t    int sj1I = int(sj1);\n\t    int si0I = int(si0);\n\t    int si1I = int(si1);\n\n\t    float sum = 0.0;\n\t    sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);\n\t    sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);\n\t    sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);\n\t    sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);\n\t    setOutput(sum);\n\t  }\n\t"})),Wb((()=>{const e=this.kernelCaches.upsampleBilinear[n];return this._compileAndRun(e,[t])}));var r,i}_downsampleBilinear(t){const e=t.shape[0],n=t.shape[1],r="w"+n;return this.kernelCaches.downsampleBilinear||(this.kernelCaches.downsampleBilinear={}),this.kernelCaches.downsampleBilinear[r]||(this.kernelCaches.downsampleBilinear[r]=((t,e)=>({variableNames:["p"],outputShape:[Math.floor(t/2),Math.floor(e/2)],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int y = coords[0] * 2;\n\t    int x = coords[1] * 2;\n\n\t    float sum = getP(y, x) * 0.25;\n\t    sum += getP(y+1,x) * 0.25; \n\t    sum += getP(y, x+1) * 0.25; \n\t    sum += getP(y+1,x+1) * 0.25;\n\t    setOutput(sum);\n\t  }\n\t"}))(e,n)),Wb((()=>{const e=this.kernelCaches.downsampleBilinear[r];return this._compileAndRun(e,[t])}))}_smoothHistograms(t){return this.kernelCaches.smoothHistograms||(this.kernelCaches.smoothHistograms=(t=>({variableNames:["histogram"],outputShape:[t.shape[0],36],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int featureIndex = coords[0];\n\t    int binIndex = coords[1];\n\n\t    int prevBin = imod(binIndex - 1 + 36, 36);\n\t    int nextBin = imod(binIndex + 1, 36);\n\n            float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);\n\n\t    setOutput(result);\n\t  }\n\t"}))(t)),Wb((()=>{const e=this.kernelCaches.smoothHistograms;for(let n=0;n<5;n++)t=this._compileAndRun(e,[t]);return t}))}_runWebGLProgram(t,e,n){const r=jb().runWebGLProgram(t,e,n);return Bb().makeTensorFromTensorInfo(r)}};var yY,vY,bY,wY=4294967295;function SY(t,e,n){var r=Math.floor(n/4294967296),i=n;t.setUint32(e,r),t.setUint32(e+4,i)}function _Y(t,e){return 4294967296*t.getInt32(e)+t.getUint32(e+4)}var IY=("undefined"==typeof process||"never"!==(null===(yY=null===process||void 0===process?void 0:process.env)||void 0===yY?void 0:yY.TEXT_ENCODING))&&"undefined"!=typeof TextEncoder&&"undefined"!=typeof TextDecoder;function kY(t){for(var e=t.length,n=0,r=0;r<e;){var i=t.charCodeAt(r++);if(0!=(4294967168&i))if(0==(4294965248&i))n+=2;else{if(i>=55296&&i<=56319&&r<e){var s=t.charCodeAt(r);56320==(64512&s)&&(++r,i=((1023&i)<<10)+(1023&s)+65536)}n+=0==(4294901760&i)?3:4}else n++}return n}var MY=IY?new TextEncoder:void 0,TY=IY?"undefined"!=typeof process&&"force"!==(null===(vY=null===process||void 0===process?void 0:process.env)||void 0===vY?void 0:vY.TEXT_ENCODING)?200:0:wY,CY=(null==MY?void 0:MY.encodeInto)?function(t,e,n){MY.encodeInto(t,e.subarray(n))}:function(t,e,n){e.set(MY.encode(t),n)},EY=4096;function AY(t,e,n){for(var r=e,i=r+n,s=[],a="";r<i;){var o=t[r++];if(0==(128&o))s.push(o);else if(192==(224&o)){var l=63&t[r++];s.push((31&o)<<6|l)}else if(224==(240&o)){l=63&t[r++];var u=63&t[r++];s.push((31&o)<<12|l<<6|u)}else if(240==(248&o)){var c=(7&o)<<18|(l=63&t[r++])<<12|(u=63&t[r++])<<6|63&t[r++];c>65535&&(c-=65536,s.push(c>>>10&1023|55296),c=56320|1023&c),s.push(c)}else s.push(o);s.length>=EY&&(a+=String.fromCharCode.apply(String,s),s.length=0)}return s.length>0&&(a+=String.fromCharCode.apply(String,s)),a}var NY,RY=IY?new TextDecoder:null,DY=IY?"undefined"!=typeof process&&"force"!==(null===(bY=null===process||void 0===process?void 0:process.env)||void 0===bY?void 0:bY.TEXT_DECODER)?200:0:wY,LY=function(t,e){this.type=t,this.data=e},FY=(NY=function(t,e){return NY=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])},NY(t,e)},function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}NY(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}),$Y=function(t){function e(n){var r=t.call(this,n)||this,i=Object.create(e.prototype);return Object.setPrototypeOf(r,i),Object.defineProperty(r,"name",{configurable:!0,enumerable:!1,value:e.name}),r}return FY(e,t),e}(Error),PY={type:-1,encode:function(t){var e,n,r,i;return t instanceof Date?function(t){var e,n=t.sec,r=t.nsec;if(n>=0&&r>=0&&n<=17179869183){if(0===r&&n<=4294967295){var i=new Uint8Array(4);return(e=new DataView(i.buffer)).setUint32(0,n),i}var s=n/4294967296,a=4294967295&n;return i=new Uint8Array(8),(e=new DataView(i.buffer)).setUint32(0,r<<2|3&s),e.setUint32(4,a),i}return i=new Uint8Array(12),(e=new DataView(i.buffer)).setUint32(0,r),SY(e,4,n),i}((r=1e6*((e=t.getTime())-1e3*(n=Math.floor(e/1e3))),{sec:n+(i=Math.floor(r/1e9)),nsec:r-1e9*i})):null},decode:function(t){var e=function(t){var e=new DataView(t.buffer,t.byteOffset,t.byteLength);switch(t.byteLength){case 4:return{sec:e.getUint32(0),nsec:0};case 8:var n=e.getUint32(0);return{sec:4294967296*(3&n)+e.getUint32(4),nsec:n>>>2};case 12:return{sec:_Y(e,4),nsec:e.getUint32(0)};default:throw new $Y("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(t.length))}}(t);return new Date(1e3*e.sec+e.nsec/1e6)}},OY=function(){function t(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(PY)}return t.prototype.register=function(t){var e=t.type,n=t.encode,r=t.decode;if(e>=0)this.encoders[e]=n,this.decoders[e]=r;else{var i=1+e;this.builtInEncoders[i]=n,this.builtInDecoders[i]=r}},t.prototype.tryToEncode=function(t,e){for(var n=0;n<this.builtInEncoders.length;n++)if(null!=(r=this.builtInEncoders[n])&&null!=(i=r(t,e)))return new LY(-1-n,i);for(n=0;n<this.encoders.length;n++){var r,i;if(null!=(r=this.encoders[n])&&null!=(i=r(t,e)))return new LY(n,i)}return t instanceof LY?t:null},t.prototype.decode=function(t,e,n){var r=e<0?this.builtInDecoders[-1-e]:this.decoders[e];return r?r(t,e,n):new LY(e,t)},t.defaultCodec=new t,t}();function zY(t){return t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer?new Uint8Array(t):Uint8Array.from(t)}var BY=100,UY=2048,WY=function(){function t(t,e,n,r,i,s,a,o){void 0===t&&(t=OY.defaultCodec),void 0===e&&(e=void 0),void 0===n&&(n=BY),void 0===r&&(r=UY),void 0===i&&(i=!1),void 0===s&&(s=!1),void 0===a&&(a=!1),void 0===o&&(o=!1),this.extensionCodec=t,this.context=e,this.maxDepth=n,this.initialBufferSize=r,this.sortKeys=i,this.forceFloat32=s,this.ignoreUndefined=a,this.forceIntegerToFloat=o,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return t.prototype.reinitializeState=function(){this.pos=0},t.prototype.encodeSharedRef=function(t){return this.reinitializeState(),this.doEncode(t,1),this.bytes.subarray(0,this.pos)},t.prototype.encode=function(t){return this.reinitializeState(),this.doEncode(t,1),this.bytes.slice(0,this.pos)},t.prototype.doEncode=function(t,e){if(e>this.maxDepth)throw new Error("Too deep objects in depth ".concat(e));null==t?this.encodeNil():"boolean"==typeof t?this.encodeBoolean(t):"number"==typeof t?this.encodeNumber(t):"string"==typeof t?this.encodeString(t):this.encodeObject(t,e)},t.prototype.ensureBufferSizeToWrite=function(t){var e=this.pos+t;this.view.byteLength<e&&this.resizeBuffer(2*e)},t.prototype.resizeBuffer=function(t){var e=new ArrayBuffer(t),n=new Uint8Array(e),r=new DataView(e);n.set(this.bytes),this.view=r,this.bytes=n},t.prototype.encodeNil=function(){this.writeU8(192)},t.prototype.encodeBoolean=function(t){!1===t?this.writeU8(194):this.writeU8(195)},t.prototype.encodeNumber=function(t){Number.isSafeInteger(t)&&!this.forceIntegerToFloat?t>=0?t<128?this.writeU8(t):t<256?(this.writeU8(204),this.writeU8(t)):t<65536?(this.writeU8(205),this.writeU16(t)):t<4294967296?(this.writeU8(206),this.writeU32(t)):(this.writeU8(207),this.writeU64(t)):t>=-32?this.writeU8(224|t+32):t>=-128?(this.writeU8(208),this.writeI8(t)):t>=-32768?(this.writeU8(209),this.writeI16(t)):t>=-2147483648?(this.writeU8(210),this.writeI32(t)):(this.writeU8(211),this.writeI64(t)):this.forceFloat32?(this.writeU8(202),this.writeF32(t)):(this.writeU8(203),this.writeF64(t))},t.prototype.writeStringHeader=function(t){if(t<32)this.writeU8(160+t);else if(t<256)this.writeU8(217),this.writeU8(t);else if(t<65536)this.writeU8(218),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too long string: ".concat(t," bytes in UTF-8"));this.writeU8(219),this.writeU32(t)}},t.prototype.encodeString=function(t){if(t.length>TY){var e=kY(t);this.ensureBufferSizeToWrite(5+e),this.writeStringHeader(e),CY(t,this.bytes,this.pos),this.pos+=e}else e=kY(t),this.ensureBufferSizeToWrite(5+e),this.writeStringHeader(e),function(t,e,n){for(var r=t.length,i=n,s=0;s<r;){var a=t.charCodeAt(s++);if(0!=(4294967168&a)){if(0==(4294965248&a))e[i++]=a>>6&31|192;else{if(a>=55296&&a<=56319&&s<r){var o=t.charCodeAt(s);56320==(64512&o)&&(++s,a=((1023&a)<<10)+(1023&o)+65536)}0==(4294901760&a)?(e[i++]=a>>12&15|224,e[i++]=a>>6&63|128):(e[i++]=a>>18&7|240,e[i++]=a>>12&63|128,e[i++]=a>>6&63|128)}e[i++]=63&a|128}else e[i++]=a}}(t,this.bytes,this.pos),this.pos+=e},t.prototype.encodeObject=function(t,e){var n=this.extensionCodec.tryToEncode(t,this.context);if(null!=n)this.encodeExtension(n);else if(Array.isArray(t))this.encodeArray(t,e);else if(ArrayBuffer.isView(t))this.encodeBinary(t);else{if("object"!=typeof t)throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(t)));this.encodeMap(t,e)}},t.prototype.encodeBinary=function(t){var e=t.byteLength;if(e<256)this.writeU8(196),this.writeU8(e);else if(e<65536)this.writeU8(197),this.writeU16(e);else{if(!(e<4294967296))throw new Error("Too large binary: ".concat(e));this.writeU8(198),this.writeU32(e)}var n=zY(t);this.writeU8a(n)},t.prototype.encodeArray=function(t,e){var n=t.length;if(n<16)this.writeU8(144+n);else if(n<65536)this.writeU8(220),this.writeU16(n);else{if(!(n<4294967296))throw new Error("Too large array: ".concat(n));this.writeU8(221),this.writeU32(n)}for(var r=0,i=t;r<i.length;r++){var s=i[r];this.doEncode(s,e+1)}},t.prototype.countWithoutUndefined=function(t,e){for(var n=0,r=0,i=e;r<i.length;r++)void 0!==t[i[r]]&&n++;return n},t.prototype.encodeMap=function(t,e){var n=Object.keys(t);this.sortKeys&&n.sort();var r=this.ignoreUndefined?this.countWithoutUndefined(t,n):n.length;if(r<16)this.writeU8(128+r);else if(r<65536)this.writeU8(222),this.writeU16(r);else{if(!(r<4294967296))throw new Error("Too large map object: ".concat(r));this.writeU8(223),this.writeU32(r)}for(var i=0,s=n;i<s.length;i++){var a=s[i],o=t[a];this.ignoreUndefined&&void 0===o||(this.encodeString(a),this.doEncode(o,e+1))}},t.prototype.encodeExtension=function(t){var e=t.data.length;if(1===e)this.writeU8(212);else if(2===e)this.writeU8(213);else if(4===e)this.writeU8(214);else if(8===e)this.writeU8(215);else if(16===e)this.writeU8(216);else if(e<256)this.writeU8(199),this.writeU8(e);else if(e<65536)this.writeU8(200),this.writeU16(e);else{if(!(e<4294967296))throw new Error("Too large extension object: ".concat(e));this.writeU8(201),this.writeU32(e)}this.writeI8(t.type),this.writeU8a(t.data)},t.prototype.writeU8=function(t){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,t),this.pos++},t.prototype.writeU8a=function(t){var e=t.length;this.ensureBufferSizeToWrite(e),this.bytes.set(t,this.pos),this.pos+=e},t.prototype.writeI8=function(t){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,t),this.pos++},t.prototype.writeU16=function(t){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,t),this.pos+=2},t.prototype.writeI16=function(t){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,t),this.pos+=2},t.prototype.writeU32=function(t){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,t),this.pos+=4},t.prototype.writeI32=function(t){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,t),this.pos+=4},t.prototype.writeF32=function(t){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,t),this.pos+=4},t.prototype.writeF64=function(t){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,t),this.pos+=8},t.prototype.writeU64=function(t){this.ensureBufferSizeToWrite(8),function(t,e,n){var r=n/4294967296,i=n;t.setUint32(e,r),t.setUint32(e+4,i)}(this.view,this.pos,t),this.pos+=8},t.prototype.writeI64=function(t){this.ensureBufferSizeToWrite(8),SY(this.view,this.pos,t),this.pos+=8},t}(),VY={};function GY(t){return"".concat(t<0?"-":"","0x").concat(Math.abs(t).toString(16).padStart(2,"0"))}var HY=16,jY=16,qY=function(){function t(t,e){void 0===t&&(t=HY),void 0===e&&(e=jY),this.maxKeyLength=t,this.maxLengthPerKey=e,this.hit=0,this.miss=0,this.caches=[];for(var n=0;n<this.maxKeyLength;n++)this.caches.push([])}return t.prototype.canBeCached=function(t){return t>0&&t<=this.maxKeyLength},t.prototype.find=function(t,e,n){t:for(var r=0,i=this.caches[n-1];r<i.length;r++){for(var s=i[r],a=s.bytes,o=0;o<n;o++)if(a[o]!==t[e+o])continue t;return s.str}return null},t.prototype.store=function(t,e){var n=this.caches[t.length-1],r={bytes:t,str:e};n.length>=this.maxLengthPerKey?n[Math.random()*n.length|0]=r:n.push(r)},t.prototype.decode=function(t,e,n){var r=this.find(t,e,n);if(null!=r)return this.hit++,r;this.miss++;var i=AY(t,e,n),s=Uint8Array.prototype.slice.call(t,e,e+n);return this.store(s,i),i},t}(),XY=function(t,e){var n,r,i,s,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(s){return function(o){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(i=2&s[0]?r.return:s[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,s[1])).done)return i;switch(r=0,i&&(s=[2&s[0],i.value]),s[0]){case 0:case 1:i=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((i=(i=a.trys).length>0&&i[i.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!i||s[1]>i[0]&&s[1]<i[3])){a.label=s[1];break}if(6===s[0]&&a.label<i[1]){a.label=i[1],i=s;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(s);break}i[2]&&a.ops.pop(),a.trys.pop();continue}s=e.call(t,a)}catch(t){s=[6,t],r=0}finally{n=i=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,o])}}},KY=function(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t="function"==typeof __values?__values(t):t[Symbol.iterator](),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(n){e[n]=t[n]&&function(e){return new Promise((function(r,i){!function(t,e,n,r){Promise.resolve(r).then((function(e){t({value:e,done:n})}),e)}(r,i,(e=t[n](e)).done,e.value)}))}}},YY=function(t){return this instanceof YY?(this.v=t,this):new YY(t)},ZY=function(t,e,n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,i=n.apply(t,e||[]),s=[];return r={},a("next"),a("throw"),a("return"),r[Symbol.asyncIterator]=function(){return this},r;function a(t){i[t]&&(r[t]=function(e){return new Promise((function(n,r){s.push([t,e,n,r])>1||o(t,e)}))})}function o(t,e){try{(n=i[t](e)).value instanceof YY?Promise.resolve(n.value.v).then(l,u):c(s[0][2],n)}catch(t){c(s[0][3],t)}var n}function l(t){o("next",t)}function u(t){o("throw",t)}function c(t,e){t(e),s.shift(),s.length&&o(s[0][0],s[0][1])}},JY=-1,QY=new DataView(new ArrayBuffer(0)),tZ=new Uint8Array(QY.buffer),eZ=function(){try{QY.getInt8(0)}catch(t){return t.constructor}throw new Error("never reached")}(),nZ=new eZ("Insufficient data"),rZ=new qY,iZ=function(){function t(t,e,n,r,i,s,a,o){void 0===t&&(t=OY.defaultCodec),void 0===e&&(e=void 0),void 0===n&&(n=wY),void 0===r&&(r=wY),void 0===i&&(i=wY),void 0===s&&(s=wY),void 0===a&&(a=wY),void 0===o&&(o=rZ),this.extensionCodec=t,this.context=e,this.maxStrLength=n,this.maxBinLength=r,this.maxArrayLength=i,this.maxMapLength=s,this.maxExtLength=a,this.keyDecoder=o,this.totalPos=0,this.pos=0,this.view=QY,this.bytes=tZ,this.headByte=JY,this.stack=[]}return t.prototype.reinitializeState=function(){this.totalPos=0,this.headByte=JY,this.stack.length=0},t.prototype.setBuffer=function(t){this.bytes=zY(t),this.view=function(t){if(t instanceof ArrayBuffer)return new DataView(t);var e=zY(t);return new DataView(e.buffer,e.byteOffset,e.byteLength)}(this.bytes),this.pos=0},t.prototype.appendBuffer=function(t){if(this.headByte!==JY||this.hasRemaining(1)){var e=this.bytes.subarray(this.pos),n=zY(t),r=new Uint8Array(e.length+n.length);r.set(e),r.set(n,e.length),this.setBuffer(r)}else this.setBuffer(t)},t.prototype.hasRemaining=function(t){return this.view.byteLength-this.pos>=t},t.prototype.createExtraByteError=function(t){var e=this.view,n=this.pos;return new RangeError("Extra ".concat(e.byteLength-n," of ").concat(e.byteLength," byte(s) found at buffer[").concat(t,"]"))},t.prototype.decode=function(t){this.reinitializeState(),this.setBuffer(t);var e=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return e},t.prototype.decodeMulti=function(t){return XY(this,(function(e){switch(e.label){case 0:this.reinitializeState(),this.setBuffer(t),e.label=1;case 1:return this.hasRemaining(1)?[4,this.doDecodeSync()]:[3,3];case 2:return e.sent(),[3,1];case 3:return[2]}}))},t.prototype.decodeAsync=function(t){var e,n,r,i,s,a,o,l;return s=this,a=void 0,l=function(){var s,a,o,l,u,c,h,d;return XY(this,(function(p){switch(p.label){case 0:s=!1,p.label=1;case 1:p.trys.push([1,6,7,12]),e=KY(t),p.label=2;case 2:return[4,e.next()];case 3:if((n=p.sent()).done)return[3,5];if(o=n.value,s)throw this.createExtraByteError(this.totalPos);this.appendBuffer(o);try{a=this.doDecodeSync(),s=!0}catch(t){if(!(t instanceof eZ))throw t}this.totalPos+=this.pos,p.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return l=p.sent(),r={error:l},[3,12];case 7:return p.trys.push([7,,10,11]),n&&!n.done&&(i=e.return)?[4,i.call(e)]:[3,9];case 8:p.sent(),p.label=9;case 9:return[3,11];case 10:if(r)throw r.error;return[7];case 11:return[7];case 12:if(s){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return[2,a]}throw c=(u=this).headByte,h=u.pos,d=u.totalPos,new RangeError("Insufficient data in parsing ".concat(GY(c)," at ").concat(d," (").concat(h," in the current buffer)"))}}))},new((o=void 0)||(o=Promise))((function(t,e){function n(t){try{i(l.next(t))}catch(t){e(t)}}function r(t){try{i(l.throw(t))}catch(t){e(t)}}function i(e){var i;e.done?t(e.value):(i=e.value,i instanceof o?i:new o((function(t){t(i)}))).then(n,r)}i((l=l.apply(s,a||[])).next())}))},t.prototype.decodeArrayStream=function(t){return this.decodeMultiAsync(t,!0)},t.prototype.decodeStream=function(t){return this.decodeMultiAsync(t,!1)},t.prototype.decodeMultiAsync=function(t,e){return ZY(this,arguments,(function(){var n,r,i,s,a,o,l,u,c;return XY(this,(function(h){switch(h.label){case 0:n=e,r=-1,h.label=1;case 1:h.trys.push([1,13,14,19]),i=KY(t),h.label=2;case 2:return[4,YY(i.next())];case 3:if((s=h.sent()).done)return[3,12];if(a=s.value,e&&0===r)throw this.createExtraByteError(this.totalPos);this.appendBuffer(a),n&&(r=this.readArraySize(),n=!1,this.complete()),h.label=4;case 4:h.trys.push([4,9,,10]),h.label=5;case 5:return[4,YY(this.doDecodeSync())];case 6:return[4,h.sent()];case 7:return h.sent(),0==--r?[3,8]:[3,5];case 8:return[3,10];case 9:if(!((o=h.sent())instanceof eZ))throw o;return[3,10];case 10:this.totalPos+=this.pos,h.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return l=h.sent(),u={error:l},[3,19];case 14:return h.trys.push([14,,17,18]),s&&!s.done&&(c=i.return)?[4,YY(c.call(i))]:[3,16];case 15:h.sent(),h.label=16;case 16:return[3,18];case 17:if(u)throw u.error;return[7];case 18:return[7];case 19:return[2]}}))}))},t.prototype.doDecodeSync=function(){t:for(;;){var t=this.readHeadByte(),e=void 0;if(t>=224)e=t-256;else if(t<192)if(t<128)e=t;else if(t<144){if(0!=(r=t-128)){this.pushMapState(r),this.complete();continue t}e={}}else if(t<160){if(0!=(r=t-144)){this.pushArrayState(r),this.complete();continue t}e=[]}else{var n=t-160;e=this.decodeUtf8String(n,0)}else if(192===t)e=null;else if(194===t)e=!1;else if(195===t)e=!0;else if(202===t)e=this.readF32();else if(203===t)e=this.readF64();else if(204===t)e=this.readU8();else if(205===t)e=this.readU16();else if(206===t)e=this.readU32();else if(207===t)e=this.readU64();else if(208===t)e=this.readI8();else if(209===t)e=this.readI16();else if(210===t)e=this.readI32();else if(211===t)e=this.readI64();else if(217===t)n=this.lookU8(),e=this.decodeUtf8String(n,1);else if(218===t)n=this.lookU16(),e=this.decodeUtf8String(n,2);else if(219===t)n=this.lookU32(),e=this.decodeUtf8String(n,4);else if(220===t){if(0!==(r=this.readU16())){this.pushArrayState(r),this.complete();continue t}e=[]}else if(221===t){if(0!==(r=this.readU32())){this.pushArrayState(r),this.complete();continue t}e=[]}else if(222===t){if(0!==(r=this.readU16())){this.pushMapState(r),this.complete();continue t}e={}}else if(223===t){if(0!==(r=this.readU32())){this.pushMapState(r),this.complete();continue t}e={}}else if(196===t){var r=this.lookU8();e=this.decodeBinary(r,1)}else if(197===t)r=this.lookU16(),e=this.decodeBinary(r,2);else if(198===t)r=this.lookU32(),e=this.decodeBinary(r,4);else if(212===t)e=this.decodeExtension(1,0);else if(213===t)e=this.decodeExtension(2,0);else if(214===t)e=this.decodeExtension(4,0);else if(215===t)e=this.decodeExtension(8,0);else if(216===t)e=this.decodeExtension(16,0);else if(199===t)r=this.lookU8(),e=this.decodeExtension(r,1);else if(200===t)r=this.lookU16(),e=this.decodeExtension(r,2);else{if(201!==t)throw new $Y("Unrecognized type byte: ".concat(GY(t)));r=this.lookU32(),e=this.decodeExtension(r,4)}this.complete();for(var i=this.stack;i.length>0;){var s=i[i.length-1];if(0===s.type){if(s.array[s.position]=e,s.position++,s.position!==s.size)continue t;i.pop(),e=s.array}else{if(1===s.type){if(void 0,"string"!=(a=typeof e)&&"number"!==a)throw new $Y("The type of key must be string or number but "+typeof e);if("__proto__"===e)throw new $Y("The key __proto__ is not allowed");s.key=e,s.type=2;continue t}if(s.map[s.key]=e,s.readCount++,s.readCount!==s.size){s.key=null,s.type=1;continue t}i.pop(),e=s.map}}return e}var a},t.prototype.readHeadByte=function(){return this.headByte===JY&&(this.headByte=this.readU8()),this.headByte},t.prototype.complete=function(){this.headByte=JY},t.prototype.readArraySize=function(){var t=this.readHeadByte();switch(t){case 220:return this.readU16();case 221:return this.readU32();default:if(t<160)return t-144;throw new $Y("Unrecognized array type byte: ".concat(GY(t)))}},t.prototype.pushMapState=function(t){if(t>this.maxMapLength)throw new $Y("Max length exceeded: map length (".concat(t,") > maxMapLengthLength (").concat(this.maxMapLength,")"));this.stack.push({type:1,size:t,key:null,readCount:0,map:{}})},t.prototype.pushArrayState=function(t){if(t>this.maxArrayLength)throw new $Y("Max length exceeded: array length (".concat(t,") > maxArrayLength (").concat(this.maxArrayLength,")"));this.stack.push({type:0,size:t,array:new Array(t),position:0})},t.prototype.decodeUtf8String=function(t,e){var n;if(t>this.maxStrLength)throw new $Y("Max length exceeded: UTF-8 byte length (".concat(t,") > maxStrLength (").concat(this.maxStrLength,")"));if(this.bytes.byteLength<this.pos+e+t)throw nZ;var r,i=this.pos+e;return r=this.stateIsMapKey()&&(null===(n=this.keyDecoder)||void 0===n?void 0:n.canBeCached(t))?this.keyDecoder.decode(this.bytes,i,t):t>DY?function(t,e,n){var r=t.subarray(e,e+n);return RY.decode(r)}(this.bytes,i,t):AY(this.bytes,i,t),this.pos+=e+t,r},t.prototype.stateIsMapKey=function(){return this.stack.length>0&&1===this.stack[this.stack.length-1].type},t.prototype.decodeBinary=function(t,e){if(t>this.maxBinLength)throw new $Y("Max length exceeded: bin length (".concat(t,") > maxBinLength (").concat(this.maxBinLength,")"));if(!this.hasRemaining(t+e))throw nZ;var n=this.pos+e,r=this.bytes.subarray(n,n+t);return this.pos+=e+t,r},t.prototype.decodeExtension=function(t,e){if(t>this.maxExtLength)throw new $Y("Max length exceeded: ext length (".concat(t,") > maxExtLength (").concat(this.maxExtLength,")"));var n=this.view.getInt8(this.pos+e),r=this.decodeBinary(t,e+1);return this.extensionCodec.decode(r,n,this.context)},t.prototype.lookU8=function(){return this.view.getUint8(this.pos)},t.prototype.lookU16=function(){return this.view.getUint16(this.pos)},t.prototype.lookU32=function(){return this.view.getUint32(this.pos)},t.prototype.readU8=function(){var t=this.view.getUint8(this.pos);return this.pos++,t},t.prototype.readI8=function(){var t=this.view.getInt8(this.pos);return this.pos++,t},t.prototype.readU16=function(){var t=this.view.getUint16(this.pos);return this.pos+=2,t},t.prototype.readI16=function(){var t=this.view.getInt16(this.pos);return this.pos+=2,t},t.prototype.readU32=function(){var t=this.view.getUint32(this.pos);return this.pos+=4,t},t.prototype.readI32=function(){var t=this.view.getInt32(this.pos);return this.pos+=4,t},t.prototype.readU64=function(){var t,e,n=(t=this.view,e=this.pos,4294967296*t.getUint32(e)+t.getUint32(e+4));return this.pos+=8,n},t.prototype.readI64=function(){var t=_Y(this.view,this.pos);return this.pos+=8,t},t.prototype.readF32=function(){var t=this.view.getFloat32(this.pos);return this.pos+=4,t},t.prototype.readF64=function(){var t=this.view.getFloat64(this.pos);return this.pos+=8,t},t}(),sZ={},aZ=n(477),oZ=n.n(aZ);function lZ(){return oZ()('(()=>{"use strict";const t=class{cumsum;constructor(t,e,s){this.cumsum=[];for(let t=0;t<s;t++){this.cumsum.push([]);for(let s=0;s<e;s++)this.cumsum[t].push(0)}this.cumsum[0][0]=t[0];for(let s=1;s<e;s++)this.cumsum[0][s]=this.cumsum[0][s-1]+t[s];for(let r=1;r<s;r++)this.cumsum[r][0]=this.cumsum[r-1][0]+t[r*e];for(let r=1;r<s;r++)for(let s=1;s<e;s++)this.cumsum[r][s]=t[r*e+s]+this.cumsum[r-1][s]+this.cumsum[r][s-1]-this.cumsum[r-1][s-1]}query(t,e,s,r){let a=this.cumsum[r][s];return e>0&&(a-=this.cumsum[e-1][s]),t>0&&(a-=this.cumsum[r][t-1]),t>0&&e>0&&(a+=this.cumsum[e-1][t-1]),a}},e=t=>{const{cx:e,cy:s,image:r,imageDataCumsum:a,imageDataSqrCumsum:i,sdThresh:o}=t;if(e-6<0||e+6>=r.width)return null;if(s-6<0||s+6>=r.height)return null;const u=a.query(e-6,s-6,e+6,s+6)/169;let n=i.query(e-6,s-6,e+6,s+6);return n-=2*u*a.query(e-6,s-6,e+6,s+6),n+=169*u**2,n/169<o*o?null:(n=Math.sqrt(n),n)},s=t=>{const{cx:e,cy:s,image:r,imageDataCumsum:a,imageDataSqrCumsum:i,tx:o,ty:u,vlen:n}=t,{data:m,width:h,height:l}=r;if(e-6<0||e+6>=h)return null;if(s-6<0||s+6>=l)return null;const c=a.query(e-6,s-6,e+6,s+6),f=i.query(e-6,s-6,e+6,s+6);let g=0,d=(s-6)*h+(e-6),y=(u-6)*h+(o-6);const M=h-13;for(let t=0;t<13;t++){for(let t=0;t<13;t++)g+=m[d]*m[y],d+=1,y+=1;d+=M,y+=M}g-=a.query(o-6,u-6,o+6,u+6)/169*c;let p=f-c*c/169;return 0==p?null:(p=Math.sqrt(p),1*g/(n*p))},r=r=>{const{data:a,height:i,width:o}=r,u=[o*i];for(let t=0;t<u.length;t++)u[t]=!1;const n=new Float32Array(a.length);for(let t=0;t<o;t++)n[t]=-1,n[o*(i-1)+t]=-1;for(let t=0;t<i;t++)n[t*o]=-1,n[t*o+o-1]=-1;for(let t=1;t<o-1;t++)for(let e=1;e<i-1;e++){const s=t+o*e;let r=0,i=0;for(let t=-1;t<=1;t++)r+=a[s+o*t+1]-a[s+o*t-1],i+=a[s+o+t]-a[s-o+t];r/=768,i/=768,n[s]=Math.sqrt((r*r+i*i)/2)}const m=new Uint32Array(1e3).fill(0),h=[-1,1,-o,o];for(let t=1;t<o-1;t++)for(let e=1;e<i-1;e++){const s=t+o*e;let r=!0;for(let t=0;t<h.length;t++)if(n[s]<=n[s+h[t]]){r=!1;break}if(r){let t=Math.floor(1e3*n[s]);t>999&&(t=999),t<0&&(t=0),m[t]+=1,u[s]=!0}}const l=.02*o*i;let c=999,f=0;for(;c>=0&&(f+=m[c],!(f>l));)c--;for(let t=0;t<u.length;t++)u[t]&&1e3*n[t]<c&&(u[t]=!1);const g=[];for(const[t,e]of a.entries())g[t]=e**2;const d=new t(a,o,i),y=new t(g,o,i),M=new Float32Array(a.length);for(let t=0;t<o;t++)for(let a=0;a<i;a++){const i=a*o+t;if(!u[i]){M[i]=1;continue}const n=e({image:r,cx:t,cy:a,sdThresh:5,imageDataCumsum:d,imageDataSqrCumsum:y});if(null===n){M[i]=1;continue}let m=-1;for(let e=-10;e<=10;e++){for(let i=-10;i<=10;i++){if(i*i+e*e<=4)continue;const o=s({image:r,cx:t+i,cy:a+e,vlen:n,tx:t,ty:a,imageDataCumsum:d,imageDataSqrCumsum:y});if(null!==o&&o>m&&(m=o,m>.95))break}if(m>.95)break}M[i]=m}const p=(t=>{const{image:r,featureMap:a,templateSize:i,searchSize:o,maxSimThresh:u,minSimThresh:n,sdThresh:m,imageDataCumsum:h,imageDataSqrCumsum:l}=t;let{occSize:c}=t;const{data:f,width:g,height:d}=r;c=Math.floor(Math.min(r.width,r.height)/10);const y=3*(2*i+1),M=Math.floor(g/y),p=Math.floor(d/y),w=Math.floor(g/c)*Math.floor(d/c)+M*p,q=[],S=new Float32Array(f.length);for(const[t,e]of a.entries())S[t]=e;let D=0;for(;D<w;){let t=u,a=-1,f=-1;for(let e=0;e<d;e++)for(let s=0;s<g;s++)S[e*g+s]<t&&(t=S[e*g+s],a=s,f=e);if(-1===a)break;const y=e({image:r,cx:a,cy:f,sdThresh:0,imageDataCumsum:h,imageDataSqrCumsum:l});if(null===y){S[f*g+a]=1;continue}if(y/(2*i+1)<m){S[f*g+a]=1;continue}let M=1,p=-1;for(let e=-o;e<=o;e++){for(let i=-o;i<=o;i++){if(i*i+e*e>o*o)continue;if(0===i&&0===e)continue;const u=s({image:r,vlen:y,cx:a+i,cy:f+e,tx:a,ty:f,imageDataCumsum:h,imageDataSqrCumsum:l});if(null!==u){if(u<M&&(M=u,M<n&&M<t))break;if(u>p&&(p=u,p>.99))break}}if(M<n&&M<t||p>.99)break}if(M<n&&M<t||p>.99)S[f*g+a]=1;else{q.push({x:a,y:f}),D+=1;for(let t=-c;t<=c;t++)for(let e=-c;e<=c;e++)f+t<0||f+t>=d||a+e<0||a+e>=g||(S[(f+t)*g+(a+e)]=1)}}return q})({image:r,featureMap:M,templateSize:6,searchSize:2,occSize:16,maxSimThresh:.9,minSimThresh:.2,sdThresh:8,imageDataCumsum:d,imageDataSqrCumsum:y});return p},a=t=>{const e=Math.min(t.width,t.height);return[256/e,128/e].map((e=>Object.assign((({image:t,ratio:e})=>{const s=Math.round(t.width*e),r=Math.round(t.height*e),a=new Uint8Array(s*r);for(let i=0;i<s;i++){const o=Math.round(1*i/e);let u=Math.round(1*(i+1)/e)-1;u>=t.width&&(u=t.width-1);for(let n=0;n<r;n++){const r=Math.round(1*n/e);let m=Math.round(1*(n+1)/e)-1;m>=t.height&&(m=t.height-1);let h=0,l=0;for(let e=o;e<=u;e++)for(let s=r;s<=m;s++)h+=1*t.data[s*t.width+e],l+=1;a[n*s+i]=Math.floor(h/l)}}return{data:a,width:s,height:r}})({image:t,ratio:e}),{scale:e})))},i=(t,e)=>{const s=[];for(const[a,i]of t.entries()){const t=r(i),o={data:i.data,scale:i.scale,width:i.width,height:i.height,points:t};s.push(o),e(a)}return s};onmessage=t=>{const{data:e}=t;if("compile"===e.type){const{targetImages:t}=e,s=50/t.length;let r=0;const o=[];for(const e of t){const t=a(e),u=s/t.length,n=i(t,(()=>{r+=u,postMessage({type:"progress",percent:r})}));o.push(n)}postMessage({type:"compileDone",list:o})}}})();',"Worker",void 0,void 0)}const uZ=({image:t,ratio:e})=>{const n=Math.round(t.width*e),r=Math.round(t.height*e),i=new Uint8Array(n*r);for(let s=0;s<n;s++){const a=Math.round(1*s/e);let o=Math.round(1*(s+1)/e)-1;o>=t.width&&(o=t.width-1);for(let l=0;l<r;l++){const r=Math.round(1*l/e);let u=Math.round(1*(l+1)/e)-1;u>=t.height&&(u=t.height-1);let c=0,h=0;for(let e=a;e<=o;e++)for(let n=r;n<=u;n++)c+=1*t.data[n*t.width+e],h+=1;i[l*n+s]=Math.floor(c/h)}}return{data:i,width:n,height:r}},cZ=t=>{const e=[];let n=100/Math.min(t.width,t.height);for(;;)if(e.push(n),n*=Math.pow(2,1/3),n>=.95){n=1;break}e.push(n),e.reverse();const r=e.map((e=>Object.assign(uZ({image:t,ratio:e}),{scale:e})));return r},hZ=t=>{const e=Math.min(t.width,t.height),n=[256/e,128/e].map((e=>Object.assign(uZ({image:t,ratio:e}),{scale:e})));return n},dZ=t=>{let e=t-(t>>1&1431655765);return e=(e>>2&858993459)+(858993459&e),e=(e>>4)+e&252645135,e=(e>>8)+e&16711935,e=(e>>16)+e&65535,e},pZ=t=>{const{v1:e,v2:n}=t;let r=0;for(let t=0;t<e.length;t++){const i=(e[t]^n[t])>>>0;r+=dZ(i)}return r},fZ=()=>{const t={seed:1234,arrayShuffle(t){const{arr:e,sampleSize:n}=t;for(let t=0;t<n;t++){this.seed=(214013*this.seed+2531011)%(1<<31);let n=this.seed>>16&32767;n%=e.length;const r=e[t];e[t]=e[n],e[n]=r}},nextInt(t){this.seed=(214013*this.seed+2531011)%(1<<31);let e=this.seed>>16&32767;return e%=t,e}};return t},mZ=t=>{const{points:e,pointIndexes:n,centerPointIndex:r,randomizer:i}=t;let s=!1;(n.length<=8||n.length<=16)&&(s=!0);const a={};if(!s){const t=(t=>{const{points:e,pointIndexes:n,randomizer:r}=t,i=[];for(let t=0;t<n.length;t++)i.push(t);let s=Number.MAX_SAFE_INTEGER,a=-1;const o=[];for(let t=0;t<128;t++){r.arrayShuffle({arr:i,sampleSize:8});let l=0;const u=[];for(let t=0;t<n.length;t++){let r=Number.MAX_SAFE_INTEGER;for(let s=0;s<8;s++){const a=n[i[s]],o=pZ({v1:e[n[t]].descriptors,v2:e[a].descriptors});o<r&&(u[t]=i[s],r=o)}l+=r}o.push(u),l<s&&(s=l,a=t)}return o[a]})({points:e,pointIndexes:n,randomizer:i});for(let e=0;e<t.length;e++)void 0===a[n[t[e]]]&&(a[n[t[e]]]=[]),a[n[t[e]]].push(n[e])}1===Object.keys(a).length&&(s=!0);const o={centerPointIndex:r};if(s){o.leaf=!0,o.pointIndexes=[];for(let t=0;t<n.length;t++)o.pointIndexes.push(n[t]);return o}return o.leaf=!1,o.children=[],Object.keys(a).forEach((t=>{o.children.push(mZ({points:e,pointIndexes:a[t],centerPointIndex:+t,randomizer:i}))})),o},gZ=({points:t})=>{const e=[];for(let n=0;n<t.length;n++)e.push(n);const n=fZ();return{rootNode:mZ({points:t,pointIndexes:e,centerPointIndex:null,randomizer:n})}},xZ=(t,e)=>{const n=2*Math.PI*e*t;return n/(n+1)},yZ=(t,e,n)=>t*e+(1-t)*n,vZ=class{minCutOff;beta;dCutOff;xPrev;dxPrev;tPrev;initialized;constructor({minCutOff:t,beta:e}){this.minCutOff=t,this.beta=e,this.dCutOff=.001,this.xPrev=null,this.dxPrev=null,this.tPrev=null,this.initialized=!1}reset(){this.initialized=!1}filter(t,e){if(!(this.initialized&&this.tPrev&&this.dxPrev&&this.xPrev))return this.initialized=!0,this.xPrev=e,this.dxPrev=e.map((()=>0)),this.tPrev=t,e;const{xPrev:n,tPrev:r,dxPrev:i}=this,s=t-r,a=xZ(s,this.dCutOff),o=[],l=[],u=[];for(let t=0;t<e.length;t++){o[t]=(e[t]-n[t])/s,l[t]=yZ(a,o[t],i[t]);const r=this.minCutOff+this.beta*Math.abs(l[t]),c=xZ(s,r);u[t]=yZ(c,e[t],n[t])}return this.xPrev=u,this.dxPrev=l,this.tPrev=t,u}};function bZ(){return oZ()('(()=>{"use strict";class t{constructor(t=[],r=e){if(this.data=t,this.length=this.data.length,this.compare=r,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}peek(){return this.data[0]}_up(t){const{data:e,compare:r}=this,o=e[t];for(;t>0;){const s=t-1>>1,n=e[s];if(r(o,n)>=0)break;e[t]=n,t=s}e[t]=o}_down(t){const{data:e,compare:r}=this,o=this.length>>1,s=e[t];for(;t<o;){let o=1+(t<<1),n=e[o];const i=o+1;if(i<this.length&&r(e[i],n)<0&&(o=i,n=e[i]),r(n,s)>=0)break;e[t]=n,t=o}e[t]=s}}function e(t,e){return t<e?-1:t>e?1:0}const r=t=>{let e=t-(t>>1&1431655765);return e=(e>>2&858993459)+(858993459&e),e=(e>>4)+e&252645135,e=(e>>8)+e&16711935,e=(e>>16)+e&65535,e},o=t=>{const{v1:e,v2:o}=t;let s=0;for(let t=0;t<e.length;t++){const n=(e[t]^o[t])>>>0;s+=r(n)}return s},s=({querypoint:t,keypoint:e,keycenterX:r,keycenterY:o,scaleOneOverLogK:s})=>{let n=t.angle-e.angle;n<=-Math.PI?n+=2*Math.PI:n>Math.PI&&(n-=2*Math.PI);const i=t.scale/e.scale,h=i*Math.cos(n),l=i*Math.sin(n),u=[h,-l,l,h],a=[u[0]*e.x+u[1]*e.y,u[2]*e.x+u[3]*e.y],c=t.x-a[0],f=t.y-a[1];return{x:u[0]*r+u[1]*o+c,y:u[2]*r+u[3]*o+f,angle:n,scale:Math.log(i)*s}},n=t=>{const{keywidth:e,keyheight:r,querywidth:o,queryheight:n,matches:i}=t,h=1.2*o,l=-h,u=1.2*n,a=-u,c=12,f=1/Math.log(10),m=Math.max(e,r),g=Math.floor(e/2),w=Math.floor(r/2),p=[];for(const t of i){const e=t.querypoint.scale,r=t.keypoint.scale;if(0==r){console.error("ERROR divide zero");continue}const o=e/r;p.push(o*m)}p.sort(((t,e)=>t-e));const d=.25*p[Math.floor(p.length/2)-(p.length%2==0?1:0)-1],y=Math.max(5,Math.ceil((h-l)/d)),M=Math.max(5,Math.ceil((u-a)/d)),b=y*M,x=b*c,E=[],S=[],v={};for(const[t,e]of i.entries()){const{keypoint:r,querypoint:o}=e,{x:n,y:i,scale:m,angle:p}=s({querypoint:o,keypoint:r,keycenterX:g,keycenterY:w,scaleOneOverLogK:f});if(n<l||n>=h||i<a||i>=u||p<=-Math.PI||p>Math.PI||m<-1||m>=1){E[t]=!1;continue}const d=y*(n-l)/(h-l),k=M*(i-a)/(u-a),R=c*(p+Math.PI)/(2*Math.PI),T=10*(m- -1)/2;S[t]={binX:d,binY:k,binAngle:R,binScale:T};const I=Math.floor(d-.5),q=Math.floor(k-.5),N=Math.floor(T-.5),C=(Math.floor(R-.5)+c)%c;if(I<0||I+1>=y||q<0||q+1>=M||N<0||N+1>=10)E[t]=!1;else{for(let t=0;t<2;t++){const e=I+t;for(let t=0;t<2;t++){const r=q+t;for(let t=0;t<2;t++){const o=(C+t)%c;for(let t=0;t<2;t++){const s=e+r*y+o*b+(N+t)*x;void 0===v[s]&&(v[s]=0),v[s]+=1}}}}E[t]=!0}}let k=0,R=-1;if(Object.keys(v).forEach((t=>{const e=+t;v[e]>k&&(k=v[e],R=e)})),k<3)return[];const T=Math.floor(R%x%b%y),I=Math.floor((R-T)%x%b/y),q=Math.floor((R-T-I*y)%x/b),N=Math.floor((R-T-I*y-q*b)/x),C=[];for(let t=0;t<i.length;t++){if(!E[t])continue;const e=S[t];if(Math.abs(e.binX-(T+.5))>=1)continue;if(Math.abs(e.binY-(I+.5))>=1)continue;if(Math.abs(e.binScale-(N+.5))>=1)continue;const r=Math.abs(e.binAngle-(q+.5));Math.min(r,c-r)>=1||C.push(i[t])}return C},i=()=>({seed:1234,arrayShuffle(t){const{arr:e,sampleSize:r}=t;for(let t=0;t<r;t++){this.seed=(214013*this.seed+2531011)%(1<<31);let r=this.seed>>16&32767;r%=e.length;const o=e[t];e[t]=e[r],e[r]=o}},nextInt(t){this.seed=(214013*this.seed+2531011)%(1<<31);let e=this.seed>>16&32767;return e%=t,e}}),h=(t,e)=>[t[0]-e[0],t[1]-e[1]],l=(t,e)=>{const r=t[0]*e[1]-t[1]*e[0];return.5*Math.abs(r)},u=(t,e,r)=>(e[0]-t[0])*(r[1]-t[1])-(e[1]-t[1])*(r[0]-t[0]),a=(t,e)=>{const r=(t=>{const e=t[4]*t[8]-t[5]*t[7],r=t[3]*t[8]-t[5]*t[6],o=t[3]*t[7]-t[4]*t[6];return t[0]*e-t[1]*r+t[2]*o})(t);if(Math.abs(r)<=e)return null;const o=1/r;return[(t[4]*t[8]-t[5]*t[7])*o,(t[2]*t[7]-t[1]*t[8])*o,(t[1]*t[5]-t[2]*t[4])*o,(t[5]*t[6]-t[3]*t[8])*o,(t[0]*t[8]-t[2]*t[6])*o,(t[2]*t[3]-t[0]*t[5])*o,(t[3]*t[7]-t[4]*t[6])*o,(t[1]*t[6]-t[0]*t[7])*o,(t[0]*t[4]-t[1]*t[3])*o]},c=(t,e)=>{const r=e[6]*t[0]+e[7]*t[1]+e[8];return[(e[0]*t[0]+e[1]*t[1]+e[2])/r,(e[3]*t[0]+e[4]*t[1]+e[5])/r]},f=Object.prototype.toString;function m(t){return f.call(t).endsWith("Array]")}function g(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!m(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!m(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var o=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!m(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,o=void 0===r?0:r,s=e.toIndex,n=void 0===s?t.length:s;if(o<0||o>=t.length||!Number.isInteger(o))throw new Error("fromIndex must be a positive integer smaller than length");if(n<=o||n>t.length||!Number.isInteger(n))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var i=t[o],h=o+1;h<n;h++)t[h]<i&&(i=t[h]);return i}(t),s=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!m(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,o=void 0===r?0:r,s=e.toIndex,n=void 0===s?t.length:s;if(o<0||o>=t.length||!Number.isInteger(o))throw new Error("fromIndex must be a positive integer smaller than length");if(n<=o||n>t.length||!Number.isInteger(n))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var i=t[o],h=o+1;h<n;h++)t[h]>i&&(i=t[h]);return i}(t);if(o===s)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var n=r.min,i=void 0===n?r.autoMinMax?o:0:n,h=r.max,l=void 0===h?r.autoMinMax?s:1:h;if(i>=l)throw new RangeError("min option must be smaller than max option");for(var u=(l-i)/(s-o),a=0;a<t.length;a++)e[a]=(t[a]-o)*u+i;return e}const w=" ".repeat(2),p=" ".repeat(4);function d(t,e={}){const{maxRows:r=15,maxColumns:o=10,maxNumSize:s=8,padMinus:n="auto"}=e;return`${t.constructor.name} {\\n${w}[\\n${p}${function(t,e,r,o,s){const{rows:n,columns:i}=t,h=Math.min(n,e),l=Math.min(i,r),u=[];if("auto"===s){s=!1;t:for(let e=0;e<h;e++)for(let r=0;r<l;r++)if(t.get(e,r)<0){s=!0;break t}}for(let e=0;e<h;e++){let r=[];for(let n=0;n<l;n++)r.push(y(t.get(e,n),o,s));u.push(`${r.join(" ")}`)}return l!==i&&(u[u.length-1]+=` ... ${i-r} more columns`),h!==n&&u.push(`... ${n-e} more rows`),u.join(`\\n${p}`)}(t,r,o,s,n)}\\n${w}]\\n${w}rows: ${t.rows}\\n${w}columns: ${t.columns}\\n}`}function y(t,e,r){return(t>=0&&r?` ${M(t,e-1)}`:M(t,e)).padEnd(e)}function M(t,e){let r=t.toString();if(r.length<=e)return r;let o=t.toFixed(e);if(o.length>e&&(o=t.toFixed(Math.max(0,e-(o.length-e)))),o.length<=e&&!o.startsWith("0.000")&&!o.startsWith("-0.000"))return o;let s=t.toExponential(e);return s.length>e&&(s=t.toExponential(Math.max(0,e-(s.length-e)))),s.slice(0)}function b(t,e,r){let o=r?t.rows:t.rows-1;if(e<0||e>o)throw new RangeError("Row index out of range")}function x(t,e,r){let o=r?t.columns:t.columns-1;if(e<0||e>o)throw new RangeError("Column index out of range")}function E(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function S(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function v(t,e,r,o,s){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(R("startRow",e),R("endRow",r),R("startColumn",o),R("endColumn",s),e>r||o>s||e<0||e>=t.rows||r<0||r>=t.rows||o<0||o>=t.columns||s<0||s>=t.columns)throw new RangeError("Submatrix indices are out of range")}function k(t,e=0){let r=[];for(let o=0;o<t;o++)r.push(e);return r}function R(t,e){if("number"!=typeof e)throw new TypeError(`${t} must be a number`)}function T(t){if(t.isEmpty())throw new Error("Empty matrix has no elements to index")}class I{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let o=new N(t,e);for(let s=0;s<t;s++)for(let t=0;t<e;t++)o.set(s,t,r[s*e+t]);return o}static rowVector(t){let e=new N(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new N(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new N(t,e)}static ones(t,e){return new N(t,e).fill(1)}static rand(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{random:o=Math.random}=r;let s=new N(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)s.set(r,t,o());return s}static randInt(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{min:o=0,max:s=1e3,random:n=Math.random}=r;if(!Number.isInteger(o))throw new TypeError("min must be an integer");if(!Number.isInteger(s))throw new TypeError("max must be an integer");if(o>=s)throw new RangeError("min must be smaller than max");let i=s-o,h=new N(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=o+Math.round(n()*i);h.set(r,t,e)}return h}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let o=Math.min(t,e),s=this.zeros(t,e);for(let t=0;t<o;t++)s.set(t,t,r);return s}static diag(t,e,r){let o=t.length;void 0===e&&(e=o),void 0===r&&(r=e);let s=Math.min(o,e,r),n=this.zeros(e,r);for(let e=0;e<s;e++)n.set(e,e,t[e]);return n}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,o=t.columns,s=new N(r,o);for(let n=0;n<r;n++)for(let r=0;r<o;r++)s.set(n,r,Math.min(t.get(n,r),e.get(n,r)));return s}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,o=t.columns,s=new this(r,o);for(let n=0;n<r;n++)for(let r=0;r<o;r++)s.set(n,r,Math.max(t.get(n,r),e.get(n,r)));return s}static checkMatrix(t){return I.isMatrix(t)?t:new N(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isEmpty(){return 0===this.rows||0===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,o=!0,s=!1;for(;t<this.rows&&o;){for(e=0,s=!1;e<this.columns&&!1===s;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(s=!0,r=e):(o=!1,s=!0);t++}return o}isReducedEchelonForm(){let t=0,e=0,r=-1,o=!0,s=!1;for(;t<this.rows&&o;){for(e=0,s=!1;e<this.columns&&!1===s;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(s=!0,r=e):(o=!1,s=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(o=!1);t++}return o}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let o=e;for(let s=e;s<t.rows;s++)t.get(s,r)>t.get(o,r)&&(o=s);if(0===t.get(o,r))r++;else{t.swapRows(e,o);let s=t.get(e,r);for(let o=r;o<t.columns;o++)t.set(e,o,t.get(e,o)/s);for(let o=e+1;o<t.rows;o++){let s=t.get(o,r)/t.get(e,r);t.set(o,r,0);for(let n=r+1;n<t.columns;n++)t.set(o,n,t.get(o,n)-t.get(e,n)*s)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,o=r-1;for(;o>=0;)if(0===t.maxRow(o))o--;else{let s=0,n=!1;for(;s<r&&!1===n;)1===t.get(o,s)?n=!0:s++;for(let r=0;r<o;r++){let n=t.get(r,s);for(let i=s;i<e;i++){let e=t.get(r,i)-n*t.get(o,i);t.set(r,i,e)}}o--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let o=new N(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)o.setSubMatrix(this,this.rows*t,this.columns*e);return o}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){b(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return N.rowVector(this.getRow(t))}setRow(t,e){b(this,t),e=E(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){b(this,t),b(this,e);for(let r=0;r<this.columns;r++){let o=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,o)}return this}getColumn(t){x(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return N.columnVector(this.getColumn(t))}setColumn(t,e){x(this,t),e=S(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){x(this,t),x(this,e);for(let r=0;r<this.rows;r++){let o=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,o)}return this}addRowVector(t){t=E(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=E(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=E(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=E(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=S(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=S(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=S(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=S(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){b(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){x(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t[e]&&(t[e]=this.get(e,r));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t[r]&&(t[r]=this.get(e,r));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}default:throw new Error(`invalid option: ${t}`)}}maxIndex(){T(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)>t&&(t=this.get(r,o),e[0]=r,e[1]=o);return e}min(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t[e]&&(t[e]=this.get(e,r));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t[r]&&(t[r]=this.get(e,r));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}default:throw new Error(`invalid option: ${t}`)}}minIndex(){T(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)<t&&(t=this.get(r,o),e[0]=r,e[1]=o);return e}maxRow(t){if(b(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){b(this,t),T(this);let e=this.get(t,0),r=[t,0];for(let o=1;o<this.columns;o++)this.get(t,o)>e&&(e=this.get(t,o),r[1]=o);return r}minRow(t){if(b(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){b(this,t),T(this);let e=this.get(t,0),r=[t,0];for(let o=1;o<this.columns;o++)this.get(t,o)<e&&(e=this.get(t,o),r[1]=o);return r}maxColumn(t){if(x(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){x(this,t),T(this);let e=this.get(0,t),r=[0,t];for(let o=1;o<this.rows;o++)this.get(o,t)>e&&(e=this.get(o,t),r[0]=o);return r}minColumn(t){if(x(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){x(this,t),T(this);let e=this.get(0,t),r=[0,t];for(let o=1;o<this.rows;o++)this.get(o,t)<e&&(e=this.get(o,t),r[0]=o);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(t="frobenius"){let e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r)*this.get(t,r);return Math.sqrt(e)}throw new RangeError(`unknown norm type: ${t}`)}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){I.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let o=0;o<e.length;o++)r+=e[o]*t[o];return r}mmul(t){t=N.checkMatrix(t);let e=this.rows,r=this.columns,o=t.columns,s=new N(e,o),n=new Float64Array(r);for(let i=0;i<o;i++){for(let e=0;e<r;e++)n[e]=t.get(e,i);for(let t=0;t<e;t++){let e=0;for(let o=0;o<r;o++)e+=this.get(t,o)*n[o];s.set(t,i,e)}}return s}strassen2x2(t){t=N.checkMatrix(t);let e=new N(2,2);const r=this.get(0,0),o=t.get(0,0),s=this.get(0,1),n=t.get(0,1),i=this.get(1,0),h=t.get(1,0),l=this.get(1,1),u=t.get(1,1),a=(r+l)*(o+u),c=(i+l)*o,f=r*(n-u),m=l*(h-o),g=(r+s)*u,w=a+m-g+(s-l)*(h+u),p=f+g,d=c+m,y=a-c+f+(i-r)*(o+n);return e.set(0,0,w),e.set(0,1,p),e.set(1,0,d),e.set(1,1,y),e}strassen3x3(t){t=N.checkMatrix(t);let e=new N(3,3);const r=this.get(0,0),o=this.get(0,1),s=this.get(0,2),n=this.get(1,0),i=this.get(1,1),h=this.get(1,2),l=this.get(2,0),u=this.get(2,1),a=this.get(2,2),c=t.get(0,0),f=t.get(0,1),m=t.get(0,2),g=t.get(1,0),w=t.get(1,1),p=t.get(1,2),d=t.get(2,0),y=t.get(2,1),M=t.get(2,2),b=(r-n)*(-f+w),x=(-r+n+i)*(c-f+w),E=(n+i)*(-c+f),S=r*c,v=(-r+l+u)*(c-m+p),k=(-r+l)*(m-p),R=(l+u)*(-c+m),T=(-s+u+a)*(w+d-y),I=(s-a)*(w-y),q=s*d,C=(u+a)*(-d+y),A=(-s+i+h)*(p+d-M),P=(s-h)*(p-M),V=(i+h)*(-d+M),F=S+q+o*g,z=(r+o+s-n-i-u-a)*w+x+E+S+T+q+C,j=S+v+R+(r+o+s-i-h-l-u)*p+q+A+V,$=b+i*(-c+f+g-w-p-d+M)+x+S+q+A+P,_=b+x+E+S+h*y,D=q+A+P+V+n*m,H=S+v+k+u*(-c+m+g-w-p-d+y)+T+I+q,U=T+I+q+C+l*f,L=S+v+k+R+a*M;return e.set(0,0,F),e.set(0,1,z),e.set(0,2,j),e.set(1,0,$),e.set(1,1,_),e.set(1,2,D),e.set(2,0,H),e.set(2,1,U),e.set(2,2,L),e}mmulStrassen(t){t=N.checkMatrix(t);let e=this.clone(),r=e.rows,o=e.columns,s=t.rows,n=t.columns;function i(t,e,r){let o=t.rows,s=t.columns;if(o===e&&s===r)return t;{let o=I.zeros(e,r);return o=o.setSubMatrix(t,0,0),o}}o!==s&&console.warn(`Multiplying ${r} x ${o} and ${s} x ${n} matrix: dimensions do not match.`);let h=Math.max(r,s),l=Math.max(o,n);return e=i(e,h,l),function t(e,r,o,s){if(o<=512||s<=512)return e.mmul(r);o%2==1&&s%2==1?(e=i(e,o+1,s+1),r=i(r,o+1,s+1)):o%2==1?(e=i(e,o+1,s),r=i(r,o+1,s)):s%2==1&&(e=i(e,o,s+1),r=i(r,o,s+1));let n=parseInt(e.rows/2,10),h=parseInt(e.columns/2,10),l=e.subMatrix(0,n-1,0,h-1),u=r.subMatrix(0,n-1,0,h-1),a=e.subMatrix(0,n-1,h,e.columns-1),c=r.subMatrix(0,n-1,h,r.columns-1),f=e.subMatrix(n,e.rows-1,0,h-1),m=r.subMatrix(n,r.rows-1,0,h-1),g=e.subMatrix(n,e.rows-1,h,e.columns-1),w=r.subMatrix(n,r.rows-1,h,r.columns-1),p=t(I.add(l,g),I.add(u,w),n,h),d=t(I.add(f,g),u,n,h),y=t(l,I.sub(c,w),n,h),M=t(g,I.sub(m,u),n,h),b=t(I.add(l,a),w,n,h),x=t(I.sub(f,l),I.add(u,c),n,h),E=t(I.sub(a,g),I.add(m,w),n,h),S=I.add(p,M);S.sub(b),S.add(E);let v=I.add(y,b),k=I.add(d,M),R=I.sub(p,d);R.add(y),R.add(x);let T=I.zeros(2*S.rows,2*S.columns);return T=T.setSubMatrix(S,0,0),T=T.setSubMatrix(v,S.rows,0),T=T.setSubMatrix(k,0,S.columns),T=T.setSubMatrix(R,S.rows,S.columns),T.subMatrix(0,o-1,0,s-1)}(e,t=i(t,h,l),h,l)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let o=new N(this.rows,this.columns);for(let t=0;t<this.rows;t++){const s=this.getRow(t);s.length>0&&g(s,{min:e,max:r,output:s}),o.setRow(t,s)}return o}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let o=new N(this.rows,this.columns);for(let t=0;t<this.columns;t++){const s=this.getColumn(t);s.length&&g(s,{min:e,max:r,output:s}),o.setColumn(t,s)}return o}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),o=this.get(e,this.columns-1-r);this.set(e,r,o),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),o=this.get(this.rows-1-r,e);this.set(r,e,o),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=N.checkMatrix(t);let e=this.rows,r=this.columns,o=t.rows,s=t.columns,n=new N(e*o,r*s);for(let i=0;i<e;i++)for(let e=0;e<r;e++)for(let r=0;r<o;r++)for(let h=0;h<s;h++)n.set(o*i+r,s*e+h,this.get(i,e)*t.get(r,h));return n}kroneckerSum(t){if(t=N.checkMatrix(t),!this.isSquare()||!t.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,r=t.rows,o=this.kroneckerProduct(N.eye(r,r)),s=N.eye(e,e).kroneckerProduct(t);return o.add(s)}transpose(){let t=new N(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(t=q){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=q){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,o){v(this,t,e,r,o);let s=new N(e-t+1,o-r+1);for(let n=t;n<=e;n++)for(let e=r;e<=o;e++)s.set(n-t,e-r,this.get(n,e));return s}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let o=new N(t.length,r-e+1);for(let s=0;s<t.length;s++)for(let n=e;n<=r;n++){if(t[s]<0||t[s]>=this.rows)throw new RangeError(`Row index out of range: ${t[s]}`);o.set(s,n-e,this.get(t[s],n))}return o}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let o=new N(r-e+1,t.length);for(let s=0;s<t.length;s++)for(let n=e;n<=r;n++){if(t[s]<0||t[s]>=this.columns)throw new RangeError(`Column index out of range: ${t[s]}`);o.set(n-e,s,this.get(n,t[s]))}return o}setSubMatrix(t,e,r){if((t=N.checkMatrix(t)).isEmpty())return this;v(this,e,e+t.rows-1,r,r+t.columns-1);for(let o=0;o<t.rows;o++)for(let s=0;s<t.columns;s++)this.set(e+o,r+s,t.get(o,s));return this}selection(t,e){!function(t,e){if(!m(e))throw new TypeError("row indices must be an array");for(let r=0;r<e.length;r++)if(e[r]<0||e[r]>=t.rows)throw new RangeError("row indices are out of range")}(this,t),function(t,e){if(!m(e))throw new TypeError("column indices must be an array");for(let r=0;r<e.length;r++)if(e[r]<0||e[r]>=t.columns)throw new RangeError("column indices are out of range")}(this,e);let r=new N(t.length,e.length);for(let o=0;o<t.length;o++){let s=t[o];for(let t=0;t<e.length;t++){let n=e[t];r.set(o,t,this.get(s,n))}}return r}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new N(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return function(t){let e=k(t.rows);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[r]+=t.get(r,o);return e}(this);case"column":return function(t){let e=k(t.columns);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[o]+=t.get(r,o);return e}(this);case void 0:return function(t){let e=0;for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)e+=t.get(r,o);return e}(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return function(t){let e=k(t.rows,1);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[r]*=t.get(r,o);return e}(this);case"column":return function(t){let e=k(t.columns,1);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[o]*=t.get(r,o);return e}(this);case void 0:return function(t){let e=1;for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)e*=t.get(r,o);return e}(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:o=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!m(o))throw new TypeError("mean must be an array");return function(t,e,r){const o=t.rows,s=t.columns,n=[];for(let i=0;i<o;i++){let o=0,h=0,l=0;for(let e=0;e<s;e++)l=t.get(i,e)-r[i],o+=l,h+=l*l;e?n.push((h-o*o/s)/(s-1)):n.push((h-o*o/s)/s)}return n}(this,r,o);case"column":if(!m(o))throw new TypeError("mean must be an array");return function(t,e,r){const o=t.rows,s=t.columns,n=[];for(let i=0;i<s;i++){let s=0,h=0,l=0;for(let e=0;e<o;e++)l=t.get(e,i)-r[i],s+=l,h+=l*l;e?n.push((h-s*s/o)/(o-1)):n.push((h-s*s/o)/o)}return n}(this,r,o);case void 0:if("number"!=typeof o)throw new TypeError("mean must be a number");return function(t,e,r){const o=t.rows,s=t.columns,n=o*s;let i=0,h=0,l=0;for(let e=0;e<o;e++)for(let o=0;o<s;o++)l=t.get(e,o)-r,i+=l,h+=l*l;return e?(h-i*i/n)/(n-1):(h-i*i/n)/n}(this,r,o);default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!m(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)-e[r])}(this,r),this;case"column":if(!m(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)-e[o])}(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)-e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.rows;r++){let o=0;for(let e=0;e<t.columns;e++)o+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(o))}return e}(this);else if(!m(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)/e[r])}(this,r),this;case"column":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.columns;r++){let o=0;for(let e=0;e<t.rows;e++)o+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(o))}return e}(this);else if(!m(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)/e[o])}(this,r),this;case void 0:if(void 0===r)r=function(t){const e=t.size-1;let r=0;for(let o=0;o<t.columns;o++)for(let s=0;s<t.rows;s++)r+=Math.pow(t.get(s,o),2)/e;return Math.sqrt(r)}(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)/e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}toString(t){return d(this,t)}}function q(t,e){return t-e}I.prototype.klass="Matrix","undefined"!=typeof Symbol&&(I.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){return d(this)}),I.random=I.rand,I.randomInt=I.randInt,I.diagonal=I.diag,I.prototype.diagonal=I.prototype.diag,I.identity=I.eye,I.prototype.negate=I.prototype.neg,I.prototype.tensorProduct=I.prototype.kroneckerProduct;class N extends I{constructor(t,e){if(super(),N.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>=0){if(this.data=[],!(Number.isInteger(e)&&e>=0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!m(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if("number"!=typeof(e=(t=r.length)?r[0].length:0))throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let o=0;o<t;o++){if(r[o].length!==e)throw new RangeError("Inconsistent array dimensions");if(!r[o].every((t=>"number"==typeof t)))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(r[o]))}}}this.rows=t,this.columns=e}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){return b(this,t),this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),b(this,t,!0),e=Float64Array.from(E(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){x(this,t);for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let o=0;o<t;o++)r[o]=this.data[e][o];for(let o=t+1;o<this.columns;o++)r[o-1]=this.data[e][o];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),x(this,t,!0),e=S(this,e);for(let r=0;r<this.rows;r++){const o=new Float64Array(this.columns+1);let s=0;for(;s<t;s++)o[s]=this.data[r][s];for(o[s++]=e[r];s<this.columns+1;s++)o[s]=this.data[r][s-1];this.data[r]=o}return this.columns+=1,this}}!function(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this}}(I,N);class C extends I{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}class A{constructor(t){let e,r,o,s,n,i,h,l,u,a=(t=C.checkMatrix(t)).clone(),c=a.rows,f=a.columns,m=new Float64Array(c),g=1;for(e=0;e<c;e++)m[e]=e;for(l=new Float64Array(c),r=0;r<f;r++){for(e=0;e<c;e++)l[e]=a.get(e,r);for(e=0;e<c;e++){for(u=Math.min(e,r),n=0,o=0;o<u;o++)n+=a.get(e,o)*l[o];l[e]-=n,a.set(e,r,l[e])}for(s=r,e=r+1;e<c;e++)Math.abs(l[e])>Math.abs(l[s])&&(s=e);if(s!==r){for(o=0;o<f;o++)i=a.get(s,o),a.set(s,o,a.get(r,o)),a.set(r,o,i);h=m[s],m[s]=m[r],m[r]=h,g=-g}if(r<c&&0!==a.get(r,r))for(e=r+1;e<c;e++)a.set(e,r,a.get(e,r)/a.get(r,r))}this.LU=a,this.pivotVector=m,this.pivotSign=g}isSingular(){let t=this.LU,e=t.columns;for(let r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=N.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let r,o,s,n=t.columns,i=t.subMatrixRow(this.pivotVector,0,n-1),h=e.columns;for(s=0;s<h;s++)for(r=s+1;r<h;r++)for(o=0;o<n;o++)i.set(r,o,i.get(r,o)-i.get(s,o)*e.get(r,s));for(s=h-1;s>=0;s--){for(o=0;o<n;o++)i.set(s,o,i.get(s,o)/e.get(s,s));for(r=0;r<s;r++)for(o=0;o<n;o++)i.set(r,o,i.get(r,o)-i.get(s,o)*e.get(r,s))}return i}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,r=t.columns;for(let o=0;o<r;o++)e*=t.get(o,o);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,o=new N(e,r);for(let s=0;s<e;s++)for(let e=0;e<r;e++)s>e?o.set(s,e,t.get(s,e)):s===e?o.set(s,e,1):o.set(s,e,0);return o}get upperTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,o=new N(e,r);for(let s=0;s<e;s++)for(let e=0;e<r;e++)s<=e?o.set(s,e,t.get(s,e)):o.set(s,e,0);return o}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function P(t,e){let r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class V{constructor(t){let e,r,o,s,n=(t=C.checkMatrix(t)).clone(),i=t.rows,h=t.columns,l=new Float64Array(h);for(o=0;o<h;o++){let t=0;for(e=o;e<i;e++)t=P(t,n.get(e,o));if(0!==t){for(n.get(o,o)<0&&(t=-t),e=o;e<i;e++)n.set(e,o,n.get(e,o)/t);for(n.set(o,o,n.get(o,o)+1),r=o+1;r<h;r++){for(s=0,e=o;e<i;e++)s+=n.get(e,o)*n.get(e,r);for(s=-s/n.get(o,o),e=o;e<i;e++)n.set(e,r,n.get(e,r)+s*n.get(e,o))}}l[o]=-t}this.QR=n,this.Rdiag=l}solve(t){t=N.checkMatrix(t);let e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let o,s,n,i,h=t.columns,l=t.clone(),u=e.columns;for(n=0;n<u;n++)for(s=0;s<h;s++){for(i=0,o=n;o<r;o++)i+=e.get(o,n)*l.get(o,s);for(i=-i/e.get(n,n),o=n;o<r;o++)l.set(o,s,l.get(o,s)+i*e.get(o,n))}for(n=u-1;n>=0;n--){for(s=0;s<h;s++)l.set(n,s,l.get(n,s)/this.Rdiag[n]);for(o=0;o<n;o++)for(s=0;s<h;s++)l.set(o,s,l.get(o,s)-l.get(n,s)*e.get(o,n))}return l.subMatrix(0,u-1,0,h-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,r=this.QR,o=r.columns,s=new N(o,o);for(t=0;t<o;t++)for(e=0;e<o;e++)t<e?s.set(t,e,r.get(t,e)):t===e?s.set(t,e,this.Rdiag[t]):s.set(t,e,0);return s}get orthogonalMatrix(){let t,e,r,o,s=this.QR,n=s.rows,i=s.columns,h=new N(n,i);for(r=i-1;r>=0;r--){for(t=0;t<n;t++)h.set(t,r,0);for(h.set(r,r,1),e=r;e<i;e++)if(0!==s.get(r,r)){for(o=0,t=r;t<n;t++)o+=s.get(t,r)*h.get(t,e);for(o=-o/s.get(r,r),t=r;t<n;t++)h.set(t,e,h.get(t,e)+o*s.get(t,r))}}return h}}class F{constructor(t,e={}){if((t=C.checkMatrix(t)).isEmpty())throw new Error("Matrix must be non-empty");let r=t.rows,o=t.columns;const{computeLeftSingularVectors:s=!0,computeRightSingularVectors:n=!0,autoTranspose:i=!1}=e;let h,l=Boolean(s),u=Boolean(n),a=!1;if(r<o)if(i){h=t.transpose(),r=h.rows,o=h.columns,a=!0;let e=l;l=u,u=e}else h=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else h=t.clone();let c=Math.min(r,o),f=Math.min(r+1,o),m=new Float64Array(f),g=new N(r,c),w=new N(o,o),p=new Float64Array(o),d=new Float64Array(r),y=new Float64Array(f);for(let t=0;t<f;t++)y[t]=t;let M=Math.min(r-1,o),b=Math.max(0,Math.min(o-2,r)),x=Math.max(M,b);for(let t=0;t<x;t++){if(t<M){m[t]=0;for(let e=t;e<r;e++)m[t]=P(m[t],h.get(e,t));if(0!==m[t]){h.get(t,t)<0&&(m[t]=-m[t]);for(let e=t;e<r;e++)h.set(e,t,h.get(e,t)/m[t]);h.set(t,t,h.get(t,t)+1)}m[t]=-m[t]}for(let e=t+1;e<o;e++){if(t<M&&0!==m[t]){let o=0;for(let s=t;s<r;s++)o+=h.get(s,t)*h.get(s,e);o=-o/h.get(t,t);for(let s=t;s<r;s++)h.set(s,e,h.get(s,e)+o*h.get(s,t))}p[e]=h.get(t,e)}if(l&&t<M)for(let e=t;e<r;e++)g.set(e,t,h.get(e,t));if(t<b){p[t]=0;for(let e=t+1;e<o;e++)p[t]=P(p[t],p[e]);if(0!==p[t]){p[t+1]<0&&(p[t]=0-p[t]);for(let e=t+1;e<o;e++)p[e]/=p[t];p[t+1]+=1}if(p[t]=-p[t],t+1<r&&0!==p[t]){for(let e=t+1;e<r;e++)d[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<o;r++)d[e]+=p[r]*h.get(e,r);for(let e=t+1;e<o;e++){let o=-p[e]/p[t+1];for(let s=t+1;s<r;s++)h.set(s,e,h.get(s,e)+o*d[s])}}if(u)for(let e=t+1;e<o;e++)w.set(e,t,p[e])}}let E=Math.min(o,r+1);if(M<o&&(m[M]=h.get(M,M)),r<E&&(m[E-1]=0),b+1<E&&(p[b]=h.get(b,E-1)),p[E-1]=0,l){for(let t=M;t<c;t++){for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}for(let t=M-1;t>=0;t--)if(0!==m[t]){for(let e=t+1;e<c;e++){let o=0;for(let s=t;s<r;s++)o+=g.get(s,t)*g.get(s,e);o=-o/g.get(t,t);for(let s=t;s<r;s++)g.set(s,e,g.get(s,e)+o*g.get(s,t))}for(let e=t;e<r;e++)g.set(e,t,-g.get(e,t));g.set(t,t,1+g.get(t,t));for(let e=0;e<t-1;e++)g.set(e,t,0)}else{for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}}if(u)for(let t=o-1;t>=0;t--){if(t<b&&0!==p[t])for(let e=t+1;e<o;e++){let r=0;for(let s=t+1;s<o;s++)r+=w.get(s,t)*w.get(s,e);r=-r/w.get(t+1,t);for(let s=t+1;s<o;s++)w.set(s,e,w.get(s,e)+r*w.get(s,t))}for(let e=0;e<o;e++)w.set(e,t,0);w.set(t,t,1)}let S=E-1,v=0,k=Number.EPSILON;for(;E>0;){let t,e;for(t=E-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+k*Math.abs(m[t]+Math.abs(m[t+1]));if(Math.abs(p[t])<=e||Number.isNaN(p[t])){p[t]=0;break}}if(t===E-2)e=4;else{let r;for(r=E-1;r>=t&&r!==t;r--){let e=(r!==E?Math.abs(p[r]):0)+(r!==t+1?Math.abs(p[r-1]):0);if(Math.abs(m[r])<=k*e){m[r]=0;break}}r===t?e=3:r===E-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=p[E-2];p[E-2]=0;for(let r=E-2;r>=t;r--){let s=P(m[r],e),n=m[r]/s,i=e/s;if(m[r]=s,r!==t&&(e=-i*p[r-1],p[r-1]=n*p[r-1]),u)for(let t=0;t<o;t++)s=n*w.get(t,r)+i*w.get(t,E-1),w.set(t,E-1,-i*w.get(t,r)+n*w.get(t,E-1)),w.set(t,r,s)}break}case 2:{let e=p[t-1];p[t-1]=0;for(let o=t;o<E;o++){let s=P(m[o],e),n=m[o]/s,i=e/s;if(m[o]=s,e=-i*p[o],p[o]=n*p[o],l)for(let e=0;e<r;e++)s=n*g.get(e,o)+i*g.get(e,t-1),g.set(e,t-1,-i*g.get(e,o)+n*g.get(e,t-1)),g.set(e,o,s)}break}case 3:{const e=Math.max(Math.abs(m[E-1]),Math.abs(m[E-2]),Math.abs(p[E-2]),Math.abs(m[t]),Math.abs(p[t])),s=m[E-1]/e,n=m[E-2]/e,i=p[E-2]/e,h=m[t]/e,a=p[t]/e,c=((n+s)*(n-s)+i*i)/2,f=s*i*(s*i);let d=0;0===c&&0===f||(d=c<0?0-Math.sqrt(c*c+f):Math.sqrt(c*c+f),d=f/(c+d));let y=(h+s)*(h-s)+d,M=h*a;for(let e=t;e<E-1;e++){let s=P(y,M);0===s&&(s=Number.MIN_VALUE);let n=y/s,i=M/s;if(e!==t&&(p[e-1]=s),y=n*m[e]+i*p[e],p[e]=n*p[e]-i*m[e],M=i*m[e+1],m[e+1]=n*m[e+1],u)for(let t=0;t<o;t++)s=n*w.get(t,e)+i*w.get(t,e+1),w.set(t,e+1,-i*w.get(t,e)+n*w.get(t,e+1)),w.set(t,e,s);if(s=P(y,M),0===s&&(s=Number.MIN_VALUE),n=y/s,i=M/s,m[e]=s,y=n*p[e]+i*m[e+1],m[e+1]=-i*p[e]+n*m[e+1],M=i*p[e+1],p[e+1]=n*p[e+1],l&&e<r-1)for(let t=0;t<r;t++)s=n*g.get(t,e)+i*g.get(t,e+1),g.set(t,e+1,-i*g.get(t,e)+n*g.get(t,e+1)),g.set(t,e,s)}p[E-2]=y,v+=1;break}case 4:if(m[t]<=0&&(m[t]=m[t]<0?-m[t]:0,u))for(let e=0;e<=S;e++)w.set(e,t,-w.get(e,t));for(;t<S&&!(m[t]>=m[t+1]);){let e=m[t];if(m[t]=m[t+1],m[t+1]=e,u&&t<o-1)for(let r=0;r<o;r++)e=w.get(r,t+1),w.set(r,t+1,w.get(r,t)),w.set(r,t,e);if(l&&t<r-1)for(let o=0;o<r;o++)e=g.get(o,t+1),g.set(o,t+1,g.get(o,t)),g.set(o,t,e);t++}v=0,E--}}if(a){let t=w;w=g,g=t}this.m=r,this.n=o,this.s=m,this.U=g,this.V=w}solve(t){let e=t,r=this.threshold,o=this.s.length,s=N.zeros(o,o);for(let t=0;t<o;t++)Math.abs(this.s[t])<=r?s.set(t,t,0):s.set(t,t,1/this.s[t]);let n=this.U,i=this.rightSingularVectors,h=i.mmul(s),l=i.rows,u=n.rows,a=N.zeros(l,u);for(let t=0;t<l;t++)for(let e=0;e<u;e++){let r=0;for(let s=0;s<o;s++)r+=h.get(t,s)*n.get(e,s);a.set(t,e,r)}return a.mmul(e)}solveForDiagonal(t){return this.solve(N.diag(t))}inverse(){let t=this.V,e=this.threshold,r=t.rows,o=t.columns,s=new N(r,this.s.length);for(let n=0;n<r;n++)for(let r=0;r<o;r++)Math.abs(this.s[r])>e&&s.set(n,r,t.get(n,r)/this.s[r]);let n=this.U,i=n.rows,h=n.columns,l=new N(r,i);for(let t=0;t<r;t++)for(let e=0;e<i;e++){let r=0;for(let o=0;o<h;o++)r+=s.get(t,o)*n.get(e,o);l.set(t,e,r)}return l}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s;for(let o=0,s=r.length;o<s;o++)r[o]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return N.diag(this.s)}}function z(t,e=!1){return t=C.checkMatrix(t),e?new F(t).inverse():function(t,e,r=!1){return t=C.checkMatrix(t),e=C.checkMatrix(e),r?new F(t).solve(e):t.isSquare()?new A(t).solve(e):new V(t).solve(e)}(t,N.eye(t.rows))}const j=t=>{let e=0,r=0;for(const o of t)e+=o[0],r+=o[1];const o=e/t.length,s=r/t.length;let n=0;for(const e of t){const t=e[0]-o,r=e[1]-s;n+=Math.sqrt(t*t+r*r)}const i=Math.sqrt(2)*t.length/n,h=[];for(const e of t)h.push([(e[0]-o)*i,(e[1]-s)*i]);return{normPoints:h,param:{meanX:o,meanY:s,s:i}}},$=(t,e)=>{const{normPoints:r,param:o}=j(t),{normPoints:s,param:n}=j(e),i=s.length,h=[],l=[];for(let t=0;t<i;t++){const e=[r[t][0],r[t][1],1,0,0,0,-r[t][0]*s[t][0],-r[t][1]*s[t][0]],o=[0,0,0,r[t][0],r[t][1],1,-r[t][0]*s[t][1],-r[t][1]*s[t][1]];h.push(e),h.push(o),l.push([s[t][0]]),l.push([s[t][1]])}try{const t=new N(h),e=new N(l),r=t.transpose(),s=r.mmul(t),i=r.mmul(e),u=((t,e,r)=>{const o=r.s*r.meanX,s=r.s*r.meanY,n=[t[0]+o*t[6],t[1]+o*t[7],(t[0]+o*t[6])*-e.meanX+(t[1]+o*t[7])*-e.meanY+(t[2]+o)/e.s,t[3]+s*t[6],t[4]+s*t[7],(t[3]+s*t[6])*-e.meanX+(t[4]+s*t[7])*-e.meanY+(t[5]+s)/e.s,r.s*t[6],r.s*t[7],r.s*t[6]*-e.meanX+r.s*t[7]*-e.meanY+r.s/e.s];for(let t=0;t<9;t++)n[t]=n[t]/n[8];return n})(z(s).mmul(i).to1DArray(),o,n);return u}catch(t){return null}},_=({H:t,testPoints:e,keyframe:r})=>{const o=a(t,1e-5);if(null===o)return!1;const s=[];for(const t of e)s.push(c(t,o));return!(((t,e,r,o)=>{const s=h(e,t),n=h(r,t),i=h(o,t),u=h(e,r),a=h(o,r),c=l(s,n),f=l(n,i),m=l(s,i),g=l(u,a);return Math.min(c,f,m,g)})(s[0],s[1],s[2],s[3])<r.width*r.height*1e-4||!((t,e,r,o)=>{const s=u(t,e,r)<=0;return u(e,r,o)<=0===s&&u(r,o,t)<=0===s&&u(o,t,e)<=0===s})(s[0],s[1],s[2],s[3]))},D=({inH:t})=>{const e=1/t[8],r=[];for(let o=0;o<8;o++)r[o]=t[o]*e;return r[8]=1,r},H=({H:t,srcPoint:e,dstPoint:r,oneOverScaleSqr:o})=>{const s=c(e,t),n=[s[0]-r[0],s[1]-r[1]];return Math.log(1+(n[0]*n[0]+n[1]*n[1])*o)},U=({H:t,testPoints:e})=>{const r=[];for(const[o,s]of e.entries())r[o]=c(s,t);for(let t=0;t<e.length;t++){const a=t,c=(t+1)%e.length,f=(t+2)%e.length;if(o=e[a],s=e[c],n=e[f],i=r[a],h=r[c],l=r[f],u(o,s,n)>0!=u(i,h,l)>0)return!1}var o,s,n,i,h,l;return!0},L=t=>{const{dstPoints:e,keyframe:r,srcPoints:o,quickMode:s}=t,n=[[0,0],[r.width,0],[r.width,r.height],[0,r.height]];if(o.length<4)return null;const h=Math.min(10,o.length),l=i(),a=o.map(((t,e)=>e));l.arrayShuffle({arr:a,sampleSize:a.length});const c=s?10:20,f=2*c;let m=0;const g=[];for(;m<f&&g.length<c;){if(m+=1,l.arrayShuffle({arr:a,sampleSize:4}),w=o[a[0]],p=o[a[1]],d=o[a[2]],y=o[a[3]],M=e[a[0]],b=e[a[1]],x=e[a[2]],E=e[a[3]],u(w,p,d)>0!=u(M,b,x)>0||u(p,d,y)>0!=u(b,x,E)>0||u(d,y,w)>0!=u(x,E,M)>0||u(y,w,p)>0!=u(E,M,b)>0)continue;const t=$([o[a[0]],o[a[1]],o[a[2]],o[a[3]]],[e[a[0]],e[a[1]],e[a[2]],e[a[3]]]);null!==t&&U({H:t,testPoints:n})&&g.push(t)}var w,p,d,y,M,b,x,E;if(0===g.length)return null;const S=[];for(const t of g)S.push({H:t,cost:0});let v=h;for(let t=0;t<o.length&&S.length>2;t+=v){v=Math.min(h,o.length-t);const r=t+v;for(let s=0;s<S.length;s++)for(let n=t;n<r;n++){const t=H({H:S[s].H,srcPoint:o[n],dstPoint:e[n],oneOverScaleSqr:1e4});S[s].cost+=t}S.sort(((t,e)=>t.cost-e.cost)),S.splice(-Math.floor((S.length+1)/2))}let k=null;for(let t=0;t<S.length;t++){const e=D({inH:S[t].H});if(_({H:e,testPoints:n,keyframe:r})){k=e;break}}return k},X=({node:t,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i})=>{if(t.leaf){for(const e of t.pointIndexes)n.push(e);return}const h=[];for(const s of t.children){const t=s.centerPointIndex;if(null==t)continue;const n=o({v1:e[t].descriptors,v2:r.descriptors});h.push(n)}const l=Math.min(Number.MAX_SAFE_INTEGER,...h);for(const[e,r]of t.children.entries())h[e]!==l&&s.push({node:r,d:h[e]});for(const[o,u]of t.children.entries())h[o]===l&&X({node:u,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i});if(i<8&&s.length>0){const t=s.pop();if(t){const{node:o}=t;X({node:o,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i+=1})}}},O=t=>{const{H:e,matches:r,threshold:o}=t,s=o**2,n=[];for(const t of r){const{querypoint:r,keypoint:o}=t,i=c([o.x,o.y],e);(i[0]-r.x)*(i[0]-r.x)+(i[1]-r.y)*(i[1]-r.y)<=s&&n.push(t)}return n},Y=e=>{const{keyframe:r,querypoints:s,querywidth:i,queryheight:h,debugMode:l}=e,u={},f=(e=>{const{keyframe:r,querypoints:s}=e,n=[];for(const e of s){const s=e.maxima?r.maximaPoints:r.minimaPoints;if(0===s.length)continue;const i=e.maxima?r.maximaPointsCluster.rootNode:r.minimaPointsCluster.rootNode,h=[],l=new t([],((t,e)=>t.d-e.d));X({node:i,keypoints:s,querypoint:e,queue:l,keypointIndexes:h,numPop:0});let u=-1,a=Number.MAX_SAFE_INTEGER,c=Number.MAX_SAFE_INTEGER;for(let t=0;t<h.length;t++){const r=s[h[t]],n=o({v1:r.descriptors,v2:e.descriptors});n<a?(c=a,a=n,u=h[t]):n<c&&(c=n)}-1!==u&&(c===Number.MAX_SAFE_INTEGER||1*a/c<.7)&&n.push({querypoint:e,keypoint:s[u]})}return n})({keyframe:r,querypoints:s});if(l&&(u.matches=f),f.length<6)return{debugExtra:u};const m=n({keywidth:r.width,keyheight:r.height,querywidth:i,queryheight:h,matches:f});l&&(u.houghMatches=m);const g=L({srcPoints:m.map((t=>[t.keypoint.x,t.keypoint.y])),dstPoints:m.map((t=>[t.querypoint.x,t.querypoint.y])),keyframe:r});if(null===g)return{debugExtra:u};const w=O({H:g,matches:m,threshold:3});if(l&&(u.inlierMatches=w),w.length<6)return{debugExtra:u};const p=a(g,1e-5);if(!p)return{debugExtra:u};const d=(t=>{const{keyframe:e,querypoints:r,HInv:s}=t,n=[];for(const t of r){const r=c([t.x,t.y],s);let i=-1,h=Number.MAX_SAFE_INTEGER,l=Number.MAX_SAFE_INTEGER;const u=t.maxima?e.maximaPoints:e.minimaPoints;for(const[e,s]of u.entries()){if((s.x-r[0])**2+(s.y-r[1])**2>100)continue;const n=o({v1:s.descriptors,v2:t.descriptors});n<h?(l=h,h=n,i=e):n<l&&(l=n)}-1!==i&&(l===Number.MAX_SAFE_INTEGER||1*h/l<.7)&&n.push({querypoint:t,keypoint:u[i]})}return n})({keyframe:r,querypoints:s,HInv:p});l&&(u.matches2=d);const y=n({keywidth:r.width,keyheight:r.height,querywidth:i,queryheight:h,matches:d});l&&(u.houghMatches2=y);const M=L({srcPoints:y.map((t=>[t.keypoint.x,t.keypoint.y])),dstPoints:y.map((t=>[t.querypoint.x,t.querypoint.y])),keyframe:r});if(null===M)return{debugExtra:u};const b=O({H:M,matches:y,threshold:3});return l&&(u.inlierMatches2=b),{H:M,matches:b,debugExtra:u}},G=(t,e)=>[[t[0][0]*e[0][0]+t[0][2]*e[2][0],t[0][0]*e[0][1]+t[0][2]*e[2][1],t[0][0]*e[0][2]+t[0][2]*e[2][2],t[0][0]*e[0][3]+t[0][2]*e[2][3]],[t[1][1]*e[1][0]+t[1][2]*e[2][0],t[1][1]*e[1][1]+t[1][2]*e[2][1],t[1][1]*e[1][2]+t[1][2]*e[2][2],t[1][1]*e[1][3]+t[1][2]*e[2][3]],[e[2][0],e[2][1],e[2][2],e[2][3]]],W=(t,e,r,o=0)=>({x:t[0][0]*e+t[0][1]*r+t[0][3],y:t[1][0]*e+t[1][1]*r+t[1][3],z:t[2][0]*e+t[2][1]*r+t[2][3]}),Q=(t,e,r,o=0)=>{const s=W(t,e,r,o),{x:n,y:i,z:h}=s;return{x:n/h,y:i/h}},J=[[],[],[]],K=[[],[]],B=[[],[],[]],Z=({initialModelViewTransform:t,projectionTransform:e,worldCoords:r,screenCoords:o,inlierProb:s})=>{const n=s<1;let i=t,h=0,l=0;const u=new Array(r.length),a=new Array(r.length),c=new Array(r.length),f=new Array(r.length);for(let t=0;t<=10;t++){const m=G(e,i);for(let t=0;t<r.length;t++){const e=Q(m,r[t].x,r[t].y,r[t].z),s=o[t].x-e.x,n=o[t].y-e.y;c[t]=s,f[t]=n,u[t]=s**2+n**2}let g=0;if(l=0,n){const t=Math.max(3,Math.floor(r.length*s)-1);for(let t=0;t<r.length;t++)a[t]=u[t];a.sort(((t,e)=>t-e)),g=Math.max(4*a[t],16);for(let t=0;t<r.length;t++)a[t]>g?l+=g/6:l+=g/6*(1-(1-a[t]/g)*(1-a[t]/g)*(1-a[t]/g))}else l=u.reduce(((t,e)=>t+e),0);if(l/=r.length,l<.1)break;if(t>0&&l/h>.99)break;if(10===t)break;h=l;const w=[],p=[];for(let t=0;t<r.length;t++){if(n&&u[t]>g)continue;const o=rt({modelViewProjectionTransform:m,modelViewTransform:i,projectionTransform:e,worldCoord:r[t]});if(n){const e=(1-u[t]/g)*(1-u[t]/g);for(let t=0;t<2;t++)for(let r=0;r<6;r++)o[t][r]*=e;w.push([c[t]*e]),w.push([f[t]*e])}else w.push([c[t]]),w.push([f[t]]);for(let t=0;t<o.length;t++)p.push(o[t])}const d=et({dU:w,J_U_S:p});if(null===d)break;i=tt({modelViewTransform:i,dS:d})}return{modelViewTransform:i,err:l}},tt=({modelViewTransform:t,dS:e})=>{let r,o,s,n=e[0]**2+e[1]**2+e[2]**2;n<1e-6?(r=1,o=0,s=0,n=0):(n=Math.sqrt(n),r=e[0]/n,o=e[1]/n,s=e[2]/n);const i=Math.cos(n),h=Math.sin(n),l=1-i;J[0][0]=r*r*l+i,J[0][1]=r*o*l-s*h,J[0][2]=r*s*l+o*h,J[0][3]=e[3],J[1][0]=o*r*l+s*h,J[1][1]=o*o*l+i,J[1][2]=o*s*l-r*h,J[1][3]=e[4],J[2][0]=s*r*l-o*h,J[2][1]=s*o*l+r*h,J[2][2]=s*s*l+i,J[2][3]=e[5];const u=[[],[],[]];for(let e=0;e<3;e++){for(let r=0;r<4;r++)u[e][r]=t[e][0]*J[0][r]+t[e][1]*J[1][r]+t[e][2]*J[2][r];u[e][3]+=t[e][3]}return u},et=({dU:t,J_U_S:e})=>{const r=new N(e),o=new N(t),s=r.transpose(),n=s.mmul(r),i=s.mmul(o);let h;try{h=z(n)}catch(t){return null}return h.mmul(i).to1DArray()},rt=({modelViewProjectionTransform:t,modelViewTransform:e,projectionTransform:r,worldCoord:o})=>{const s=e,{x:n,y:i,z:h}=o,l=W(t,n,i,h),u=l.z*l.z;K[0][0]=r[0][0]*l.z/u,K[0][1]=r[0][1]*l.z/u,K[0][2]=(r[0][2]*l.z-r[2][2]*l.x)/u,K[1][0]=r[1][0]*l.z/u,K[1][1]=r[1][1]*l.z/u,K[1][2]=(r[1][2]*l.z-r[2][2]*l.y)/u,B[0][0]=s[0][2]*i,B[0][1]=-s[0][2]*n,B[0][2]=s[0][1]*n-s[0][0]*i,B[0][3]=s[0][0],B[0][4]=s[0][1],B[0][5]=s[0][2],B[1][0]=s[1][2]*i,B[1][1]=-s[1][2]*n,B[1][2]=s[1][1]*n-s[1][0]*i,B[1][3]=s[1][0],B[1][4]=s[1][1],B[1][5]=s[1][2],B[2][0]=s[2][2]*i,B[2][1]=-s[2][2]*n,B[2][2]=s[2][1]*n-s[2][0]*i,B[2][3]=s[2][0],B[2][4]=s[2][1],B[2][5]=s[2][2];const a=[[],[]];for(let t=0;t<2;t++)for(let e=0;e<6;e++){a[t][e]=0;for(let r=0;r<3;r++)a[t][e]+=K[t][r]*B[r][e]}return a};let ot,st,nt=[],it=!1;onmessage=t=>{const{data:e}=t;switch(e.type){case"setup":(t=>{nt=t.matchingDataList,it=t.debugMode,ot=new class{queryWidth;queryHeight;debugMode;constructor(t,e,r=!1){this.queryWidth=t,this.queryHeight=e,this.debugMode=r}matchDetection(t,e){const r={frames:[]};let o=null;for(const[s,n]of t.entries()){const t=Y({keyframe:n,querypoints:e,querywidth:this.queryWidth,queryheight:this.queryHeight,debugMode:this.debugMode});if(!t)continue;const{H:i,matches:h,debugExtra:l}=t;r.frames.push(l),i&&(null===o||(o?.matches?.length??0<h.length))&&(o={keyframeIndex:s,matches:h,H:i})}if(null===o||!o.matches)return{keyframeIndex:-1,debugExtra:r};const s=[],n=[],i=t[o.keyframeIndex];for(const t of o.matches){const e=t.querypoint,r=t.keypoint;s.push({x:e.x,y:e.y}),n.push({x:(r.x+.5)/i.scale,y:(r.y+.5)/i.scale,z:0})}return{keyframeIndex:o.keyframeIndex,screenCoords:s,worldCoords:n,debugExtra:r}}}(t.inputWidth,t.inputHeight,it),st=new class{projectionTransform;constructor(t){this.projectionTransform=t}estimate({screenCoords:t,worldCoords:e}){return(t=>{const{projectionTransform:e,screenCoords:r,worldCoords:o}=t,s=$(o.map((t=>[t.x,t.y])),r.map((t=>[t.x,t.y])));if(!s)return null;const n=new N([[s[0],s[1],s[2]],[s[3],s[4],s[5]],[s[6],s[7],s[8]]]),i=z(new N(e)).mmul(n).to1DArray(),h=Math.sqrt(i[0]*i[0]+i[3]*i[3]+i[6]*i[6]),l=Math.sqrt(i[1]*i[1]+i[4]*i[4]+i[7]*i[7]),u=(h+l)/2,a=[];a[0]=i[0]/h,a[3]=i[3]/h,a[6]=i[6]/h,a[1]=i[1]/l,a[4]=i[4]/l,a[7]=i[7]/l,a[2]=a[3]*a[7]-a[6]*a[4],a[5]=a[6]*a[1]-a[0]*a[7],a[8]=a[0]*a[4]-a[1]*a[3];const c=Math.sqrt(a[2]*a[2]+a[5]*a[5]+a[8]*a[8]);a[2]/=c,a[5]/=c,a[8]/=c;const f=[];return f[0]=i[2]/u,f[1]=i[5]/u,f[2]=i[8]/u,[[a[0],a[1],a[2],f[0]],[a[3],a[4],a[5],f[1]],[a[6],a[7],a[8],f[2]]]})({screenCoords:t,worldCoords:e,projectionTransform:this.projectionTransform})}refineEstimate({initialModelViewTransform:t,worldCoords:e,screenCoords:r}){return(({initialModelViewTransform:t,projectionTransform:e,worldCoords:r,screenCoords:o})=>{const s=r.reduce(((t,e)=>t+e.x),0)/r.length,n=r.reduce(((t,e)=>t+e.y),0)/r.length,i=[];for(const t of r)i.push({x:t.x-s,y:t.y-n,z:t.z});const h=[[],[],[]];for(let e=0;e<3;e++)for(let r=0;r<3;r++)h[e][r]=t[e][r];h[0][3]=t[0][0]*s+t[0][1]*n+t[0][3],h[1][3]=t[1][0]*s+t[1][1]*n+t[1][3],h[2][3]=t[2][0]*s+t[2][1]*n+t[2][3];const l=[1,.8,.6,.4,0];let u=h,a=null;for(const t of l){const r=Z({initialModelViewTransform:u,projectionTransform:e,worldCoords:i,screenCoords:o,inlierProb:t});if(u=r.modelViewTransform,r.err<5){a=u;break}}return null===a?null:(a[0][3]=a[0][3]-a[0][0]*s-a[0][1]*n,a[1][3]=a[1][3]-a[1][0]*s-a[1][1]*n,a[2][3]=a[2][3]-a[2][0]*s-a[2][1]*n,a)})({initialModelViewTransform:t,worldCoords:e,screenCoords:r,projectionTransform:this.projectionTransform})}}(t.projectionTransform)})(e);break;case"match":(t=>{const e=t.targetIndexes;let r=-1,o=null,s=null;for(const n of e){const{keyframeIndex:e,screenCoords:i,worldCoords:h,debugExtra:l}=ot.matchDetection(nt[n],t.featurePoints);if(s=l,-1!==e){const t=st.estimate({screenCoords:i,worldCoords:h});t&&(r=n,o=t);break}}postMessage({type:"matchDone",targetIndex:r,modelViewTransform:o,debugExtra:s})})(e);break;case"trackUpdate":(t=>{const{modelViewTransform:e,worldCoords:r,screenCoords:o}=t,s=st.refineEstimate({initialModelViewTransform:e,screenCoords:o,worldCoords:r});postMessage({type:"trackUpdateDone",modelViewTransform:s})})(e)}}})();',"Worker",void 0,void 0)}const wZ="updateMatrix";var SZ=n(379),_Z=n.n(SZ),IZ=n(795),kZ=n.n(IZ),MZ=n(569),TZ=n.n(MZ),CZ=n(565),EZ=n.n(CZ),AZ=n(216),NZ=n.n(AZ),RZ=n(589),DZ=n.n(RZ),LZ=n(485),FZ={};FZ.styleTagTransform=DZ(),FZ.setAttributes=EZ(),FZ.insert=TZ().bind(null,"head"),FZ.domAPI=kZ(),FZ.insertStyleElement=NZ(),_Z()(LZ.Z,FZ),LZ.Z&&LZ.Z.locals&&LZ.Z.locals;const $Z="yes",PZ="hidden",OZ=new Br;OZ.compose(new ur,new lr,new ur(.001,.001,.001));window.MINDAR.IMAGE.MindARThree||(window.MINDAR.IMAGE.MindARThree=class{container;imageTargetSrc;maxTrack;filterMinCF;filterBeta;warmupTolerance;missTolerance;ui;scene;cssScene;renderer;cssRenderer;camera;anchors;controller;video;postMatrixs;constructor({container:t,imageTargetSrc:e,maxTrack:n,uiLoading:r="yes",uiScanning:i="yes",uiError:s="yes",filterMinCF:a=null,filterBeta:o=null,warmupTolerance:l=null,missTolerance:u=null}){this.container=t,this.imageTargetSrc=e,this.maxTrack=n,this.filterMinCF=a,this.filterBeta=o,this.warmupTolerance=l,this.missTolerance=u,this.ui=new class{loadingModal;compatibilityModal;scanningMask;constructor({uiLoading:t,uiScanning:e,uiError:n}){this.loadingModal=t===$Z?this._loadHTML('<div class="mindar-ui-overlay mindar-ui-loading"> <div class="loader"/> </div> '):document.querySelector(t),this.compatibilityModal=n===$Z?this._loadHTML('<div class="mindar-ui-overlay mindar-ui-compatibility"> <div class="content"> <h1>Failed to launch :(</h1> <p> Looks like your device/browser is not compatible. </p> <br/> <br/> <p> Please try the following recommended browsers: </p> <p> For Android device - Chrome </p> <p> For iOS device - Safari </p> </div> </div> '):document.querySelector(n),this.scanningMask=e===$Z?this._loadHTML('<div class="mindar-ui-overlay mindar-ui-scanning"> <div class="scanning"> <div class="inner"> <div class="scanline"/> </div> </div> </div> '):document.querySelector(e),this.hideLoading(),this.hideCompatibility(),this.hideScanning()}showLoading(){this.loadingModal&&this.loadingModal.classList.remove(PZ)}hideLoading(){this.loadingModal&&this.loadingModal.classList.add(PZ)}showCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.remove(PZ)}hideCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.add(PZ)}showScanning(){this.scanningMask&&this.scanningMask.classList.remove(PZ)}hideScanning(){this.scanningMask&&this.scanningMask.classList.add(PZ)}_loadHTML(t){const e=document.createElement("template");e.innerHTML=t.trim();const n=e.content.firstChild;return document.querySelector("a-scene").appendChild(n),n}}({uiLoading:r,uiScanning:i,uiError:s}),this.scene=new gl,this.cssScene=new gl,this.renderer=new dl({antialias:!0,alpha:!0}),this.cssRenderer=new tf,this.renderer.outputEncoding=$e,this.renderer.setPixelRatio(window.devicePixelRatio),this.camera=new ys,this.anchors=[],this.renderer.domElement.style.position="absolute",this.cssRenderer.domElement.style.position="absolute",this.container.appendChild(this.renderer.domElement),this.container.appendChild(this.cssRenderer.domElement),window.addEventListener("resize",this.resize.bind(this))}async start(){this.ui.showLoading(),await this._startVideo(),await this._startAR()}stop(){this.controller.stopProcessVideo();const{srcObject:t}=this.video;t&&(t.getTracks().forEach((t=>{t.stop()})),this.video.remove())}addAnchor(t){const e=new sl;e.visible=!1,e.matrixAutoUpdate=!1;const n={group:e,targetIndex:t,onTargetFound:null,onTargetLost:null,css:!1,visible:!1};return this.anchors.push(n),this.scene.add(e),n}addCSSAnchor(t){const e=new sl;e.visible=!1,e.matrixAutoUpdate=!1;const n={group:e,targetIndex:t,onTargetFound:null,onTargetLost:null,css:!0,visible:!1};return this.anchors.push(n),this.cssScene.add(e),n}_startVideo(){return new Promise((async(t,e)=>{if(this.video=document.createElement("video"),this.video.setAttribute("autoplay",""),this.video.setAttribute("muted",""),this.video.setAttribute("playsinline",""),this.video.style.position="absolute",this.video.style.top="0px",this.video.style.left="0px",this.video.style.zIndex="-2",this.container.appendChild(this.video),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)return this.ui.showCompatibility(),void e();try{const e=await navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"environment"}});this.video.addEventListener("loadedmetadata",(()=>{this.video.setAttribute("width",this.video.videoWidth.toString()),this.video.setAttribute("height",this.video.videoHeight.toString()),t()})),this.video.srcObject=e}catch(t){console.log("getUserMedia error",t),e()}}))}_startAR(){return new Promise((async t=>{this.controller=new class{inputWidth;inputHeight;maxTrack;filterMinCF;filterBeta;warmupTolerance;missTolerance;cropDetector;inputLoader;markerDimensions;onUpdate;debugMode;processingVideo;interestedTargetIndex;projectionTransform;projectionMatrix;worker;workerMatchDone;workerTrackDone;trackingStates;tracker;constructor({inputWidth:t,inputHeight:e,onUpdate:n=null,debugMode:r=!1,maxTrack:i=1,warmupTolerance:s=null,missTolerance:a=null,filterMinCF:o=null,filterBeta:l=null}){this.inputHeight=e,this.inputWidth=t,this.maxTrack=i,this.filterMinCF=mY(o)?.001:o,this.filterBeta=mY(l)?1e3:l,this.warmupTolerance=mY(s)?5:s,this.missTolerance=mY(a)?5:a,this.cropDetector=new class{width;height;debugMode;cropSize;lastRandomIndex;detector;constructor(t,e,n=!1){this.width=t,this.height=e,this.debugMode=n,this.cropSize=this._getCropSize(t,e),this.detector=new xY(t,e,n),this.lastRandomIndex=4}_getCropSize(t,e){const n=Math.min(t,e)/2;return Math.pow(2,Math.round(Math.log(n)/Math.log(2)))}async detect(t){const e=Math.floor(this.height/2-this.cropSize/2),n=Math.floor(this.width/2-this.cropSize/2),r=await this._detect(t,n,e);return this.debugMode&&(r.debugExtra.crop={startX:n,startY:e,cropSize:this.cropSize}),r}detectMoving(t){const e=this.lastRandomIndex%3,n=Math.floor(this.lastRandomIndex/3);let r=Math.floor(this.height/2-this.cropSize+n*this.cropSize/2),i=Math.floor(this.width/2-this.cropSize+e*this.cropSize/2);return i<0&&(i=0),r<0&&(r=0),i>=this.width-this.cropSize&&(i=this.width-this.cropSize-1),r>=this.height-this.cropSize&&(r=this.height-this.cropSize-1),this.lastRandomIndex=(this.lastRandomIndex+1)%9,this._detect(t,i,r)}_detect(t,e,n){const r=t.slice([n,e],[this.cropSize,this.cropSize]),{featurePoints:i,debugExtra:s}=this.detector.detect(r);return i.forEach((t=>{t.x+=e,t.y+=n})),this.debugMode&&(s.projectedImage=r.arraySync()),r.dispose(),{featurePoints:i,debugExtra:s}}}(this.inputWidth,this.inputHeight,r),this.inputLoader=new class{width;height;texShape;context;program;tempPixelHandle;constructor(t,e){this.width=t,this.height=e,this.texShape=[e,t];const n=document.createElement("canvas").getContext("2d");n.canvas.width=t,n.canvas.height=e,this.context=n,this.program=this.buildProgram(t,e);const r=jb();this.tempPixelHandle=r.makeTensorInfo(this.texShape,"float32"),r.texData.get(this.tempPixelHandle.dataId).usage=PB.PIXELS}loadInput(t){this.context.drawImage(t,0,0,this.width,this.height);const e=jb();return e.gpgpu.uploadPixelDataToTexture(e.getTexture(this.tempPixelHandle.dataId),this.context.canvas),this._compileAndRun(this.program,[this.tempPixelHandle])}buildProgram(t,e){const n=2===Hf().getNumber("WEBGL_VERSION")?"texture":"texture2D";return{variableNames:["A"],outputShape:this.texShape,userCode:`\n\tvoid main() {\n\t  ivec2 coords = getOutputCoords();\n\t  int texR = coords[0];\n\t  int texC = coords[1];\n\t  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}.0, ${e}.0);\n\n\t  vec4 values = ${n}(A, uv);\n\t  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);\n\t}\n      `}}_compileAndRun(t,e){const n=jb().compileAndRun(t,e);return Bb().makeTensorFromTensorInfo(n)}}(this.inputWidth,this.inputHeight),this.markerDimensions=[],this.onUpdate=n,this.debugMode=r,this.processingVideo=!1,this.interestedTargetIndex=-1,this.trackingStates=[];const u=45*Math.PI/180,c=this.inputHeight/2/Math.tan(u/2);this.projectionTransform=[[c,0,this.inputWidth/2],[0,c,this.inputHeight/2],[0,0,1]],this.projectionMatrix=this._glProjectionMatrix({projectionTransform:this.projectionTransform,width:this.inputWidth,height:this.inputHeight,near:10,far:1e5}),this.worker=new bZ,this.workerMatchDone=null,this.workerTrackDone=null,this.worker.onmessage=t=>{switch(t.data.type){case"matchDone":this.workerMatchDone?.(t.data);break;case"trackUpdateDone":this.workerTrackDone?.(t.data)}}}showTFStats(){console.log(Ub().numTensors),console.table(Ub())}addImageTargets(t){return new Promise((async e=>{const n=await fetch(t),r=await n.arrayBuffer();e(this.addImageTargetsFromBuffer(r))}))}addImageTargetsFromBuffer(t){const e=(new class{data;constructor(){this.data=[]}compileImageTargets(t,e){return new Promise((async n=>{const r=[];for(const e of t){const t=document.createElement("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),s=new Uint8Array(e.width*e.height);for(let t=0;t<s.length;t++){const e=4*t;s[t]=Math.floor((i.data[e]+i.data[e+1]+i.data[e+2])/3)}r.push({data:s,width:e.width,height:e.height})}const i=50/r.length;let s=0;this.data=[];for(let t=0;t<r.length;t++){const n=r[t],a=cZ(n),o=i/a.length,l={targetImage:n,imageList:a,matchingData:await this._extractMatchingFeatures(a,(()=>{s+=o,e(s)}))};this.data.push(l)}for(const[t,e]of r.entries()){const n=hZ(e);this.data[t].trackingImageList=n}const a=await new Promise((t=>{const n=new lZ;n.onmessage=n=>{switch(n.data.type){case"progress":e(50+n.data.percent);break;case"compileDone":t(n.data.list)}},n.postMessage({type:"compile",targetImages:r})}));for(const[t,e]of a.entries())this.data[t].trackingData=e;n(this.data)}))}exportData(){const t=[];for(const e of this.data)t.push({targetImage:{width:e.targetImage.width,height:e.targetImage.height},trackingData:e.trackingData,matchingData:e.matchingData});const e=function(t,e){return void 0===e&&(e=VY),new WY(e.extensionCodec,e.context,e.maxDepth,e.initialBufferSize,e.sortKeys,e.forceFloat32,e.ignoreUndefined,e.forceIntegerToFloat).encodeSharedRef(t)}({v:2,dataList:t});return e}importData(t){const e=function(t,e){return void 0===e&&(e=sZ),new iZ(e.extensionCodec,e.context,e.maxStrLength,e.maxBinLength,e.maxArrayLength,e.maxMapLength,e.maxExtLength).decode(t)}(new Uint8Array(t));if(!e.v||2!==e.v)return console.error("Your compiled .mind might be outdated. Please recompile"),[];const{dataList:n}=e;this.data=[];for(const t of n)this.data.push({targetImage:t.targetImage,trackingData:t.trackingData,matchingData:t.matchingData});return this.data}async _extractMatchingFeatures(t,e){const n=[];for(const[r,i]of t.entries()){const t=new xY(i.width,i.height);await bI(),Wb((()=>{const s=kv(i.data,[i.data.length],"float32").reshape([i.height,i.width]),{featurePoints:a}=t.detect(s),o=a.filter((t=>t.maxima)),l=a.filter((t=>!t.maxima)),u=gZ({points:o}),c=gZ({points:l});n.push({maximaPoints:o,minimaPoints:l,maximaPointsCluster:u,minimaPointsCluster:c,width:i.width,height:i.height,scale:i.scale}),e(r)}))}return n}}).importData(t),n=[],r=[],i=[];for(const t of e)r.push(t.matchingData),n.push(t.trackingData),i.push([t.targetImage.width,t.targetImage.height]);return this.tracker=new class{projectionTransform;trackingKeyframeList;debugMode;kernelCaches;featurePointsListT;imagePixelsListT;imagePropertiesListT;constructor(t,e,n,r,i,s=!1){this.projectionTransform=n,this.debugMode=s,this.trackingKeyframeList=e.map((t=>t[0]));const a=Math.max(...this.trackingKeyframeList.map((({points:t})=>t.length)));this.featurePointsListT=[],this.imagePixelsListT=[],this.imagePropertiesListT=[];for(const[t,e]of this.trackingKeyframeList.entries()){const{featurePoints:n,imagePixels:r,imageProperties:i}=this._prebuild(e,a);this.featurePointsListT[t]=n,this.imagePixelsListT[t]=r,this.imagePropertiesListT[t]=i}this.kernelCaches={}}dummyRun(t){const e=[[1,1,1,1],[1,1,1,1],[1,1,1,1]];for(let n=0;n<this.featurePointsListT.length;n++)this.track(t,e,n)}track(t,e,n){let r={};const i=(a=e,[[(s=this.projectionTransform)[0][0]*a[0][0]+s[0][2]*a[2][0],s[0][0]*a[0][1]+s[0][2]*a[2][1],s[0][0]*a[0][2]+s[0][2]*a[2][2],s[0][0]*a[0][3]+s[0][2]*a[2][3]],[s[1][1]*a[1][0]+s[1][2]*a[2][0],s[1][1]*a[1][1]+s[1][2]*a[2][1],s[1][1]*a[1][2]+s[1][2]*a[2][2],s[1][1]*a[1][3]+s[1][2]*a[2][3]],[a[2][0],a[2][1],a[2][2],a[2][3]]]);var s,a;const o=this._buildAdjustedModelViewTransform(i),l=this.featurePointsListT[n],u=this.imagePixelsListT[n],c=this.imagePropertiesListT[n],h=this._computeProjection(o,t,n),{matchingPointsT:d,simT:p}=this._computeMatching(l,u,c,h),f=d.arraySync(),m=p.arraySync(),g=this.trackingKeyframeList[n],x=[],y=[],v=[];for(const[t,e]of f.entries())if(m[t]>.8&&t<g.points.length){v.push(t);const n=tY(i,e[0],e[1]);y.push(n),x.push({x:g.points[t].x/g.scale,y:g.points[t].y/g.scale,z:0})}return this.debugMode&&(r={projectedImage:h.arraySync(),matchingPoints:f,trackedPoints:y,goodTrack:v}),o.dispose(),h.dispose(),d.dispose(),p.dispose(),{worldCoords:x,screenCoords:y,debugExtra:r}}_prebuild(t,e){return Wb((()=>{const n=t.scale,r=[];for(let i=0;i<e;i++)i<t.points.length?r.push([t.points[i].x/n,t.points[i].y/n]):r.push([-1,-1]);const i=kv(t.data,[t.width*t.height]),s=kv([t.width,t.height,t.scale],[3]);return{featurePoints:kv(r,[r.length,2],"float32"),imagePixels:i,imageProperties:s}}))}_computeMatching(t,e,n,r){const i=r.shape[0],s=r.shape[1],a=t.shape[0];return this.kernelCaches.computeMatching||(this.kernelCaches.computeMatching=((t,e,n,r,i,s,a,o)=>[eY(6,13,n,r,i,s,a,o),nY(n,r,i,o),rY(o)])(0,0,10,1,21,i,s,a)),Wb((()=>{const i=this.kernelCaches.computeMatching,s=this._compileAndRun(i[0],[t,e,n,r]),a=s.argMax(1);return{matchingPointsT:this._compileAndRun(i[1],[t,n,a]),simT:this._compileAndRun(i[2],[s,a])}}))}_computeProjection(t,e,n){const r=this.trackingKeyframeList[n].width,i=this.trackingKeyframeList[n].height,s=this.trackingKeyframeList[n].scale,a=r+"-"+i+"-"+s;return this.kernelCaches.computeProjection||(this.kernelCaches.computeProjection={}),this.kernelCaches.computeProjection[a]||(this.kernelCaches.computeProjection[a]=((t,e,n)=>({variableNames:["M","pixel"],outputShape:[t,e],userCode:`\n\t  void main() {\n\t      ivec2 coords = getOutputCoords();\n\n\t      float m00 = getM(0, 0) * 1000.;\n\t      float m01 = getM(0, 1) * 1000.;\n\t      float m03 = getM(0, 3) * 1000.;\n\t      float m10 = getM(1, 0) * 1000.;\n\t      float m11 = getM(1, 1) * 1000.;\n\t      float m13 = getM(1, 3) * 1000.;\n\t      float m20 = getM(2, 0) * 1000.;\n\t      float m21 = getM(2, 1) * 1000.;\n\t      float m23 = getM(2, 3) * 1000.;\n\n\t      float y = float(coords[0]) / float(${n});\n\t      float x = float(coords[1]) / float(${n});\n\t      float uz = (x * m20) + (y * m21) + m23;\n\t      float oneOverUz = 1. / uz;\n\n\t      float ux = (x * m00) + (y * m01) + m03;\n\t      float uy = (x * m10) + (y * m11) + m13;\n\n\t      ux = floor(ux * oneOverUz + 0.5);\n\t      uy = floor(uy * oneOverUz + 0.5);\n\t      setOutput(getPixel(int(uy), int(ux)));\n\t    }\n\t`}))(i,r,s)),Wb((()=>{const n=this.kernelCaches.computeProjection[a];return this._compileAndRun(n,[t,e])}))}_buildAdjustedModelViewTransform(t){return Wb((()=>kv(t.map((t=>t.map((t=>t/1e3)))),[3,4])))}_compileAndRun(t,e){const n=jb().compileAndRun(t,e);return Bb().makeTensorFromTensorInfo(n)}}(i,n,this.projectionTransform,this.inputWidth,this.inputHeight,this.debugMode),this.worker.postMessage({type:"setup",inputWidth:this.inputWidth,inputHeight:this.inputHeight,projectionTransform:this.projectionTransform,debugMode:this.debugMode,matchingDataList:r}),this.markerDimensions=i,{dimensions:i,matchingDataList:r,trackingDataList:n}}dummyRun(t){const e=this.inputLoader.loadInput(t);this.cropDetector.detect(e),this.tracker.dummyRun(e),e.dispose()}getProjectionMatrix(){return this.projectionMatrix}getWorldMatrix(t,e){return this._glModelViewMatrix(t,e)}async _detectAndMatch(t,e){const{featurePoints:n}=this.cropDetector.detectMoving(t),{targetIndex:r,modelViewTransform:i}=await this._workerMatch(n,e);return{targetIndex:r,modelViewTransform:i}}async _trackAndUpdate(t,e,n){const{worldCoords:r,screenCoords:i}=await this.tracker.track(t,e,n);return r.length<4?null:await this._workerTrackUpdate(e,{worldCoords:r,screenCoords:i})}_glProjectionMatrix(t){const{projectionTransform:e,width:n,height:r,near:i,far:s}=t,a=[[2*e[0][0]/n,0,-(2*e[0][2]/n-1),0],[0,2*e[1][1]/r,-(2*e[1][2]/r-1),0],[0,0,-(s+i)/(s-i),-2*s*i/(s-i)],[0,0,-1,0]],o=[];for(let t=0;t<4;t++)for(let e=0;e<4;e++)o.push(a[e][t]);return o}_glModelViewMatrix(t,e){const n=this.markerDimensions[e][1];return[t[0][0],-t[1][0],-t[2][0],0,-t[0][1],t[1][1],t[2][1],0,-t[0][2],t[1][2],t[2][2],0,t[0][1]*n+t[0][3],-(t[1][1]*n+t[1][3]),-(t[2][1]*n+t[2][3]),1]}async _matchImageTarget(t,e){if(t>=this.maxTrack)return;const n=[];for(const[t,e]of this.trackingStates.entries())e.isTracking||-1!==this.interestedTargetIndex&&this.interestedTargetIndex!==t||n.push(t);const{targetIndex:r,modelViewTransform:i}=await this._detectAndMatch(e,n);-1!==r&&(this.trackingStates[r].isTracking=!0,this.trackingStates[r].currentModelViewTransform=i)}async _updateTrackingState(t,e){const n=this.trackingStates[e];if(!n.isTracking||!n.currentModelViewTransform)return;const r=await this._trackAndUpdate(t,n.currentModelViewTransform,e);null!==r?n.currentModelViewTransform=r:n.isTracking=!1}_showAfterWarmup(t){const e=this.trackingStates[t];!e.showing&&e.isTracking&&(e.trackMiss=0,e.trackCount++,e.trackCount<=this.warmupTolerance||(e.showing=!0,e.trackingMatrix=null,e.filter.reset()))}_hideAfterMiss(t){const e=this.trackingStates[t];e.showing&&(e.isTracking?e.trackMiss=0:(e.trackCount=0,e.trackMiss++,e.trackMiss<this.missTolerance||(e.showing=!1,e.trackingMatrix=null,this.onUpdate?.({type:wZ,targetIndex:t,worldMatrix:null}))))}_onTrackShow(t){const e=this.trackingStates[t];if(!e.showing||!e.currentModelViewTransform)return;const n=this._glModelViewMatrix(e.currentModelViewTransform,t);e.trackingMatrix=e.filter.filter(Date.now(),n),this.onUpdate?.({type:wZ,worldMatrix:gY(e.trackingMatrix),targetIndex:t})}async _doVideoProcessing(t){for(;this.processingVideo;){const e=this.inputLoader.loadInput(t),n=this.trackingStates.reduce(((t,e)=>t+(e.isTracking?1:0)),0);await this._matchImageTarget(n,e);for(const[t]of this.trackingStates.entries())await this._updateTrackingState(e,t),this._showAfterWarmup(t),this._hideAfterMiss(t),this._onTrackShow(t);e.dispose(),this.onUpdate?.({type:"processDone"}),await bI()}}processVideo(t){if(!this.processingVideo){this.processingVideo=!0,this.trackingStates=[];for(let t=0;t<this.maxTrack;t++)this.trackingStates.push({showing:!1,isTracking:!1,currentModelViewTransform:null,trackCount:0,trackMiss:0,filter:new vZ({minCutOff:this.filterMinCF,beta:this.filterBeta})});this._doVideoProcessing(t)}}stopProcessVideo(){this.processingVideo=!1}async detect(t){const e=this.inputLoader.loadInput(t),{featurePoints:n,debugExtra:r}=await this.cropDetector.detect(e);return e.dispose(),{featurePoints:n,debugExtra:r}}async match(t,e){const{modelViewTransform:n,debugExtra:r}=await this._workerMatch(t,[e]);return{modelViewTransform:n,debugExtra:r}}async _workerMatch(t,e){return new Promise((async n=>{this.workerMatchDone=t=>{n({targetIndex:t.targetIndex,modelViewTransform:t.modelViewTransform,debugExtra:t.debugExtra})},this.worker.postMessage({type:"match",featurePoints:t,targetIndexes:e})}))}async track(t,e,n){const r=this.inputLoader.loadInput(t),i=this.tracker.track(r,e,n);return r.dispose(),i}async trackUpdate(t,e){return e.worldCoords.length<4?null:await this._workerTrackUpdate(t,e)}async _workerTrackUpdate(t,e){return new Promise((async n=>{this.workerTrackDone=t=>{n(t.modelViewTransform)};const{worldCoords:r,screenCoords:i}=e;this.worker.postMessage({type:"trackUpdate",modelViewTransform:t,screenCoords:i,worldCoords:r})}))}}({inputWidth:this.video.videoWidth,inputHeight:this.video.videoHeight,filterMinCF:this.filterMinCF,filterBeta:this.filterBeta,warmupTolerance:this.warmupTolerance,missTolerance:this.missTolerance,maxTrack:this.maxTrack,onUpdate:t=>{if(t.type===wZ){const{targetIndex:e,worldMatrix:n}=t;for(let t=0;t<this.anchors.length;t++)if(this.anchors[t].targetIndex===e){if(this.anchors[t].css?this.anchors[t].group.children.forEach((t=>{t.element.style.visibility=n?"visible":"hidden"})):this.anchors[t].group.visible=!!n,n){const r=new Br;r.elements=[...n],r.multiply(this.postMatrixs[e]),this.anchors[t].css&&r.multiply(OZ),this.anchors[t].group.matrix=r}this.anchors[t].visible&&!n&&(this.anchors[t].visible=!1,this.anchors[t].onTargetLost?.()),!this.anchors[t].visible&&n&&(this.anchors[t].visible=!0,this.anchors[t].onTargetFound?.()),n&&this.ui.hideScanning()}}}}),this.resize();const{dimensions:e}=await this.controller.addImageTargets(this.imageTargetSrc);this.postMatrixs=[];for(let t=0;t<e.length;t++){const n=new ur,r=new lr,i=new ur,[s,a]=e[t];n.x=s/2,n.y=s/2+(a-s)/2,i.x=s,i.y=s,i.z=s;const o=new Br;o.compose(n,r,i),this.postMatrixs.push(o)}await this.controller.dummyRun(this.video),this.ui.hideLoading(),this.ui.showScanning(),this.controller.processVideo(this.video),t()}))}resize(){const{renderer:t,cssRenderer:e,camera:n,container:r,video:i,controller:s}=this;if(!i||!s)return;let a,o;const l=i.videoWidth/i.videoHeight;l>r.clientWidth/r.clientHeight?(o=r.clientHeight,a=o*l):(a=r.clientWidth,o=a/l);const u=s.getProjectionMatrix(),c=2*Math.atan(1/u[5]/o*r.clientHeight)*180/Math.PI,h=u[14]/(u[10]-1),d=u[14]/(u[10]+1);n.fov=c,n.near=h,n.far=d,n.aspect=r.clientWidth/r.clientHeight,n.updateProjectionMatrix(),i.style.top=-(o-r.clientHeight)/2+"px",i.style.left=-(a-r.clientWidth)/2+"px",i.style.width=a+"px",i.style.height=o+"px";const p=t.domElement,f=e.domElement;p.style.position="absolute",p.style.left="0",p.style.top="0",p.style.width=r.clientWidth+"px",p.style.height=r.clientHeight+"px",f.style.position="absolute",f.style.left="0",f.style.top="0",f.style.width=r.clientWidth+"px",f.style.height=r.clientHeight+"px",t.setSize(r.clientWidth,r.clientHeight),e.setSize(r.clientWidth,r.clientHeight)}}),window.MINDAR.IMAGE.THREE||(window.MINDAR.IMAGE.THREE=t)})()})();